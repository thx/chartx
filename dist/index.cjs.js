'use strict';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var interopRequireDefault = createCommonjsModule(function (module) {
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(interopRequireDefault);

function unwrapExports$1 (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule$1(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var classCallCheck = createCommonjsModule$1(function (module) {
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _classCallCheck = unwrapExports$1(classCallCheck);

var createClass = createCommonjsModule$1(function (module) {
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _createClass = unwrapExports$1(createClass);

var assertThisInitialized = createCommonjsModule$1(function (module) {
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _assertThisInitialized = unwrapExports$1(assertThisInitialized);

var setPrototypeOf = createCommonjsModule$1(function (module) {
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports$1(setPrototypeOf);

var inherits = createCommonjsModule$1(function (module) {
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _inherits = unwrapExports$1(inherits);

var _typeof_1 = createCommonjsModule$1(function (module) {
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _typeof = unwrapExports$1(_typeof_1);

var possibleConstructorReturn = createCommonjsModule$1(function (module) {
var _typeof = _typeof_1["default"];



function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _possibleConstructorReturn = unwrapExports$1(possibleConstructorReturn);

var getPrototypeOf = createCommonjsModule$1(function (module) {
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _getPrototypeOf = unwrapExports$1(getPrototypeOf);

var _ = {};
var breaker = {};
var ArrayProto = Array.prototype,
    ObjProto = Object.prototype;
 // Create quick reference variables for speed access to core prototypes.

var push = ArrayProto.push,
    slice = ArrayProto.slice,
    concat = ArrayProto.concat,
    toString = ObjProto.toString,
    hasOwnProperty = ObjProto.hasOwnProperty; // All **ECMAScript 5** native function implementations that we hope to use
// are declared here.

var nativeForEach = ArrayProto.forEach,
    nativeMap = ArrayProto.map,
    nativeFilter = ArrayProto.filter,
    nativeEvery = ArrayProto.every,
    nativeSome = ArrayProto.some,
    nativeIndexOf = ArrayProto.indexOf,
    nativeIsArray = Array.isArray,
    nativeKeys = Object.keys;

var shallowProperty = function shallowProperty(key) {
  return function (obj) {
    return obj == null ? void 0 : obj[key];
  };
};

var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
var getLength = shallowProperty('length');

var isArrayLike = function isArrayLike(collection) {
  var length = getLength(collection);
  return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
};

_.values = function (obj) {
  var keys = _.keys(obj);

  var length = keys.length;
  var values = new Array(length);

  for (var i = 0; i < length; i++) {
    values[i] = obj[keys[i]];
  }

  return values;
};

_.keys = nativeKeys || function (obj) {
  if (obj !== Object(obj)) throw new TypeError('Invalid object');
  var keys = [];

  for (var key in obj) {
    if (_.has(obj, key)) keys.push(key);
  }

  return keys;
};

_.has = function (obj, key) {
  return hasOwnProperty.call(obj, key);
};

var each = _.each = _.forEach = function (obj, iterator, context) {
  if (obj == null) return;

  if (nativeForEach && obj.forEach === nativeForEach) {
    obj.forEach(iterator, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, length = obj.length; i < length; i++) {
      if (iterator.call(context, obj[i], i, obj) === breaker) return;
    }
  } else {
    var keys = _.keys(obj);

    for (var i = 0, length = keys.length; i < length; i++) {
      if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
    }
  }
};

_.compact = function (array) {
  return _.filter(array, _.identity);
};

_.filter = _.select = function (obj, iterator, context) {
  var results = [];
  if (obj == null) return results;
  if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
  each(obj, function (value, index, list) {
    if (iterator.call(context, value, index, list)) results.push(value);
  });
  return results;
};

each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function (name) {
  _['is' + name] = function (obj) {
    return toString.call(obj) == '[object ' + name + ']';
  };
}); //if (!_.isArguments(arguments)) {

_.isArguments = function (obj) {
  return !!(obj && _.has(obj, 'callee'));
}; //}


if (typeof /./ !== 'function') {
  _.isFunction = function (obj) {
    return typeof obj === 'function';
  };
}

_.isFinite = function (obj) {
  return isFinite(obj) && !isNaN(parseFloat(obj));
};

_.isNaN = function (obj) {
  return _.isNumber(obj) && obj != +obj;
};

_.isBoolean = function (obj) {
  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
};

_.isNull = function (obj) {
  return obj === null;
};

_.isEmpty = function (obj) {
  if (obj == null) return true;
  if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;

  for (var key in obj) {
    if (_.has(obj, key)) return false;
  }

  return true;
};

_.isElement = function (obj) {
  return !!(obj && obj.nodeType === 1);
};

_.isArray = nativeIsArray || function (obj) {
  return toString.call(obj) == '[object Array]';
};

_.isObject = function (obj) {
  return obj === Object(obj);
};

_.identity = function (value) {
  return value;
};

_.indexOf = function (array, item, isSorted) {
  if (array == null) return -1;
  var i = 0,
      length = array.length;

  if (isSorted) {
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
  }

  if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);

  for (; i < length; i++) {
    if (array[i] === item) return i;
  }

  return -1;
};

_.isWindow = function (obj) {
  return obj != null && obj == obj.window;
}; // Internal implementation of a recursive `flatten` function.


var flatten = function flatten(input, shallow, output) {
  if (shallow && _.every(input, _.isArray)) {
    return concat.apply(output, input);
  }

  each(input, function (value) {
    if (_.isArray(value) || _.isArguments(value)) {
      shallow ? push.apply(output, value) : flatten(value, shallow, output);
    } else {
      output.push(value);
    }
  });
  return output;
}; // Flatten out an array, either recursively (by default), or just one level.


_.flatten = function (array, shallow) {
  return flatten(array, shallow, []);
};

_.every = _.all = function (obj, iterator, context) {
  iterator || (iterator = _.identity);
  var result = true;
  if (obj == null) return result;
  if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
  each(obj, function (value, index, list) {
    if (!(result = result && iterator.call(context, value, index, list))) return breaker;
  });
  return !!result;
}; // Return the minimum element (or element-based computation).


_.min = function (obj, iterator, context) {
  if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
    return Math.min.apply(Math, obj);
  }

  if (!iterator && _.isEmpty(obj)) return Infinity;
  var result = {
    computed: Infinity,
    value: Infinity
  };
  each(obj, function (value, index, list) {
    var computed = iterator ? iterator.call(context, value, index, list) : value;
    computed < result.computed && (result = {
      value: value,
      computed: computed
    });
  });
  return result.value;
}; // Return the maximum element or (element-based computation).
// Can't optimize arrays of integers longer than 65,535 elements.
// See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)


_.max = function (obj, iterator, context) {
  if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
    return Math.max.apply(Math, obj);
  }

  if (!iterator && _.isEmpty(obj)) return -Infinity;
  var result = {
    computed: -Infinity,
    value: -Infinity
  };
  each(obj, function (value, index, list) {
    var computed = iterator ? iterator.call(context, value, index, list) : value;
    computed > result.computed && (result = {
      value: value,
      computed: computed
    });
  });
  return result.value;
}; // Return the first value which passes a truth test. Aliased as `detect`.


_.find = _.detect = function (obj, iterator, context) {
  var result;
  any(obj, function (value, index, list) {
    if (iterator.call(context, value, index, list)) {
      result = value;
      return true;
    }
  });
  return result;
}; // Determine if at least one element in the object matches a truth test.
// Delegates to **ECMAScript 5**'s native `some` if available.
// Aliased as `any`.


var any = _.some = _.any = function (obj, iterator, context) {
  iterator || (iterator = _.identity);
  var result = false;
  if (obj == null) return result;
  if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
  each(obj, function (value, index, list) {
    if (result || (result = iterator.call(context, value, index, list))) return breaker;
  });
  return !!result;
}; // Return a version of the array that does not contain the specified value(s).


_.without = function (array) {
  return _.difference(array, slice.call(arguments, 1));
}; // Take the difference between one array and a number of other arrays.
// Only the elements present in just the first array will remain.


_.difference = function (array) {
  var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
  return _.filter(array, function (value) {
    return !_.contains(rest, value);
  });
}; // Produce a duplicate-free version of the array. If the array has already
// been sorted, you have the option of using a faster algorithm.
// Aliased as `unique`.


_.uniq = _.unique = function (array, isSorted, iterator, context) {
  if (_.isFunction(isSorted)) {
    context = iterator;
    iterator = isSorted;
    isSorted = false;
  }

  var initial = iterator ? _.map(array, iterator, context) : array;
  var results = [];
  var seen = [];
  each(initial, function (value, index) {
    if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
      seen.push(value);
      results.push(array[index]);
    }
  });
  return results;
}; // Return the results of applying the iterator to each element.
// Delegates to **ECMAScript 5**'s native `map` if available.


_.map = _.collect = function (obj, iterator, context) {
  var results = [];
  if (obj == null) return results;
  if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
  each(obj, function (value, index, list) {
    results.push(iterator.call(context, value, index, list));
  });
  return results;
}; // Determine if the array or object contains a given value (using `===`).
// Aliased as `include`.


_.contains = _.include = function (obj, target) {
  if (obj == null) return false;
  if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
  return any(obj, function (value) {
    return value === target;
  });
}; // Convenience version of a common use case of `map`: fetching a property.


_.pluck = function (obj, key) {
  return _.map(obj, function (value) {
    return value[key];
  });
}; // Return a random integer between min and max (inclusive).


_.random = function (min, max) {
  if (max == null) {
    max = min;
    min = 0;
  }

  return min + Math.floor(Math.random() * (max - min + 1));
}; // Shuffle a collection.


_.shuffle = function (obj) {
  return _.sample(obj, Infinity);
};

_.sample = function (obj, n, guard) {
  if (n == null || guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    return obj[_.random(obj.length - 1)];
  }

  var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
  var length = getLength(sample);
  n = Math.max(Math.min(n, length), 0);
  var last = length - 1;

  for (var index = 0; index < n; index++) {
    var rand = _.random(index, last);

    var temp = sample[index];
    sample[index] = sample[rand];
    sample[rand] = temp;
  }

  return sample.slice(0, n);
};
/**
*
*如果是深度extend，第一个参数就设置为true
*/


_.extend = function () {
  var options,
      name,
      src,
      copy,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;

  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }

  if (_typeof(target) !== "object" && !_.isFunction(target)) {
    target = {};
  }

  if (length === i) {
    target = this;
    --i;
  }

  for (; i < length; i++) {
    if ((options = arguments[i]) != null) {
      for (name in options) {
        src = target[name];
        copy = options[name];

        if (target === copy || copy === undefined) {
          continue;
        }

        if (deep && copy && _.isObject(copy) && copy.constructor === Object) {
          target[name] = _.extend(deep, src, copy);
        } else {
          target[name] = copy;
        }
      }
    }
  }

  return target;
};

_.clone = function (obj) {
  if (!_.isObject(obj)) return obj;
  return _.isArray(obj) ? obj.slice() : _.extend(true, {}, obj);
}; //********补存一些数学常用方法,暂放在这里文件下,后期多了单独成立一个类库  */
// compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation


_.euclideanModulo = function (n, m) {
  return (n % m + m) % m;
};

_.DEG2RAD = Math.PI / 180;
_.RAD2DEG = 180 / Math.PI;

_.degToRad = function (degrees) {
  return degrees * _.DEG2RAD;
};

_.radToDeg = function (radians) {
  return radians * _.RAD2DEG;
};

var Settings = {
  //设备分辨率
  RESOLUTION: 1,

  /**
   * Target frames per millisecond.
   */
  TARGET_FPMS: 0.06,

  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   */
  MIPMAP_TEXTURES: true,

  /**
   * Default filter resolution.
   */
  FILTER_RESOLUTION: 1,
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000

  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   */
  SPRITE_BATCH_SIZE: 4096,

  /**
   * The prefix that denotes a URL is for a retina asset.
   */
  RETINA_PREFIX: /@(.+)x/,
  RENDER_OPTIONS: {
    view: null,
    antialias: true,
    forceFXAA: false,
    autoResize: false,
    transparent: true,
    backgroundColor: 0x000000,
    clearBeforeRender: true,
    preserveDrawingBuffer: false,
    roundPixels: false
  },
  TRANSFORM_MODE: 0,
  GC_MODE: 0,
  GC_MAX_IDLE: 60 * 60,
  GC_MAX_CHECK_COUNT: 60 * 10,
  WRAP_MODE: 0,
  SCALE_MODE: 0,
  PRECISION: 'mediump'
};

var addOrRmoveEventHand = function addOrRmoveEventHand(domHand, ieHand) {
  if (!document) return;

  if (document[domHand]) {
    var eventDomFn = function eventDomFn(el, type, fn) {
      if (el.length) {
        for (var i = 0; i < el.length; i++) {
          eventDomFn(el[i], type, fn);
        }
      } else {
        el[domHand](type, fn, false);
      }
    };
    return eventDomFn;
  } else {
    var eventFn = function eventFn(el, type, fn) {
      if (el.length) {
        for (var i = 0; i < el.length; i++) {
          eventFn(el[i], type, fn);
        }
      } else {
        el[ieHand]("on" + type, function () {
          return fn.call(el, window.event);
        });
      }
    };
    return eventFn;
  }
};

var $ = {
  // dom操作相关代码
  query: function query(el) {
    if (!el) return;

    if (_.isString(el)) {
      return document.getElementById(el);
    }

    if (el.nodeType == 1) {
      //则为一个element本身
      return el;
    }

    if (el.length) {
      return el[0];
    }

    return null;
  },
  offset: function offset(el) {
    if (!el) {
      return {
        top: 0,
        left: 0
      };
    }
    var box = el.getBoundingClientRect(),
        doc = el.ownerDocument,
        body = doc.body,
        docElem = doc.documentElement,
        // for ie  
    clientTop = docElem.clientTop || body.clientTop || 0,
        clientLeft = docElem.clientLeft || body.clientLeft || 0,
        // In Internet Explorer 7 getBoundingClientRect property is treated as physical, 
    // while others are logical. Make all logical, like in IE8. 
    zoom = 1;

    if (body.getBoundingClientRect) {
      var bound = body.getBoundingClientRect();
      zoom = (bound.right - bound.left) / body.clientWidth;
    }

    if (zoom > 1) {
      clientTop = 0;
      clientLeft = 0;
    }

    var top = box.top / zoom + (window.pageYOffset || docElem && docElem.scrollTop / zoom || body.scrollTop / zoom) - clientTop,
        left = box.left / zoom + (window.pageXOffset || docElem && docElem.scrollLeft / zoom || body.scrollLeft / zoom) - clientLeft;
    return {
      top: top,
      left: left
    };
  },
  addEvent: addOrRmoveEventHand("addEventListener", "attachEvent"),
  removeEvent: addOrRmoveEventHand("removeEventListener", "detachEvent"),
  pageX: function pageX(e) {
    if (e.pageX) return e.pageX;else if (e.clientX) return e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);else return null;
  },
  pageY: function pageY(e) {
    if (e.pageY) return e.pageY;else if (e.clientY) return e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);else return null;
  },

  /**
   * 创建dom
   * @param {string} id dom id 待用
   * @param {string} type : dom type， such as canvas, div etc.
   */
  createCanvas: function createCanvas(_width, _height, id) {
    if (!document) return;
    var canvas = document.createElement("canvas");
    canvas.style.position = 'absolute';
    canvas.style.width = _width + 'px';
    canvas.style.height = _height + 'px';
    canvas.style.left = 0;
    canvas.style.top = 0;
    canvas.setAttribute('width', _width * Settings.RESOLUTION);
    canvas.setAttribute('height', _height * Settings.RESOLUTION);
    canvas.setAttribute('id', id);
    return canvas;
  },
  createView: function createView(_width, _height, id) {
    var view = document.createElement("div");
    view.className = "canvax-view";
    view.style.cssText += "position:relative;width:100%;height:100%;";
    var stageView = document.createElement("div");
    stageView.style.cssText += "position:absolute;width:" + _width + "px;height:" + _height + "px;"; //用来存放一些dom元素

    var domView = document.createElement("div");
    domView.style.cssText += "position:absolute;width:" + _width + "px;height:" + _height + "px;";
    view.appendChild(stageView);
    view.appendChild(domView);
    return {
      view: view,
      stageView: stageView,
      domView: domView
    };
  } //dom相关代码结束

};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com 
*/
var Utils = {
  mainFrameRate: 60,
  //默认主帧率
  now: 0,

  /*给文本检测高宽专用*/
  _pixelCtx: null,
  __emptyFunc: function __emptyFunc() {},
  //retina 屏幕优化
  _UID: 0,
  //该值为向上的自增长整数值
  getUID: function getUID() {
    return this._UID++;
  },
  createId: function createId(name) {
    //if end with a digit, then append an undersBase before appending
    var charCode = name.charCodeAt(name.length - 1);
    if (charCode >= 48 && charCode <= 57) name += "_";
    return name + Utils.getUID();
  },
  canvasSupport: function canvasSupport() {
    return !!document.createElement('canvas').getContext;
  },
  initElement: function initElement(canvas) {
    if (!window) return;

    if (window.FlashCanvas && FlashCanvas.initElement) {
      FlashCanvas.initElement(canvas);
    }
    return canvas;
  },

  /**
   * 按照css的顺序，返回一个[上,右,下,左]
   */
  getCssOrderArr: function getCssOrderArr(r) {
    var r1;
    var r2;
    var r3;
    var r4;

    if (typeof r === 'number') {
      r1 = r2 = r3 = r4 = r;
    } else if (r instanceof Array) {
      if (r.length === 1) {
        r1 = r2 = r3 = r4 = r[0];
      } else if (r.length === 2) {
        r1 = r3 = r[0];
        r2 = r4 = r[1];
      } else if (r.length === 3) {
        r1 = r[0];
        r2 = r4 = r[1];
        r3 = r[2];
      } else {
        r1 = r[0];
        r2 = r[1];
        r3 = r[2];
        r4 = r[3];
      }
    } else {
      r1 = r2 = r3 = r4 = 0;
    }

    return [r1, r2, r3, r4];
  },
  isWebGLSupported: function isWebGLSupported() {
    var contextOptions = {
      stencil: true
    };

    try {
      if (!window.WebGLRenderingContext) //不存在直接return
        {
          return false;
        }

      var canvas = document.createElement('canvas'),
          gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);
      return !!(gl && gl.getContextAttributes().stencil); //还要确实检测是否支持webGL模式
    } catch (e) {
      return false;
    }
  },
  checkOpt: function checkOpt(opt) {
    if (!opt) {
      opt = {
        context: {}
      };
    } else {
      if (!opt.context) {
        opt.context = {};
      }
    }

    return opt;
  }
};

var _canvas = Utils.initElement($.createCanvas(1, 1, "_pixelCanvas"));

Utils._pixelCtx = _canvas && _canvas.getContext('2d');

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * canvas 上委托的事件管理
 */

var Event = function Event(evt) {
  var eventType = "CanvaxEvent";

  if (_.isString(evt)) {
    eventType = evt;
  }

  if (_.isObject(evt) && evt.type) {
    eventType = evt.type;

    _.extend(this, evt);
  }
  this.target = null;
  this.currentTarget = null;
  this.type = eventType;
  this.point = null;
  var me = this;
  this._stopPropagation = false; //默认不阻止事件冒泡

  this.stopPropagation = function () {
    me._stopPropagation = true;

    if (_.isObject(evt)) {
      evt._stopPropagation = true;
    }
  };

  this._preventDefault = false; //是否组织事件冒泡

  this.preventDefault = function () {
    me._preventDefault = true;

    if (_.isObject(evt)) {
      evt._preventDefault = true;
    }
  };
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * canvas 上委托的事件管理
 */
var _mouseEvents = 'mousedown mouseup mouseover mousemove mouseout click dblclick wheel keydown keypress keyup';
var types = {
  _types: _mouseEvents.split(/,| /),
  register: function register(evts) {
    if (!evts) {
      return;
    }

    if (_.isString(evts)) {
      evts = evts.split(/,| /);
    }
    this._types = _mouseEvents.split(/,| /).concat(evts);
  },
  get: function get() {
    return this._types;
  }
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 事件管理类
 */
/**
 * 构造函数.
 * @name EventDispatcher
 * @class EventDispatcher类是可调度事件的类的基类，它允许显示列表上的任何对象都是一个事件目标。
 */

var Manager = function Manager() {
  //事件映射表，格式为：{type1:[listener1, listener2], type2:[listener3, listener4]}
  this._eventMap = {};
};

Manager.prototype = {
  /**
   * 判断events里面是否有用户交互事件
   */
  _setEventEnable: function _setEventEnable() {
    if (this.children) return; //容器的_eventEnabled不受注册的用户交互事件影响

    var hasInteractionEvent = false;

    for (var t in this._eventMap) {
      if (_.indexOf(types.get(), t) > -1) {
        hasInteractionEvent = true;
      }
    }
    this._eventEnabled = hasInteractionEvent;
  },

  /*
   * 注册事件侦听器对象，以使侦听器能够接收事件通知。
   */
  _addEventListener: function _addEventListener(_type, listener) {
    if (typeof listener != "function") {
      //listener必须是个function呐亲
      return false;
    }

    var addResult = true;
    var self = this;
    var types = _type;

    if (_.isString(_type)) {
      types = _type.split(/,| /);
    }

    _.each(types, function (type) {
      var map = self._eventMap[type];

      if (!map) {
        map = self._eventMap[type] = [];
        map.push(listener); //self._eventEnabled = true;

        self._setEventEnable();

        return true;
      }

      if (_.indexOf(map, listener) == -1) {
        map.push(listener); //self._eventEnabled = true;

        self._setEventEnable();

        return true;
      }

      addResult = false;
    });

    return addResult;
  },

  /**
   * 删除事件侦听器。
   */
  _removeEventListener: function _removeEventListener(type, listener) {
    if (arguments.length == 1) return this.removeEventListenerByType(type);
    var map = this._eventMap[type];

    if (!map) {
      return false;
    }

    for (var i = 0; i < map.length; i++) {
      var li = map[i];

      if (li === listener) {
        map.splice(i, 1);

        if (map.length == 0) {
          delete this._eventMap[type];

          this._setEventEnable(); //如果这个如果这个时候child没有任何事件侦听

          /*
          if(_.isEmpty(this._eventMap)){
              //那么该元素不再接受事件的检测
              this._eventEnabled = false;
          }
          */

        }

        return true;
      }
    }

    return false;
  },

  /**
   * 删除指定类型的所有事件侦听器。
   */
  _removeEventListenerByType: function _removeEventListenerByType(type) {
    var map = this._eventMap[type];

    if (!map) {
      delete this._eventMap[type];

      this._setEventEnable(); //如果这个如果这个时候child没有任何事件侦听

      /*
      if(_.isEmpty(this._eventMap)){
          //那么该元素不再接受事件的检测
          this._eventEnabled = false;
      }
      */


      return true;
    }

    return false;
  },

  /**
   * 删除所有事件侦听器。
   */
  _removeAllEventListeners: function _removeAllEventListeners() {
    this._eventMap = {};
    this._eventEnabled = false;
  },

  /**
  * 派发事件，调用事件侦听器。
  */
  _dispatchEvent: function _dispatchEvent(e) {
    var map = this._eventMap[e.type];

    if (map) {
      if (!e.target) e.target = this;
      if (!e.currentTarget) e.currentTarget = this;
      map = map.slice();

      for (var i = 0; i < map.length; i++) {
        var listener = map[i];

        if (typeof listener == "function") {
          listener.call(this, e);
        }
      }
    }

    if (!e._stopPropagation) {
      //向上冒泡
      if (this.parent) {
        e.currentTarget = this.parent;

        this.parent._dispatchEvent(e);
      }
    }

    return true;
  },

  /**
     * 检查是否为指定事件类型注册了任何侦听器。
     */
  _hasEventListener: function _hasEventListener(type) {
    var map = this._eventMap[type];
    return map != null && map.length > 0;
  }
};

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Dispatcher = /*#__PURE__*/function (_Manager) {
  _inherits(Dispatcher, _Manager);

  var _super = _createSuper(Dispatcher);

  function Dispatcher() {
    _classCallCheck(this, Dispatcher);

    return _super.call(this);
  }

  _createClass(Dispatcher, [{
    key: "on",
    value: function on(type, listener) {
      this._addEventListener(type, listener);

      return this;
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      this._addEventListener(type, listener);

      return this;
    }
  }, {
    key: "un",
    value: function un(type, listener) {
      this._removeEventListener(type, listener);

      return this;
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener) {
      this._removeEventListener(type, listener);

      return this;
    }
  }, {
    key: "removeEventListenerByType",
    value: function removeEventListenerByType(type) {
      this._removeEventListenerByType(type);

      return this;
    }
  }, {
    key: "removeAllEventListeners",
    value: function removeAllEventListeners() {
      this._removeAllEventListeners();

      return this;
    } //params 要传给evt的eventhandler处理函数的参数，会被merge到Canvax event中

  }, {
    key: "fire",
    value: function fire(eventType, params) {
      //{currentTarget,point,target,type,_stopPropagation}
      var e = new Event(eventType);

      if (params) {
        for (var p in params) {
          if (p != "type") {
            e[p] = params[p];
          }
        }
      }
      var me = this;

      _.each(eventType.split(" "), function (eType) {
        //然后，currentTarget要修正为自己
        e.currentTarget = me;
        me.dispatchEvent(e);
      });

      return this;
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(evt) {
      //this instanceof DisplayObjectContainer ==> this.children
      //TODO: 这里import DisplayObjectContainer 的话，在displayObject里面的import EventDispatcher from "../event/EventDispatcher";
      //会得到一个undefined，感觉是成了一个循环依赖的问题，所以这里换用简单的判断来判断自己是一个容易，拥有children
      if (this.children && evt.point) {
        var target = this.getObjectsUnderPoint(evt.point, 1)[0];

        if (target) {
          target.dispatchEvent(evt);
        }

        return;
      }

      if (this.context && evt.type == "mouseover") {
        //记录dispatchEvent之前的心跳
        var preHeartBeat = this._heartBeatNum;
        var pregAlpha = this.context.$model.globalAlpha;

        this._dispatchEvent(evt);

        if (preHeartBeat != this._heartBeatNum) {
          this._hoverClass = true;

          if (this.hoverClone) {
            var canvax = this.getStage().parent; //然后clone一份obj，添加到_bufferStage 中

            var activShape = this.clone(true);
            activShape._transform = this.getConcatenatedMatrix();

            canvax._bufferStage.addChildAt(activShape, 0); //然后把自己隐藏了
            //用一个临时变量_globalAlpha 来存储自己之前的alpha


            this._globalAlpha = pregAlpha;
            this.context.globalAlpha = 0;
          }
        }

        return;
      }

      this._dispatchEvent(evt);

      if (this.context && evt.type == "mouseout") {
        if (this._hoverClass && this.hoverClone) {
          //说明刚刚over的时候有添加样式
          var canvax = this.getStage().parent;
          this._hoverClass = false;

          canvax._bufferStage.removeChildById(this.id);

          if (this._globalAlpha) {
            this.context.globalAlpha = this._globalAlpha;
            delete this._globalAlpha;
          }
        }
      }

      return this;
    }
  }, {
    key: "hasEvent",
    value: function hasEvent(type) {
      return this._hasEventListener(type);
    }
  }, {
    key: "hasEventListener",
    value: function hasEventListener(type) {
      return this._hasEventListener(type);
    }
  }, {
    key: "hover",
    value: function hover(overFun, outFun) {
      this.on("mouseover", overFun);
      this.on("mouseout", outFun);
      return this;
    }
  }, {
    key: "once",
    value: function once(type, listener) {
      var me = this;

      var onceHandle = function onceHandle() {
        listener.apply(me, arguments);
        this.un(type, onceHandle);
      };

      this.on(type, onceHandle);
      return this;
    }
  }]);

  return Dispatcher;
}(Manager);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 */

var Handler = function Handler(canvax) {
  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  this.canvax = canvax;
  this.curPoints = [{
    x: 0,
    y: 0
  }]; //X,Y 的 point 集合, 在touch下面则为 touch的集合，只是这个touch被添加了对应的x，y
  //当前激活的点对应的obj，在touch下可以是个数组,和上面的 curPoints 对应

  this.curPointsTarget = [];
  this._touching = false; //正在拖动，前提是_touching=true

  this._draging = false; //当前的鼠标状态

  this._cursor = "default";
  this.target = this.canvax.view; //mouse体统中不需要配置drag,touch中会用到第三方的touch库，每个库的事件名称可能不一样，
  //就要这里配置，默认实现的是hammerjs的,所以默认可以在项目里引入hammerjs http://hammerjs.github.io/

  this.drag = {
    start: "panstart",
    move: "panmove",
    end: "panend"
  };
  this._opt = opt;

  _.extend(true, this, opt);
}; //这样的好处是document.compareDocumentPosition只会在定义的时候执行一次。


var contains = document && document.compareDocumentPosition ? function (parent, child) {
  if (!child) {
    return false;
  }
  return !!(parent.compareDocumentPosition(child) & 16);
} : function (parent, child) {
  if (!child) {
    return false;
  }

  return child !== child && (parent.contains ? parent.contains(child) : true);
};
Handler.prototype = {
  init: function init() {
    //依次添加上浏览器的自带事件侦听
    var me = this;

    if (this._opt.events) {
      types.register(this._opt.events);
    }

    if (me.target) {
      if (me.target.nodeType == undefined) ;

      $.addEvent(me.target, "contextmenu", function (e) {
        if (e && e.preventDefault) {
          e.preventDefault();
        } else {
          window.event.returnValue = false;
        }
      });

      _.each(types.get(), function (type) {
        //不再关心浏览器环境是否 'ontouchstart' in window 
        //而是直接只管传给事件模块的是一个原生dom还是 jq对象 or hammer对象等
        if (me.target.nodeType == 1) {
          $.addEvent(me.target, type, function (e) {
            me.__mouseHandler(e);
          });
        } else {
          me.target.on(type, function (e) {
            me.__libHandler(e);
          });
        }
      });
    }
  },
  bindEventHandle: function bindEventHandle(e, type) {
    if (type == 'mouse') {
      this.__mouseHandler.apply(this, [e]);
    } else {
      this.__libHandler.apply(this, [e]);
    }
  },

  /*
  * 原生事件系统------------------------------------------------begin
  * 鼠标事件处理函数
  **/
  __mouseHandler: function __mouseHandler(e) {
    var me = this;
    var root = me.canvax;
    root.updateViewOffset();
    me.curPoints = [{
      x: $.pageX(e) - root.viewOffset.left,
      y: $.pageY(e) - root.viewOffset.top
    }]; //理论上来说，这里拿到point了后，就要计算这个point对应的target来push到curPointsTarget里，
    //但是因为在drag的时候其实是可以不用计算对应target的。
    //所以放在了下面的me.__getcurPointsTarget( e , curMousePoint );常规mousemove中执行

    var curMousePoint = me.curPoints[0];
    var curMouseTarget = me.curPointsTarget[0];

    if ( //这几个事件触发过来，是一定需要检测 curMouseTarget 的
    _.indexOf(['mousedown', 'mouseover', 'click'], e.type) > -1 && !curMouseTarget) {
      if (!curMouseTarget) {
        var obj = root.getObjectsUnderPoint(curMousePoint, 1)[0];

        if (obj) {
          me.curPointsTarget = [obj];
        }
      }
      curMouseTarget = me.curPointsTarget[0];
    }
    //mousedown的时候 如果 curMouseTarget.dragEnabled 为true。就要开始准备drag了

    if (e.type == "mousedown") {
      //如果curTarget 的数组为空或者第一个为false ，，，
      if (curMouseTarget && curMouseTarget.dragEnabled) {
        //鼠标事件已经摸到了一个
        me._touching = true;
      }
    }

    if (e.type == "mouseup" || e.type == "mouseout" && !contains(root.view, e.toElement || e.relatedTarget)) {
      if (me._draging == true) {
        //说明刚刚在拖动
        me._dragEnd(e, curMouseTarget, 0);

        curMouseTarget.fire("dragend");
      }
      me._draging = false;
      me._touching = false;
    }

    if (e.type == "mouseout") {
      if (!contains(root.view, e.toElement || e.relatedTarget)) {
        me.__getcurPointsTarget(e, curMousePoint, true);
      }
    } else if (e.type == "mousemove") {
      //|| e.type == "mousedown" ){
      //拖动过程中就不在做其他的mouseover检测，drag优先
      if (me._touching && e.type == "mousemove" && curMouseTarget) {
        //说明正在拖动啊
        if (!me._draging) {
          //begin drag
          curMouseTarget.fire("dragstart"); //有可能该child没有hover style

          if (!curMouseTarget._globalAlpha) {
            curMouseTarget._globalAlpha = curMouseTarget.context.$model.globalAlpha;
          }

          curMouseTarget.context.globalAlpha = 0; //然后克隆一个副本到activeStage

          var cloneObject = me._clone2hoverStage(curMouseTarget, 0);

          cloneObject.context.globalAlpha = curMouseTarget._globalAlpha;
        } else {
          //drag move ing
          me._dragIngHander(e, curMouseTarget, 0);
        }
        me._draging = true;
      } else {
        //常规mousemove检测
        //move事件中，需要不停的搜索target，这个开销挺大，
        //后续可以优化，加上和帧率相当的延迟处理
        me.__getcurPointsTarget(e, curMousePoint);
      }
    } else {
      //其他的事件就直接在target上面派发事件
      var child = curMouseTarget;

      if (!child) {
        child = root;
      }

      me.__dispatchEventInChilds(e, [child]);

      me._cursorHander(child);
    }

    if (root.preventDefault || e._preventDefault) {
      //阻止默认浏览器动作(W3C) 
      if (e && e.preventDefault) {
        e.preventDefault();
      } else {
        window.event.returnValue = false;
      }
    }
  },
  //notInRootView 真正的mouseout,鼠标已经不在图表的节点内了
  __getcurPointsTarget: function __getcurPointsTarget(e, point, notInRootView) {
    var me = this;
    var root = me.canvax;
    var oldObj = me.curPointsTarget[0];

    if (oldObj && !oldObj.context) {
      oldObj = null;
    }
    var e = new Event(e);

    if (e.type == "mousemove" && oldObj && oldObj._hoverClass && oldObj.hoverClone && oldObj.pointChkPriority && oldObj.getChildInPoint(point)) {
      //小优化,鼠标move的时候。计算频率太大，所以。做此优化
      //如果有target存在，而且当前元素正在hoverStage中，而且当前鼠标还在target内,就没必要取检测整个displayList了
      //开发派发常规mousemove事件
      e.target = e.currentTarget = oldObj;
      e.point = oldObj.globalToLocal(point);
      oldObj.dispatchEvent(e);
      return;
    }
    var obj = notInRootView ? null : root.getObjectsUnderPoint(point, 1)[0];

    if (oldObj && oldObj != obj || e.type == "mouseout") {
      if (oldObj && oldObj.context) {
        me.curPointsTarget[0] = null;
        e.type = "mouseout";
        e.toTarget = obj;
        e.target = e.currentTarget = oldObj;
        e.point = oldObj.globalToLocal(point);
        oldObj.dispatchEvent(e);
      }
    }

    if (obj && oldObj != obj) {
      me.curPointsTarget[0] = obj;
      e.type = "mouseover";
      e.fromTarget = oldObj;
      e.target = e.currentTarget = obj;
      e.point = obj.globalToLocal(point);
      obj.dispatchEvent(e);
    }

    if (e.type == "mousemove" && obj) {
      e.target = e.currentTarget = oldObj;
      e.point = oldObj.globalToLocal(point);
      oldObj.dispatchEvent(e);
    }

    me._cursorHander(obj, oldObj);
  },
  _cursorHander: function _cursorHander(obj, oldObj) {
    if (!obj && !oldObj) {
      this._setCursor("default");
    }

    if (obj && oldObj != obj && obj.context) {
      this._setCursor(obj.context.$model.cursor);
    }
  },
  _setCursor: function _setCursor(cursor) {
    if (this._cursor == cursor) {
      //如果两次要设置的鼠标状态是一样的
      return;
    }
    this.canvax.view.style.cursor = cursor;
    this._cursor = cursor;
  },

  /*
  * 原生事件系统------------------------------------------------end
  */

  /*
   *第三方库的事件系统------------------------------------------------begin
   *触屏事件处理函数
   * */
  __libHandler: function __libHandler(e) {
    var me = this;
    var root = me.canvax;
    root.updateViewOffset(); // touch 下的 curPointsTarget 从touches中来
    //获取canvax坐标系统里面的坐标

    me.curPoints = me.__getCanvaxPointInTouchs(e);

    if (!me._draging) {
      //如果在draging的话，target已经是选中了的，可以不用 检测了
      me.curPointsTarget = me.__getChildInTouchs(me.curPoints);
    }

    if (me.curPointsTarget.length > 0) {
      //drag开始
      if (me.drag.start.indexOf(e.type) > -1) {
        //dragstart的时候touch已经准备好了target， curPointsTarget 里面只要有一个是有效的
        //就认为drags开始
        _.each(me.curPointsTarget, function (child, i) {
          if (child && child.dragEnabled) {
            //只要有一个元素就认为正在准备drag了
            me._draging = true; //有可能该child没有hover style

            if (!child._globalAlpha) {
              child._globalAlpha = child.context.$model.globalAlpha;
            }

            me._clone2hoverStage(child, i); //先把本尊给隐藏了


            child.context.globalAlpha = 0;
            child.fire("dragstart");
            return false;
          }
        });
      }

      if (me.drag.move.indexOf(e.type) > -1) {
        if (me._draging) {
          _.each(me.curPointsTarget, function (child, i) {
            if (child && child.dragEnabled) {
              me._dragIngHander(e, child, i);
            }
          });
        }
      }

      if (me.drag.end.indexOf(e.type) > -1) {
        if (me._draging) {
          _.each(me.curPointsTarget, function (child, i) {
            if (child && child.dragEnabled) {
              me._dragEnd(e, child, 0);

              child.fire("dragend");
            }
          });

          me._draging = false;
        }
      }

      me.__dispatchEventInChilds(e, me.curPointsTarget);
    } else {
      //如果当前没有一个target，就把事件派发到canvax上面
      me.__dispatchEventInChilds(e, [root]);
    }
  },
  //从touchs中获取到对应touch , 在上面添加上canvax坐标系统的x，y
  __getCanvaxPointInTouchs: function __getCanvaxPointInTouchs(e) {
    var me = this;
    var root = me.canvax;
    var curTouchs = [];

    _.each(e.point || e.touches, function (touch) {
      curTouchs.push({
        x: 'x' in touch ? touch.x : $.pageX(touch) - root.viewOffset.left,
        y: 'y' in touch ? touch.y : $.pageY(touch) - root.viewOffset.top
      });
    });

    return curTouchs;
  },
  __getChildInTouchs: function __getChildInTouchs(touchs) {
    var me = this;
    var root = me.canvax;
    var touchesTarget = [];

    _.each(touchs, function (touch) {
      touchesTarget.push(root.getObjectsUnderPoint(touch, 1)[0]);
    });

    return touchesTarget;
  },

  /*
  *第三方库的事件系统------------------------------------------------end
  */

  /*
   *@param {array} childs 
   * */
  __dispatchEventInChilds: function __dispatchEventInChilds(e, childs) {
    if (!childs && !("length" in childs)) {
      return false;
    }

    var me = this;

    _.each(childs, function (child, i) {
      if (child) {
        var ce = new Event(e); //ce.target = ce.currentTarget = child || this;

        ce.stagePoint = me.curPoints[i];
        ce.point = child.globalToLocal(ce.stagePoint);
        child.dispatchEvent(ce);
      }
    });
  },
  //克隆一个元素到hover stage中去
  _clone2hoverStage: function _clone2hoverStage(target, i) {
    var me = this;
    var root = me.canvax;

    var _dragDuplicate = root._bufferStage.getChildById(target.id);

    if (!_dragDuplicate) {
      _dragDuplicate = target.clone(true);
      _dragDuplicate._transform = target.getConcatenatedMatrix();
      /**
       *TODO: 因为后续可能会有手动添加的 元素到_bufferStage 里面来
       *比如tips
       *这类手动添加进来的肯定是因为需要显示在最外层的。在hover元素之上。
       *所有自动添加的hover元素都默认添加在_bufferStage的最底层
       **/

      root._bufferStage.addChildAt(_dragDuplicate, 0);
    }

    _dragDuplicate.context.globalAlpha = target._globalAlpha;
    target._dragPoint = target.globalToLocal(me.curPoints[i]);
    return _dragDuplicate;
  },
  //drag 中 的处理函数
  _dragIngHander: function _dragIngHander(e, target, i) {
    var me = this;
    var root = me.canvax;

    var _point = target.globalToLocal(me.curPoints[i]); //要对应的修改本尊的位置，但是要告诉引擎不要watch这个时候的变化


    target._noHeart = true;
    var _moveStage = target.moveing;
    target.moveing = true;
    target.context.x += _point.x - target._dragPoint.x;
    target.context.y += _point.y - target._dragPoint.y;
    target.fire("draging");
    target.moveing = _moveStage;
    target._noHeart = false; //同步完毕本尊的位置
    //这里只能直接修改_transform 。 不能用下面的修改x，y的方式。

    var _dragDuplicate = root._bufferStage.getChildById(target.id);

    _dragDuplicate._transform = target.getConcatenatedMatrix(); //worldTransform在renderer的时候计算

    _dragDuplicate.worldTransform = null; //setWorldTransform都统一在render中执行，这里注释掉
    //_dragDuplicate.setWorldTransform();
    //直接修改的_transform不会出发心跳上报， 渲染引擎不制动这个stage需要绘制。
    //所以要手动出发心跳包

    _dragDuplicate.heartBeat();
  },
  //drag结束的处理函数
  //TODO: dragend的还需要处理end的点是否还在元素上面，要恢复hover状态
  _dragEnd: function _dragEnd(e, target, i) {
    var me = this;
    var root = me.canvax; //_dragDuplicate 复制在_bufferStage 中的副本

    var _dragDuplicate = root._bufferStage.getChildById(target.id);

    _dragDuplicate && _dragDuplicate.destroy();
    target.context.globalAlpha = target._globalAlpha;
  }
};

var event = {
  Event: Event,
  Dispatcher: Dispatcher,
  Handler: Handler,
  Manager: Manager,
  types: types
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * | a | c | tx|
 * | b | d | ty|
 * | 0 | 0 | 1 |
 *
 * @class
 * @memberof PIXI
 *
 *
 * Matrix 矩阵库 用于整个系统的几何变换计算
 */
var Matrix = function Matrix(a, b, c, d, tx, ty) {
  this.a = a != undefined ? a : 1;
  this.b = b != undefined ? b : 0;
  this.c = c != undefined ? c : 0;
  this.d = d != undefined ? d : 1;
  this.tx = tx != undefined ? tx : 0;
  this.ty = ty != undefined ? ty : 0;
  this.array = null;
};

Matrix.prototype = {
  concat: function concat(mtx) {
    var a = this.a;
    var c = this.c;
    var tx = this.tx;
    this.a = a * mtx.a + this.b * mtx.c;
    this.b = a * mtx.b + this.b * mtx.d;
    this.c = c * mtx.a + this.d * mtx.c;
    this.d = c * mtx.b + this.d * mtx.d;
    this.tx = tx * mtx.a + this.ty * mtx.c + mtx.tx;
    this.ty = tx * mtx.b + this.ty * mtx.d + mtx.ty;
    return this;
  },
  concatTransform: function concatTransform(x, y, scaleX, scaleY, rotation) {
    var cos = 1;
    var sin = 0;

    if (rotation % 360) {
      var r = rotation * Math.PI / 180;
      cos = Math.cos(r);
      sin = Math.sin(r);
    }

    this.concat(new Matrix(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y));
    return this;
  },
  rotate: function rotate(angle) {
    //目前已经提供对顺时针逆时针两个方向旋转的支持
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var a = this.a;
    var c = this.c;
    var tx = this.tx;

    if (angle > 0) {
      this.a = a * cos - this.b * sin;
      this.b = a * sin + this.b * cos;
      this.c = c * cos - this.d * sin;
      this.d = c * sin + this.d * cos;
      this.tx = tx * cos - this.ty * sin;
      this.ty = tx * sin + this.ty * cos;
    } else {
      var st = Math.sin(Math.abs(angle));
      var ct = Math.cos(Math.abs(angle));
      this.a = a * ct + this.b * st;
      this.b = -a * st + this.b * ct;
      this.c = c * ct + this.d * st;
      this.d = -c * st + ct * this.d;
      this.tx = ct * tx + st * this.ty;
      this.ty = ct * this.ty - st * tx;
    }

    return this;
  },
  scale: function scale(sx, sy) {
    this.a *= sx;
    this.d *= sy;
    this.tx *= sx;
    this.ty *= sy;
    return this;
  },
  translate: function translate(dx, dy) {
    this.tx += dx;
    this.ty += dy;
    return this;
  },
  identity: function identity() {
    //初始化
    this.a = this.d = 1;
    this.b = this.c = this.tx = this.ty = 0;
    return this;
  },
  invert: function invert() {
    //逆向矩阵
    var a = this.a;
    var b = this.b;
    var c = this.c;
    var d = this.d;
    var tx = this.tx;
    var i = a * d - b * c;
    this.a = d / i;
    this.b = -b / i;
    this.c = -c / i;
    this.d = a / i;
    this.tx = (c * this.ty - d * tx) / i;
    this.ty = -(a * this.ty - b * tx) / i;
    return this;
  },
  clone: function clone() {
    return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
  },
  toArray: function toArray(transpose, out) {
    if (arguments.length == 0) {
      //canvas2d 中不会有任何的参数传入
      if (isNaN(this.a) || isNaN(this.b) || isNaN(this.c) || isNaN(this.d) || isNaN(this.tx) || isNaN(this.ty)) {
        //不是一个合格的矩阵
        return null;
      }
      return [this.a, this.b, this.c, this.d, this.tx, this.ty];
    } //webgl的glsl需要用的时候，需要传入transpose 来转换为一个3*3完整矩阵


    if (!this.array) {
      this.array = new Float32Array(9);
    }

    var array = out || this.array;

    if (transpose) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }

    return array;
  },

  /**
   * 矩阵左乘向量
   */
  mulVector: function mulVector(v) {
    var aa = this.a,
        ac = this.c,
        atx = this.tx;
    var ab = this.b,
        ad = this.d,
        aty = this.ty;
    var out = [0, 0];
    out[0] = v[0] * aa + v[1] * ac + atx;
    out[1] = v[0] * ab + v[1] * ad + aty;
    return out;
  }
};

/**
 * Point
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 */
var Point = /*#__PURE__*/function () {
  function Point() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, Point);

    if (arguments.length == 1 && _typeof(arguments[0]) == 'object') {
      var arg = arguments[0];

      if ("x" in arg && "y" in arg) {
        this.x = arg.x * 1;
        this.y = arg.y * 1;
      } else {
        var i = 0;

        for (var p in arg) {
          if (i == 0) {
            this.x = arg[p] * 1;
          } else {
            this.y = arg[p] * 1;
            break;
          }

          i++;
        }
      }
    } else {
      this.x = x * 1;
      this.y = y * 1;
    }
  }

  _createClass(Point, [{
    key: "toArray",
    value: function toArray() {
      return [this.x, this.y];
    }
  }]);

  return Point;
}();

/**
 * The Ease class provides a collection of easing functions for use with tween.js.
 */
var Easing = {
    Linear: {
        None: function (amount) {
            return amount;
        },
    },
    Quadratic: {
        In: function (amount) {
            return amount * amount;
        },
        Out: function (amount) {
            return amount * (2 - amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount;
            }
            return -0.5 * (--amount * (amount - 2) - 1);
        },
    },
    Cubic: {
        In: function (amount) {
            return amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount + 2);
        },
    },
    Quartic: {
        In: function (amount) {
            return amount * amount * amount * amount;
        },
        Out: function (amount) {
            return 1 - --amount * amount * amount * amount;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount;
            }
            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
        },
    },
    Quintic: {
        In: function (amount) {
            return amount * amount * amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
        },
    },
    Sinusoidal: {
        In: function (amount) {
            return 1 - Math.cos((amount * Math.PI) / 2);
        },
        Out: function (amount) {
            return Math.sin((amount * Math.PI) / 2);
        },
        InOut: function (amount) {
            return 0.5 * (1 - Math.cos(Math.PI * amount));
        },
    },
    Exponential: {
        In: function (amount) {
            return amount === 0 ? 0 : Math.pow(1024, amount - 1);
        },
        Out: function (amount) {
            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            if ((amount *= 2) < 1) {
                return 0.5 * Math.pow(1024, amount - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
        },
    },
    Circular: {
        In: function (amount) {
            return 1 - Math.sqrt(1 - amount * amount);
        },
        Out: function (amount) {
            return Math.sqrt(1 - --amount * amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
        },
    },
    Elastic: {
        In: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
        },
        Out: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            amount *= 2;
            if (amount < 1) {
                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
            }
            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
        },
    },
    Back: {
        In: function (amount) {
            var s = 1.70158;
            return amount * amount * ((s + 1) * amount - s);
        },
        Out: function (amount) {
            var s = 1.70158;
            return --amount * amount * ((s + 1) * amount + s) + 1;
        },
        InOut: function (amount) {
            var s = 1.70158 * 1.525;
            if ((amount *= 2) < 1) {
                return 0.5 * (amount * amount * ((s + 1) * amount - s));
            }
            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
        },
    },
    Bounce: {
        In: function (amount) {
            return 1 - Easing.Bounce.Out(1 - amount);
        },
        Out: function (amount) {
            if (amount < 1 / 2.75) {
                return 7.5625 * amount * amount;
            }
            else if (amount < 2 / 2.75) {
                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
            }
            else if (amount < 2.5 / 2.75) {
                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
            }
            else {
                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
            }
        },
        InOut: function (amount) {
            if (amount < 0.5) {
                return Easing.Bounce.In(amount * 2) * 0.5;
            }
            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
        },
    },
};

var now;
// Include a performance.now polyfill.
// In node.js, use process.hrtime.
// eslint-disable-next-line
// @ts-ignore
if (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {
    now = function () {
        // eslint-disable-next-line
        // @ts-ignore
        var time = process.hrtime();
        // Convert [seconds, nanoseconds] to milliseconds.
        return time[0] * 1000 + time[1] / 1000000;
    };
}
// In a browser, use self.performance.now if it is available.
else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {
    // This must be bound, because directly assigning this function
    // leads to an invocation exception in Chrome.
    now = self.performance.now.bind(self.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
    now = Date.now;
}
// Otherwise, use 'new Date().getTime()'.
else {
    now = function () {
        return new Date().getTime();
    };
}
var now$1 = now;

/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tween
 */
var Group = /** @class */ (function () {
    function Group() {
        this._tweens = {};
        this._tweensAddedDuringUpdate = {};
    }
    Group.prototype.getAll = function () {
        var _this = this;
        return Object.keys(this._tweens).map(function (tweenId) {
            return _this._tweens[tweenId];
        });
    };
    Group.prototype.removeAll = function () {
        this._tweens = {};
    };
    Group.prototype.add = function (tween) {
        this._tweens[tween.getId()] = tween;
        this._tweensAddedDuringUpdate[tween.getId()] = tween;
    };
    Group.prototype.remove = function (tween) {
        delete this._tweens[tween.getId()];
        delete this._tweensAddedDuringUpdate[tween.getId()];
    };
    Group.prototype.update = function (time, preserve) {
        if (time === void 0) { time = now$1(); }
        if (preserve === void 0) { preserve = false; }
        var tweenIds = Object.keys(this._tweens);
        if (tweenIds.length === 0) {
            return false;
        }
        // Tweens are updated in "batches". If you add a new tween during an
        // update, then the new tween will be updated in the next batch.
        // If you remove a tween during an update, it may or may not be updated.
        // However, if the removed tween was added during the current batch,
        // then it will not be updated.
        while (tweenIds.length > 0) {
            this._tweensAddedDuringUpdate = {};
            for (var i = 0; i < tweenIds.length; i++) {
                var tween = this._tweens[tweenIds[i]];
                var autoStart = !preserve;
                if (tween && tween.update(time, autoStart) === false && !preserve) {
                    delete this._tweens[tweenIds[i]];
                }
            }
            tweenIds = Object.keys(this._tweensAddedDuringUpdate);
        }
        return true;
    };
    return Group;
}());

/**
 *
 */
var Interpolation = {
    Linear: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = Interpolation.Utils.Linear;
        if (k < 0) {
            return fn(v[0], v[1], f);
        }
        if (k > 1) {
            return fn(v[m], v[m - 1], m - f);
        }
        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function (v, k) {
        var b = 0;
        var n = v.length - 1;
        var pw = Math.pow;
        var bn = Interpolation.Utils.Bernstein;
        for (var i = 0; i <= n; i++) {
            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
        }
        return b;
    },
    CatmullRom: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = Interpolation.Utils.CatmullRom;
        if (v[0] === v[m]) {
            if (k < 0) {
                i = Math.floor((f = m * (1 + k)));
            }
            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
        }
        else {
            if (k < 0) {
                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
            }
            if (k > 1) {
                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
            }
            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
        }
    },
    Utils: {
        Linear: function (p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        Bernstein: function (n, i) {
            var fc = Interpolation.Utils.Factorial;
            return fc(n) / fc(i) / fc(n - i);
        },
        Factorial: (function () {
            var a = [1];
            return function (n) {
                var s = 1;
                if (a[n]) {
                    return a[n];
                }
                for (var i = n; i > 1; i--) {
                    s *= i;
                }
                a[n] = s;
                return s;
            };
        })(),
        CatmullRom: function (p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        },
    },
};

/**
 * Utils
 */
var Sequence = /** @class */ (function () {
    function Sequence() {
    }
    Sequence.nextId = function () {
        return Sequence._nextId++;
    };
    Sequence._nextId = 0;
    return Sequence;
}());

var mainGroup = new Group();

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
var Tween = /** @class */ (function () {
    function Tween(_object, _group) {
        if (_group === void 0) { _group = mainGroup; }
        this._object = _object;
        this._group = _group;
        this._isPaused = false;
        this._pauseStart = 0;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1000;
        this._initialRepeat = 0;
        this._repeat = 0;
        this._yoyo = false;
        this._isPlaying = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = 0;
        this._easingFunction = Easing.Linear.None;
        this._interpolationFunction = Interpolation.Linear;
        this._chainedTweens = [];
        this._onStartCallbackFired = false;
        this._id = Sequence.nextId();
        this._isChainStopped = false;
        this._goToEnd = false;
    }
    Tween.prototype.getId = function () {
        return this._id;
    };
    Tween.prototype.isPlaying = function () {
        return this._isPlaying;
    };
    Tween.prototype.isPaused = function () {
        return this._isPaused;
    };
    Tween.prototype.to = function (properties, duration) {
        // TODO? restore this, then update the 07_dynamic_to example to set fox
        // tween's to on each update. That way the behavior is opt-in (there's
        // currently no opt-out).
        // for (const prop in properties) this._valuesEnd[prop] = properties[prop]
        this._valuesEnd = Object.create(properties);
        if (duration !== undefined) {
            this._duration = duration;
        }
        return this;
    };
    Tween.prototype.duration = function (d) {
        this._duration = d;
        return this;
    };
    Tween.prototype.start = function (time) {
        if (this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.add(this);
        this._repeat = this._initialRepeat;
        if (this._reversed) {
            // If we were reversed (f.e. using the yoyo feature) then we need to
            // flip the tween direction back to forward.
            this._reversed = false;
            for (var property in this._valuesStartRepeat) {
                this._swapEndStartRepeatValues(property);
                this._valuesStart[property] = this._valuesStartRepeat[property];
            }
        }
        this._isPlaying = true;
        this._isPaused = false;
        this._onStartCallbackFired = false;
        this._isChainStopped = false;
        this._startTime = time !== undefined ? (typeof time === 'string' ? now$1() + parseFloat(time) : time) : now$1();
        this._startTime += this._delayTime;
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
        return this;
    };
    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
        for (var property in _valuesEnd) {
            var startValue = _object[property];
            var startValueIsArray = Array.isArray(startValue);
            var propType = startValueIsArray ? 'array' : typeof startValue;
            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
            // If `to()` specifies a property that doesn't exist in the source object,
            // we should not set that property in the object
            if (propType === 'undefined' || propType === 'function') {
                continue;
            }
            // Check if an Array was provided as property value
            if (isInterpolationList) {
                var endValues = _valuesEnd[property];
                if (endValues.length === 0) {
                    continue;
                }
                // handle an array of relative values
                endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
                // Create a local copy of the Array with the start value at the front
                _valuesEnd[property] = [startValue].concat(endValues);
            }
            // handle the deepness of the values
            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
                _valuesStart[property] = startValueIsArray ? [] : {};
                // eslint-disable-next-line
                for (var prop in startValue) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property][prop] = startValue[prop];
                }
                _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
            }
            else {
                // Save the starting value, but only once.
                if (typeof _valuesStart[property] === 'undefined') {
                    _valuesStart[property] = startValue;
                }
                if (!startValueIsArray) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
                }
                if (isInterpolationList) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                }
                else {
                    _valuesStartRepeat[property] = _valuesStart[property] || 0;
                }
            }
        }
    };
    Tween.prototype.stop = function () {
        if (!this._isChainStopped) {
            this._isChainStopped = true;
            this.stopChainedTweens();
        }
        if (!this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        this._isPlaying = false;
        this._isPaused = false;
        if (this._onStopCallback) {
            this._onStopCallback(this._object);
        }
        return this;
    };
    Tween.prototype.end = function () {
        this._goToEnd = true;
        this.update(Infinity);
        return this;
    };
    Tween.prototype.pause = function (time) {
        if (time === void 0) { time = now$1(); }
        if (this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = true;
        this._pauseStart = time;
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        return this;
    };
    Tween.prototype.resume = function (time) {
        if (time === void 0) { time = now$1(); }
        if (!this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = false;
        this._startTime += time - this._pauseStart;
        this._pauseStart = 0;
        // eslint-disable-next-line
        this._group && this._group.add(this);
        return this;
    };
    Tween.prototype.stopChainedTweens = function () {
        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
            this._chainedTweens[i].stop();
        }
        return this;
    };
    Tween.prototype.group = function (group) {
        this._group = group;
        return this;
    };
    Tween.prototype.delay = function (amount) {
        this._delayTime = amount;
        return this;
    };
    Tween.prototype.repeat = function (times) {
        this._initialRepeat = times;
        this._repeat = times;
        return this;
    };
    Tween.prototype.repeatDelay = function (amount) {
        this._repeatDelayTime = amount;
        return this;
    };
    Tween.prototype.yoyo = function (yoyo) {
        this._yoyo = yoyo;
        return this;
    };
    Tween.prototype.easing = function (easingFunction) {
        this._easingFunction = easingFunction;
        return this;
    };
    Tween.prototype.interpolation = function (interpolationFunction) {
        this._interpolationFunction = interpolationFunction;
        return this;
    };
    Tween.prototype.chain = function () {
        var tweens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tweens[_i] = arguments[_i];
        }
        this._chainedTweens = tweens;
        return this;
    };
    Tween.prototype.onStart = function (callback) {
        this._onStartCallback = callback;
        return this;
    };
    Tween.prototype.onUpdate = function (callback) {
        this._onUpdateCallback = callback;
        return this;
    };
    Tween.prototype.onRepeat = function (callback) {
        this._onRepeatCallback = callback;
        return this;
    };
    Tween.prototype.onComplete = function (callback) {
        this._onCompleteCallback = callback;
        return this;
    };
    Tween.prototype.onStop = function (callback) {
        this._onStopCallback = callback;
        return this;
    };
    /**
     * @returns true if the tween is still playing after the update, false
     * otherwise (calling update on a paused tween still returns true because
     * it is still playing, just paused).
     */
    Tween.prototype.update = function (time, autoStart) {
        if (time === void 0) { time = now$1(); }
        if (autoStart === void 0) { autoStart = true; }
        if (this._isPaused)
            return true;
        var property;
        var elapsed;
        var endTime = this._startTime + this._duration;
        if (!this._goToEnd && !this._isPlaying) {
            if (time > endTime)
                return false;
            if (autoStart)
                this.start(time);
        }
        this._goToEnd = false;
        if (time < this._startTime) {
            return true;
        }
        if (this._onStartCallbackFired === false) {
            if (this._onStartCallback) {
                this._onStartCallback(this._object);
            }
            this._onStartCallbackFired = true;
        }
        elapsed = (time - this._startTime) / this._duration;
        elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
        var value = this._easingFunction(elapsed);
        // properties transformations
        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
        if (this._onUpdateCallback) {
            this._onUpdateCallback(this._object, elapsed);
        }
        if (elapsed === 1) {
            if (this._repeat > 0) {
                if (isFinite(this._repeat)) {
                    this._repeat--;
                }
                // Reassign starting values, restart by making startTime = now
                for (property in this._valuesStartRepeat) {
                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {
                        this._valuesStartRepeat[property] =
                            // eslint-disable-next-line
                            // @ts-ignore FIXME?
                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
                    }
                    if (this._yoyo) {
                        this._swapEndStartRepeatValues(property);
                    }
                    this._valuesStart[property] = this._valuesStartRepeat[property];
                }
                if (this._yoyo) {
                    this._reversed = !this._reversed;
                }
                if (this._repeatDelayTime !== undefined) {
                    this._startTime = time + this._repeatDelayTime;
                }
                else {
                    this._startTime = time + this._delayTime;
                }
                if (this._onRepeatCallback) {
                    this._onRepeatCallback(this._object);
                }
                return true;
            }
            else {
                if (this._onCompleteCallback) {
                    this._onCompleteCallback(this._object);
                }
                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                    // Make the chained tweens start exactly at the time they should,
                    // even if the `update()` method was called way past the duration of the tween
                    this._chainedTweens[i].start(this._startTime + this._duration);
                }
                this._isPlaying = false;
                return false;
            }
        }
        return true;
    };
    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
        for (var property in _valuesEnd) {
            // Don't update properties that do not exist in the source object
            if (_valuesStart[property] === undefined) {
                continue;
            }
            var start = _valuesStart[property] || 0;
            var end = _valuesEnd[property];
            var startIsArray = Array.isArray(_object[property]);
            var endIsArray = Array.isArray(end);
            var isInterpolationList = !startIsArray && endIsArray;
            if (isInterpolationList) {
                _object[property] = this._interpolationFunction(end, value);
            }
            else if (typeof end === 'object' && end) {
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._updateProperties(_object[property], start, end, value);
            }
            else {
                // Parses relative end values with start as base (e.g.: +10, -3)
                end = this._handleRelativeValue(start, end);
                // Protect against non numeric properties.
                if (typeof end === 'number') {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _object[property] = start + (end - start) * value;
                }
            }
        }
    };
    Tween.prototype._handleRelativeValue = function (start, end) {
        if (typeof end !== 'string') {
            return end;
        }
        if (end.charAt(0) === '+' || end.charAt(0) === '-') {
            return start + parseFloat(end);
        }
        else {
            return parseFloat(end);
        }
    };
    Tween.prototype._swapEndStartRepeatValues = function (property) {
        var tmp = this._valuesStartRepeat[property];
        var endValue = this._valuesEnd[property];
        if (typeof endValue === 'string') {
            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
        }
        else {
            this._valuesStartRepeat[property] = this._valuesEnd[property];
        }
        this._valuesEnd[property] = tmp;
    };
    return Tween;
}());

var VERSION = '18.6.4';

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
var nextId = Sequence.nextId;
/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tweens.
 */
var TWEEN = mainGroup;
// This is the best way to export things in a way that's compatible with both ES
// Modules and CommonJS, without build hacks, and so as not to break the
// existing API.
// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
var getAll = TWEEN.getAll.bind(TWEEN);
var removeAll = TWEEN.removeAll.bind(TWEEN);
var add = TWEEN.add.bind(TWEEN);
var remove = TWEEN.remove.bind(TWEEN);
var update = TWEEN.update.bind(TWEEN);
var exports$1 = {
    Easing: Easing,
    Group: Group,
    Interpolation: Interpolation,
    now: now$1,
    Sequence: Sequence,
    nextId: nextId,
    Tween: Tween,
    VERSION: VERSION,
    getAll: getAll,
    removeAll: removeAll,
    add: add,
    remove: remove,
    update: update,
};

/**
 * 设置 AnimationFrame begin
 */

var lastTime = 0;
var _globalAnimationEnabled = true;
var requestAnimationFrame, cancelAnimationFrame;

if (typeof window !== 'undefined') {
  requestAnimationFrame = window.requestAnimationFrame;
  cancelAnimationFrame = window.cancelAnimationFrame;
  var vendors = ['ms', 'moz', 'webkit', 'o'];

  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    requestAnimationFrame = window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    cancelAnimationFrame = window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }
}

if (!requestAnimationFrame) {
  requestAnimationFrame = function requestAnimationFrame(callback, element) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}

if (!cancelAnimationFrame) {
  cancelAnimationFrame = function cancelAnimationFrame(id) {
    clearTimeout(id);
  };
}

var _taskList = []; //[{ id : task: }...]

var _requestAid = null;

function enabledAnimationFrame() {
  if (!_requestAid) {
    _requestAid = requestAnimationFrame(function () {
      //console.log("frame__" + _taskList.length);
      //if ( Tween.getAll().length ) {
      exports$1.update(); //tween自己会做length判断
      //};

      var currTaskList = _taskList;
      _taskList = [];
      _requestAid = null;

      while (currTaskList.length > 0) {
        currTaskList.shift().task();
      }
    });
  }
  return _requestAid;
}
/*
 * @param task 要加入到渲染帧队列中的任务
 * @result frameid
 */

function registFrame($frame) {
  if (!$frame) {
    return;
  }

  _taskList.push($frame);

  return enabledAnimationFrame();
}
/*
 *  @param task 要从渲染帧队列中删除的任务
 */

function destroyFrame($frame) {
  var d_result = false;

  for (var i = 0, l = _taskList.length; i < l; i++) {
    if (_taskList[i].id === $frame.id) {
      d_result = true;

      _taskList.splice(i, 1);

      i--;
      l--;
    }
  }

  if (_taskList.length == 0) {
    cancelAnimationFrame(_requestAid);
    _requestAid = null;
  }
  return d_result;
}
/* 
 * @param opt {from , to , onUpdate , onComplete , ......}
 * @result tween
 */

function registTween(options) {
  var opt = _.extend({
    from: null,
    to: null,
    duration: 500,
    onStart: function onStart() {},
    onUpdate: function onUpdate() {},
    onComplete: function onComplete() {},
    onStop: function onStop() {},
    repeat: 0,
    delay: 0,
    easing: 'Linear.None',
    desc: '' //动画描述，方便查找bug

  }, options);

  if (!getAnimationEnabled()) {
    //如果全局动画被禁用，那么下面两项强制设置为0
    //TODO:其实应该直接执行回调函数的
    opt.duration = 0;
    opt.delay = 0;
  }
  var tween = {};
  var tid = "tween_" + Utils.getUID();
  opt.id && (tid = tid + "_" + opt.id);

  if (opt.from && opt.to) {
    var animate = function animate() {
      if (tween._isCompleteed || tween._isStoped) {
        tween = null;
        return;
      }
      registFrame({
        id: tid,
        task: animate,
        desc: opt.desc,
        tween: tween
      });
    };

    tween = new exports$1.Tween(opt.from).to(opt.to, opt.duration).onStart(function () {
      //opt.onStart.apply( this )
      opt.onStart(opt.from);
    }).onUpdate(function () {
      //opt.onUpdate.apply( this );
      opt.onUpdate(opt.from);
    }).onComplete(function () {
      destroyFrame({
        id: tid
      });
      tween._isCompleteed = true; //opt.onComplete.apply( this , [this] ); //执行用户的conComplete

      opt.onComplete(opt.from);
    }).onStop(function () {
      destroyFrame({
        id: tid
      });
      tween._isStoped = true; //opt.onStop.apply( this , [this] );

      opt.onStop(opt.from);
    }).repeat(opt.repeat).delay(opt.delay).easing(exports$1.Easing[opt.easing.split(".")[0]][opt.easing.split(".")[1]]);
    tween.id = tid;
    tween.start();
    animate();
  }
  return tween;
}
/*
 * @param tween
 * @result void(0)
 */

function destroyTween(tween, msg) {
  tween.stop();
}

function setAnimationEnabled(bool) {
  _globalAnimationEnabled = bool;
}

function getAnimationEnabled() {
  return _globalAnimationEnabled;
}

var AnimationFrame = {
  setAnimationEnabled: setAnimationEnabled,
  getAnimationEnabled: getAnimationEnabled,
  registFrame: registFrame,
  destroyFrame: destroyFrame,
  registTween: registTween,
  destroyTween: destroyTween,
  Tween: exports$1,
  taskList: _taskList
};

function Observe(scope) {
  var stopRepeatAssign = true;
  var pmodel = {},
      //要返回的对象
  accessores = {},
      //内部用于转换的对象
  _Publics = ["$watch", "$model"],
      //公共属性，不需要get set 化的
  model = {}; //这是pmodel上的$model属性

  var Publics = _Publics;

  function loop(name, val) {
    if (_.indexOf(_Publics, name) === -1) {
      //非 _Publics 中的值，都要先设置好对应的val到model上
      model[name] = val;
    }

    var valueType = _typeof(val);

    if (_.indexOf(Publics, name) > -1) {
      return;
    }

    if (valueType === "function") {
      Publics.push(name); //函数无需要转换，也可以做为公共属性存在
    } else {
      var accessor = function accessor(neo) {
        //创建监控属性或数组，自变量，由用户触发其改变
        var value = model[name],
            preValue = value,
            complexValue;

        if (arguments.length) {
          //写操作
          //set 的 值的 类型
          var neoType = _typeof(neo);

          if (stopRepeatAssign) {
            return; //阻止重复赋值
          }

          if (value !== neo) {
            if (neo && neoType === "object" && !(neo instanceof Array) && !neo.addColorStop // neo instanceof CanvasGradient
            ) {
                value = neo.$model ? neo : Observe(neo);
                complexValue = value.$model;
              } else {
              //如果是其他数据类型
              value = neo;
            }

            model[name] = complexValue ? complexValue : value; //更新$model中的值

            if (valueType != neoType) {
              //如果set的值类型已经改变，
              //那么也要把对应的valueType修改为对应的neoType
              valueType = neoType;
            }

            if (pmodel.$watch) {
              pmodel.$watch.call(pmodel, name, value, preValue);
            }
          }
        } else {
          //读操作
          //读的时候，发现value是个obj，而且还没有defineProperty
          //那么就临时defineProperty一次
          if (value && valueType === "object" && !(value instanceof Array) && !value.$model && !value.addColorStop) {
            value = Observe(value);
            value.$watch = pmodel.$watch; //accessor.value = value;

            model[name] = value;
          }
          return value;
        }
      }; //accessor.value = val;


      accessores[name] = {
        set: accessor,
        get: accessor,
        enumerable: true
      };
    }
  }

  for (var i in scope) {
    loop(i, scope[i]);
  }
  pmodel = defineProperties(pmodel, accessores, Publics); //生成一个空的ViewModel

  _.forEach(Publics, function (name) {
    if (scope[name]) {
      //然后为函数等不被监控的属性赋值
      if (typeof scope[name] == "function") {
        pmodel[name] = function () {
          scope[name].apply(this, arguments);
        };
      } else {
        pmodel[name] = scope[name];
      }
    }
  });

  pmodel.$model = model;

  pmodel.hasOwnProperty = function (name) {
    return name in pmodel.$model;
  };

  stopRepeatAssign = false;
  return pmodel;
}
var defineProperty = Object.defineProperty; //如果浏览器不支持ecma262v5的Object.defineProperties或者存在BUG，比如IE8
//标准浏览器使用__defineGetter__, __defineSetter__实现

try {
  defineProperty({}, "_", {
    value: "x"
  });
  var defineProperties = Object.defineProperties;
} catch (e) {
  if ("__defineGetter__" in Object) {
    defineProperty = function defineProperty(obj, prop, desc) {
      if ('value' in desc) {
        obj[prop] = desc.value;
      }

      if ('get' in desc) {
        obj.__defineGetter__(prop, desc.get);
      }

      if ('set' in desc) {
        obj.__defineSetter__(prop, desc.set);
      }

      return obj;
    };

    defineProperties = function defineProperties(obj, descs) {
      for (var prop in descs) {
        if (descs.hasOwnProperty(prop)) {
          defineProperty(obj, prop, descs[prop]);
        }
      }

      return obj;
    };
  }
}

var RENDERER_TYPE = {
  UNKNOWN: 0,
  WEBGL: 1,
  CANVAS: 2
};
var SHAPES = {
  POLY: 0,
  RECT: 1,
  CIRC: 2,
  ELIP: 3
};

var TRANSFORM_PROPS = ["x", "y", "scaleX", "scaleY", "rotation", "scaleOrigin", "rotateOrigin"]; //所有和样式相关的属性
//appha 有 自己的 处理方式

var STYLE_PROPS = ["lineWidth", "strokeAlpha", "strokeStyle", "fillStyle", "fillAlpha", "globalAlpha", "shadowOffsetX", "shadowOffsetY", "shadowColor", "shadowBlur"];

/**
 * 线段包含判断
 * @points [0,0,0,0]
 */
var _isInsideLine = function _isInsideLine(points, x, y, lineWidth) {
  var x0 = points[0];
  var y0 = points[1];
  var x1 = points[2];
  var y1 = points[3];

  var _l = Math.max(lineWidth, 3);

  var _a = 0;
  var _b = x0;

  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
    return false;
  }

  if (x0 !== x1) {
    _a = (y0 - y1) / (x0 - x1);
    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
  } else {
    return Math.abs(x - x0) <= _l / 2;
  }

  var _s = (_a * x - y + _b) * (_a * x - y + _b) / (_a * _a + 1);

  return _s <= _l / 2 * _l / 2;
};

function insideLine(data, x, y, line) {
  var points = data.shape.points;
  var lineWidth = data.lineWidth;
  var insideCatch = false;

  for (var i = 0; i < points.length; ++i) {
    insideCatch = _isInsideLine(points.slice(i, i + 4), x, y, lineWidth);

    if (insideCatch) {
      break;
    }
    i += 1;
  }
  return insideCatch;
}

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var DisplayObject = /*#__PURE__*/function (_event$Dispatcher) {
  _inherits(DisplayObject, _event$Dispatcher);

  var _super = _createSuper$1(DisplayObject);

  function DisplayObject(opt) {
    var _this;

    _classCallCheck(this, DisplayObject);

    _this = _super.call(this, opt); //相对父级元素的矩阵

    _this._transform = null;
    _this.worldTransform = null; //_transform如果有修改，则_transformChange为true，renderer的时候worldTransform

    _this._transformChange = false; //心跳次数

    _this._heartBeatNum = 0; //元素对应的stage元素

    _this.stage = null; //元素的父元素

    _this.parent = null;
    _this.xyToInt = "xyToInt" in opt ? opt.xyToInt : true; //是否对xy坐标统一int处理，默认为true，但是有的时候可以由外界用户手动指定是否需要计算为int，因为有的时候不计算比较好，比如，进度图表中，再sector的两端添加两个圆来做圆角的进度条的时候，圆circle不做int计算，才能和sector更好的衔接

    _this.moveing = false; //如果元素在最轨道运动中的时候，最好把这个设置为true，这样能保证轨迹的丝搬顺滑，否则因为xyToInt的原因，会有跳跃

    _this.clip = null; //裁剪的图形对象
    //创建好context

    _this.context = _this._createContext(opt);
    _this.type = opt.type || "DisplayObject";
    _this.id = opt.id || Utils.createId(_this.type);
    _this._trackList = []; //一个元素可以追踪另外元素的变动

    _this.init.apply(_assertThisInitialized(_this), arguments); //所有属性准备好了后，先要计算一次this._updateTransform()得到_tansform


    _this._updateTransform();

    _this._tweens = [];

    var me = _assertThisInitialized(_this);

    _this.on("destroy", function () {
      me.cleanAnimates();
    });

    return _this;
  }

  _createClass(DisplayObject, [{
    key: "init",
    value: function init() {}
  }, {
    key: "clipTo",
    value: function clipTo(node) {
      this.clip = node;
      node.isClip = true;
    }
  }, {
    key: "_createContext",
    value: function _createContext(opt) {
      var self = this;
      var optCtx = opt.context || {};
      var _contextATTRS = {
        width: optCtx.width || 0,
        height: optCtx.height || 0,
        x: optCtx.x || 0,
        y: optCtx.y || 0,
        scaleX: optCtx.scaleX || 1,
        scaleY: optCtx.scaleY || 1,
        scaleOrigin: optCtx.scaleOrigin || {
          x: 0,
          y: 0
        },
        rotation: optCtx.rotation || 0,
        rotateOrigin: optCtx.rotateOrigin || {
          x: 0,
          y: 0
        },
        visible: optCtx.visible || true,
        globalAlpha: optCtx.globalAlpha || 1 //样式部分迁移到shape中

      }; //平凡的clone数据非常的耗时，还是走回原来的路
      //var _contextATTRS = _.extend( true , _.clone(CONTEXT_DEFAULT), opt.context );

      _.extend(true, _contextATTRS, opt.context); //有些引擎内部设置context属性的时候是不用上报心跳的，比如做热点检测的时候


      self._notWatch = false; //不需要发心跳信息

      self._noHeart = false; //_contextATTRS.$owner = self;

      _contextATTRS.$watch = function (name, value, preValue) {
        //下面的这些属性变化，都会需要重新组织矩阵属性 _transform 
        var obj = self; //this.$owner;

        if (!obj.context) {
          //如果这个obj的context已经不存在了，那么就什么都不处理，
          //TODO:后续还要把自己给destroy 并且要把在 动画队列里面的动画也干掉
          return;
        }

        if (name == "globalGalpha") {
          obj._globalAlphaChange = true;
        }

        if (_.indexOf(TRANSFORM_PROPS, name) > -1) {
          obj._updateTransform();

          obj._transformChange = true;
        }

        if (obj._notWatch) {
          return;
        }

        if (obj.$watch) {
          //执行的内部$watch的时候必须把_notWatch 设置为true，否则会死循环调用
          obj._notWatch = true;
          obj.$watch(name, value, preValue);
          obj._notWatch = false;
        }

        if (obj._noHeart) {
          return;
        }
        obj.heartBeat({
          convertType: "context",
          shape: obj,
          name: name,
          value: value,
          preValue: preValue
        });
      }; //执行init之前，应该就根据参数，把context组织好线


      return Observe(_contextATTRS);
    } //TODO:track目前还没测试过,需要的时候再测试

  }, {
    key: "track",
    value: function track(el) {
      if (_.indexOf(this._trackList, el) == -1) {
        this._trackList.push(el);
      }
    }
  }, {
    key: "untrack",
    value: function untrack(el) {
      var ind = _.indexOf(this._trackList, el);

      if (ind > -1) {
        this._trackList.splice(ind, 1);
      }
    }
    /* @myself 是否生成自己的镜像 
     * 克隆又两种，一种是镜像，另外一种是绝对意义上面的新个体
     * 默认为绝对意义上面的新个体，新对象id不能相同
     * 镜像基本上是框架内部在实现  镜像的id相同 主要用来把自己画到另外的stage里面，比如
     * mouseover和mouseout的时候调用*/

  }, {
    key: "clone",
    value: function clone(myself) {
      var conf = {
        id: this.id,
        context: _.clone(this.context.$model),
        isClone: true
      };
      var newObj;

      if (this.type == 'text') {
        newObj = new this.constructor(this.text, conf);
      } else {
        newObj = new this.constructor(conf);
      }

      newObj.id = conf.id;

      if (this.children) {
        newObj.children = this.children;
      }

      if (this.graphics) {
        newObj.graphics = this.graphics.clone();
      }

      if (!myself) {
        newObj.id = Utils.createId(newObj.type);
      }
      return newObj;
    }
  }, {
    key: "heartBeat",
    value: function heartBeat(opt) {
      //stage存在，才说self代表的display已经被添加到了displayList中，绘图引擎需要知道其改变后
      //的属性，所以，通知到stage.displayAttrHasChange
      var stage = this.getStage();

      if (stage) {
        this._heartBeatNum++;
        stage.heartBeat && stage.heartBeat(opt);
      }
    }
  }, {
    key: "getCurrentWidth",
    value: function getCurrentWidth() {
      return Math.abs(this.context.$model.width * this.context.$model.scaleX);
    }
  }, {
    key: "getCurrentHeight",
    value: function getCurrentHeight() {
      return Math.abs(this.context.$model.height * this.context.$model.scaleY);
    }
  }, {
    key: "getStage",
    value: function getStage() {
      if (this.stage) {
        return this.stage;
      }
      var p = this;

      if (p.type != "stage") {
        while (p.parent) {
          p = p.parent;

          if (p.type == "stage") {
            break;
          }
        }

        if (p.type !== "stage") {
          //如果得到的顶点display 的type不是Stage,也就是说不是stage元素
          //那么只能说明这个p所代表的顶端display 还没有添加到displayList中，也就是没有没添加到
          //stage舞台的childen队列中，不在引擎渲染范围内
          return false;
        }
      } //一直回溯到顶层object， 即是stage， stage的parent为null


      this.stage = p;
      return p;
    }
  }, {
    key: "localToGlobal",
    value: function localToGlobal(point, container) {
      !point && (point = new Point(0, 0));
      var cm = this.getConcatenatedMatrix(container);
      if (cm == null) return Point(0, 0);
      var m = new Matrix(1, 0, 0, 1, point.x, point.y);
      m.concat(cm);
      return new Point(m.tx, m.ty); //{x:m.tx, y:m.ty};
    }
  }, {
    key: "globalToLocal",
    value: function globalToLocal(point, container) {
      !point && (point = new Point(0, 0));

      if (this.type == "stage") {
        return point;
      }

      var cm = this.getConcatenatedMatrix(container);
      if (cm == null) return new Point(0, 0); //{x:0, y:0};

      cm.invert(); //let originPos = cm.mulVector( [ point.x, point.y ] );
      //return new Point( originPos[0], originPos[1] );

      var m = new Matrix(1, 0, 0, 1, point.x, point.y);
      m.concat(cm);
      return new Point(m.tx, m.ty); //{x:m.tx, y:m.ty};
    }
  }, {
    key: "localToTarget",
    value: function localToTarget(point, target) {
      var p = localToGlobal(point);
      return target.globalToLocal(p);
    }
  }, {
    key: "getConcatenatedMatrix",
    value: function getConcatenatedMatrix(container) {
      var cm = new Matrix();

      for (var o = this; o != null; o = o.parent) {
        cm.concat(o._transform);

        if (!o.parent || container && o.parent && o.parent == container || o.parent && o.parent.type == "stage") {
          //if( o.type == "stage" || (o.parent && container && o.parent.type == container.type ) ) {
          return cm; //break;
        }
      }

      return cm;
    }
    /*
     *设置元素的是否响应事件检测
     *@bool  Boolean 类型
     */

  }, {
    key: "setEventEnable",
    value: function setEventEnable(bool) {
      if (_.isBoolean(bool)) {
        this._eventEnabled = bool;
        return true;
      }
      return false;
    }
    /*
     *查询自己在parent的队列中的位置
     */

  }, {
    key: "getIndex",
    value: function getIndex() {
      if (!this.parent) {
        return;
      }
      return _.indexOf(this.parent.children, this);
    }
    /*
     *元素在z轴方向向下移动
     *@num 移动的层级
     */

  }, {
    key: "toBack",
    value: function toBack(num) {
      if (!this.parent) {
        return;
      }

      var fromIndex = this.getIndex();
      var toIndex = 0;

      if (_.isNumber(num)) {
        if (num == 0) {
          //原地不动
          return;
        }
        toIndex = fromIndex - num;
      }

      var me = this.parent.children.splice(fromIndex, 1)[0];

      if (toIndex < 0) {
        toIndex = 0;
      }
      this.parent.addChildAt(me, toIndex);
    }
    /*
     *元素在z轴方向向上移动
     *@num 移动的层数量 默认到顶端
     */

  }, {
    key: "toFront",
    value: function toFront(num) {
      if (!this.parent) {
        return;
      }

      var fromIndex = this.getIndex();
      var pcl = this.parent.children.length;
      var toIndex = pcl;

      if (_.isNumber(num)) {
        if (num == 0) {
          //原地不动
          return;
        }

        toIndex = fromIndex + num + 1;
      }

      var me = this.parent.children.splice(fromIndex, 1)[0];

      if (toIndex > pcl) {
        toIndex = pcl;
      }

      this.parent.addChildAt(me, toIndex - 1);
    }
  }, {
    key: "_updateTransform",
    value: function _updateTransform() {
      var _transform = new Matrix();

      _transform.identity();

      var context = this.context; //是否需要scale

      if (context.scaleX !== 1 || context.scaleY !== 1) {
        //如果有缩放
        //缩放的原点坐标
        var origin = new Point(context.scaleOrigin);

        _transform.translate(-origin.x, -origin.y);

        _transform.scale(context.scaleX, context.scaleY);

        _transform.translate(origin.x, origin.y);
      }
      var rotation = context.rotation;

      if (rotation) {
        //如果有旋转
        //旋转的原点坐标
        var origin = new Point(context.rotateOrigin);

        _transform.translate(-origin.x, -origin.y);

        _transform.rotate(rotation % 360 * Math.PI / 180);

        _transform.translate(origin.x, origin.y);
      }

      var x, y;

      if (this.xyToInt && !this.moveing) {
        //当这个元素在做轨迹运动的时候，比如drag，animation如果实时的调整这个x ， y
        //那么该元素的轨迹会有跳跃的情况发生。所以加个条件过滤，
        var x = parseInt(context.x);
        var y = parseInt(context.y);

        if (parseInt(context.lineWidth, 10) % 2 == 1 && context.strokeStyle) {
          x += 0.5;
          y += 0.5;
        }
      } else {
        x = context.x;
        y = context.y;
      }

      if (x != 0 || y != 0) {
        _transform.translate(x, y);
      }
      this._transform = _transform;
      return _transform;
    } //获取全局的世界坐标系内的矩阵
    //世界坐标是从上而下的，所以只要和parent的直接坐标相乘就好了

  }, {
    key: "setWorldTransform",
    value: function setWorldTransform() {
      var cm = new Matrix();
      cm.concat(this._transform);
      this.parent && cm.concat(this.parent.worldTransform);
      this.worldTransform = cm;
      return this.worldTransform;
    } //显示对象的选取检测处理函数

  }, {
    key: "getChildInPoint",
    value: function getChildInPoint(point) {
      var result = false; //检测的结果
      //第一步，吧glob的point转换到对应的obj的层级内的坐标系统
      //if( this.type != "stage" && this.parent && this.parent.type != "stage" ) {
      //    point = this.parent.globalToLocal( point );
      //};
      //var m = new Matrix( Settings.RESOLUTION, 0, 0, Settings.RESOLUTION, point.x , point.y);
      //m.concat( this.worldTransform );

      var x = point.x;
      var y = point.y; //对鼠标的坐标也做相同的变换

      if (this.worldTransform) {
        var inverseMatrix = this.worldTransform.clone().invert();
        var originPos = [x * Settings.RESOLUTION, y * Settings.RESOLUTION];
        originPos = inverseMatrix.mulVector(originPos);
        x = originPos[0];
        y = originPos[1];
      }

      if (this.graphics) {
        result = this.containsPoint({
          x: x,
          y: y
        });
      }

      if (this.type == "text") {
        //文本框的先单独处理
        var _rect = this.getRect();

        if (!_rect.width || !_rect.height) {
          return false;
        }

        if (x >= _rect.x && x <= _rect.x + _rect.width && (_rect.height >= 0 && y >= _rect.y && y <= _rect.y + _rect.height || _rect.height < 0 && y <= _rect.y && y >= _rect.y + _rect.height)) {
          //那么就在这个元素的矩形范围内
          result = true;
        } else {
          //如果连矩形内都不是，那么肯定的，这个不是我们要找的shap
          result = false;
        }
        return result;
      }
      return result;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      var inside = false;

      for (var i = 0; i < this.graphics.graphicsData.length; ++i) {
        var data = this.graphics.graphicsData[i];

        if (data.shape) {
          //先检测fill， fill的检测概率大些。
          //像circle,ellipse这样的shape 就直接把lineWidth算在fill里面计算就好了，所以他们是没有insideLine的
          if (data.hasFill() && data.shape.contains(point.x, point.y)) {
            inside = true;

            if (inside) {
              break;
            }
          } //circle,ellipse等就没有points


          if (data.hasLine() && data.shape.points) {
            //然后检测是否和描边碰撞
            inside = insideLine(data, point.x, point.y);

            if (inside) {
              break;
            }
          }
        }
      }

      return inside;
    }
    /*
    * animate
    * @param toContent 要动画变形到的属性集合
    * @param options tween 动画参数
    */

  }, {
    key: "animate",
    value: function animate(toContent, options, context) {
      if (!context) {
        context = this.context;
      }

      if (!context) {
        //这个时候如果还是找不到context说明这个 el 已经被destroy了
        return;
      }
      var to = toContent;
      var from = null;

      for (var p in to) {
        if (_.isObject(to[p])) {
          //options必须传递一份copy出去，比如到下一个animate
          this.animate(to[p], _.extend({}, options), context[p]); //如果是个object

          continue;
        }

        if (isNaN(to[p]) && to[p] !== '' && to[p] !== null) {
          //undefined已经被isNaN过滤了
          //只有number才能继续走下去执行tween，而非number则直接赋值完事，
          //TODO:不能用_.isNumber 因为 '1212' 这样的其实可以计算
          context[p] = to[p];
          delete to[p];
          continue;
        }

        if (!from) {
          from = {};
        }
        from[p] = context[p];
      }

      if (!from) {
        //这里很重要，不能删除。 
        //比如line.animate({start:{x:0,y:0}} , {duration:500});
        //那么递归到start的时候  from 的值依然为null
        //如果这个时候继续执行的话，会有很严重的bug
        //line.context.start 会 被赋值了 line对象上的所有属性，严重的bug
        return;
      }
      !options && (options = {});
      options.from = from;
      options.to = to;
      var self = this;

      var upFun = function upFun() {};

      if (options.onUpdate) {
        upFun = options.onUpdate;
      }
      var tween;

      options.onUpdate = function (status) {
        //如果context不存在说明该obj已经被destroy了，那么要把他的tween给destroy
        if (!context && tween) {
          AnimationFrame.destroyTween(tween);
          tween = null;
          return;
        }

        for (var p in status) {
          context[p] = status[p];
        }
        upFun.apply(self, [status]);
      };

      var compFun = function compFun() {};

      if (options.onComplete) {
        compFun = options.onComplete;
      }

      options.onComplete = function (status) {
        compFun.apply(self, arguments);

        self._removeTween(tween);
      };

      options.onStop = function () {
        self._removeTween(tween);
      };

      options.desc = "tweenType:DisplayObject.animate__id:" + this.id + "__objectType:" + this.type;
      tween = AnimationFrame.registTween(options);

      this._tweens.push(tween);

      return tween;
    }
  }, {
    key: "_removeTween",
    value: function _removeTween(tween) {
      for (var i = 0; i < this._tweens.length; i++) {
        if (tween == this._tweens[i]) {
          this._tweens.splice(i, 1);

          break;
        }
      }
    }
  }, {
    key: "removeAnimate",
    value: function removeAnimate(animate) {
      animate.stop();

      this._removeTween(animate);
    } //清楚所有的动画

  }, {
    key: "cleanAnimates",
    value: function cleanAnimates() {
      this._cleanAnimates();
    } //清楚所有的动画

  }, {
    key: "_cleanAnimates",
    value: function _cleanAnimates() {
      while (this._tweens.length) {
        this._tweens.shift().stop();
      }
    } //从树中删除

  }, {
    key: "remove",
    value: function remove() {
      if (this.parent) {
        this.parent.removeChild(this);
        this.parent = null;
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._destroy();
    } //元素的自我销毁

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.remove();
      this.fire("destroy"); //把自己从父节点中删除了后做自我清除，释放内存

      this.context = null;
      delete this.context;
    }
  }]);

  return DisplayObject;
}(event.Dispatcher);

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var DisplayObjectContainer = /*#__PURE__*/function (_DisplayObject) {
  _inherits(DisplayObjectContainer, _DisplayObject);

  var _super = _createSuper$2(DisplayObjectContainer);

  function DisplayObjectContainer(opt) {
    var _this;

    _classCallCheck(this, DisplayObjectContainer);

    _this = _super.call(this, opt);
    _this.children = []; //所有的容器默认支持event 检测，因为 可能有里面的shape是eventEnable是true的
    //如果用户有强制的需求让容器下的所有元素都 不可检测，可以调用
    //DisplayObjectContainer的 setEventEnable() 方法

    _this._eventEnabled = true;
    return _this;
  }

  _createClass(DisplayObjectContainer, [{
    key: "addChild",
    value: function addChild(child, index) {
      if (!child) {
        return;
      }

      if (this.getChildIndex(child) != -1) {
        child.parent = this;
        return child;
      }

      if (child.parent) {
        child.parent.removeChild(child);
      }

      if (index === undefined) {
        index = this.children.length;
      }
      this.children.splice(index, 0, child);
      child.parent = this;

      if (this.heartBeat) {
        this.heartBeat({
          convertType: "children",
          target: child,
          src: this
        });
      }

      if (this._afterAddChild) {
        this._afterAddChild(child);
      }
      return child;
    }
  }, {
    key: "addChildAt",
    value: function addChildAt(child, index) {
      return this.addChild(child, index);
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      return this.removeChildAt(_.indexOf(this.children, child));
    }
  }, {
    key: "removeChildAt",
    value: function removeChildAt(index) {
      if (index < 0 || index > this.children.length - 1) {
        return false;
      }
      var child = this.children[index];

      if (child != null) {
        child.parent = null;
      }
      this.children.splice(index, 1);

      if (this.heartBeat) {
        this.heartBeat({
          convertType: "children",
          target: child,
          src: this
        });
      }

      if (this._afterDelChild) {
        this._afterDelChild(child, index);
      }

      return child;
    }
  }, {
    key: "removeChildById",
    value: function removeChildById(id) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i].id == id) {
          return this.removeChildAt(i);
        }
      }

      return false;
    }
  }, {
    key: "removeAllChildren",
    value: function removeAllChildren() {
      while (this.children.length > 0) {
        this.removeChildAt(0);
      }
    } //集合类的自我销毁

  }, {
    key: "destroy",
    value: function destroy() {
      /*
      if( this.parent ){
          this.parent.removeChild(this);
          this.parent = null;
      };
      this.fire("destroy");
      */
      //依次销毁所有子元素
      for (var i = 0, l = this.children.length; i < l; i++) {
        this.getChildAt(i).destroy();
        i--;
        l--;
      }

      this._destroy();
    } //集合类的自我销毁

  }, {
    key: "cleanAnimates",
    value: function cleanAnimates() {
      //依次销毁所有子元素
      for (var i = 0, l = this.children.length; i < l; i++) {
        this.getChildAt(i).cleanAnimates();
      }

      this._cleanAnimates();
    }
    /*
     *@id 元素的id
     *@boolen 是否深度查询，默认就在第一层子元素中查询
     **/

  }, {
    key: "getChildById",
    value: function getChildById(id, boolen) {
      if (!boolen) {
        for (var i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i].id == id) {
            return this.children[i];
          }
        }
      } else {
        //深度查询
        //TODO:暂时未实现
        return null;
      }

      return null;
    }
  }, {
    key: "getChildAt",
    value: function getChildAt(index) {
      if (index < 0 || index > this.children.length - 1) return null;
      return this.children[index];
    }
  }, {
    key: "getChildIndex",
    value: function getChildIndex(child) {
      return _.indexOf(this.children, child);
    }
  }, {
    key: "setChildIndex",
    value: function setChildIndex(child, index) {
      if (child.parent != this) return;

      var oldIndex = _.indexOf(this.children, child);

      if (index == oldIndex) return;
      this.children.splice(oldIndex, 1);
      this.children.splice(index, 0, child);
    }
  }, {
    key: "getNumChildren",
    value: function getNumChildren() {
      return this.children.length;
    } //获取x,y点上的所有object  num 需要返回的obj数量

  }, {
    key: "getObjectsUnderPoint",
    value: function getObjectsUnderPoint(point, num) {
      var result = [];

      for (var i = this.children.length - 1; i >= 0; i--) {
        var child = this.children[i];

        if (child == null || !child.context.$model.visible) {
          //不管是集合还是非集合，如果不显示的都不接受点击检测
          continue;
        }

        if (child instanceof DisplayObjectContainer) {
          if (!child._eventEnabled) {
            //容易一般默认 _eventEnabled == true; 但是如果被设置成了false
            //如果容器设置了不接受事件检测，那么下面所有的元素都不接受事件检测
            continue;
          }

          if (child.getNumChildren() > 0) {
            var objs = child.getObjectsUnderPoint(point);

            if (objs.length > 0) {
              result = result.concat(objs);
            }
          }
        } else {
          if (!child._eventEnabled && !child.dragEnabled) {
            continue;
          }

          if (child.getChildInPoint(point)) {
            result.push(child);

            if (num != undefined && !isNaN(num)) {
              if (result.length == num) {
                return result;
              }
            }
          }
        }
      }

      return result;
    }
  }]);

  return DisplayObjectContainer;
}(DisplayObject);

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Stage = /*#__PURE__*/function (_DisplayObjectContain) {
  _inherits(Stage, _DisplayObjectContain);

  var _super = _createSuper$3(Stage);

  function Stage(opt) {
    var _this;

    _classCallCheck(this, Stage);

    opt.type = "stage";
    _this = _super.call(this, opt);
    _this.canvas = null; //渲染的时候由renderer决定,这里不做初始值, 也接受外界手动设置好的ctx

    _this.ctx = opt.ctx || null; //stage正在渲染中

    _this.stageRending = false;
    _this._isReady = false;
    return _this;
  } //由canvax的afterAddChild 回调
  //width、height都是app的width， 如果后续有每个stage设置不同的width和height，在判断opt里面的width和height


  _createClass(Stage, [{
    key: "initStage",
    value: function initStage(canvas, width, height) {
      var self = this;
      self.canvas = canvas;
      var model = self.context;
      model.width = width;
      model.height = height;
      model.scaleX = Settings.RESOLUTION;
      model.scaleY = Settings.RESOLUTION;
      self._isReady = true;
    }
  }, {
    key: "heartBeat",
    value: function heartBeat(opt) {
      //shape , name , value , preValue 
      //displayList中某个属性改变了
      if (!this._isReady) {
        //在stage还没初始化完毕的情况下，无需做任何处理
        return;
      }
      opt || (opt = {}); //如果opt为空，说明就是无条件刷新

      opt.stage = this; //TODO临时先这么处理

      this.parent && this.parent.heartBeat(opt);
    }
  }]);

  return Stage;
}(DisplayObjectContainer);

var SystemRenderer = /*#__PURE__*/function () {
  function SystemRenderer() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDERER_TYPE.UNKNOWN;
    var app = arguments.length > 1 ? arguments[1] : undefined;
    var options = arguments.length > 2 ? arguments[2] : undefined;

    _classCallCheck(this, SystemRenderer);

    this.type = type; //2canvas,1webgl

    this.app = app;

    if (options) {
      for (var i in Settings.RENDER_OPTIONS) {
        if (typeof options[i] === 'undefined') {
          options[i] = Settings.RENDER_OPTIONS[i];
        }
      }
    } else {
      options = Settings.RENDER_OPTIONS;
    }

    this.options = options;
    this.requestAid = null;
    this._heartBeat = false; //心跳，默认为false，即false的时候引擎处于静默状态 true则启动渲染

    this._preRenderTime = 0;
  } //如果引擎处于静默状态的话，就会启动


  _createClass(SystemRenderer, [{
    key: "startEnter",
    value: function startEnter() {
      var self = this;

      if (!self.requestAid) {
        self.requestAid = AnimationFrame.registFrame({
          id: "enterFrame",
          //同时肯定只有一个enterFrame的task
          task: function task() {
            self.enterFrame.apply(self);
          }
        });
      }
    }
  }, {
    key: "enterFrame",
    value: function enterFrame() {
      var self = this; //不管怎么样，enterFrame执行了就要把
      //requestAid null 掉

      self.requestAid = null;
      Utils.now = new Date().getTime();

      if (self._heartBeat) {
        //var _begin = new Date().getTime();
        this.app.children.length && self.render(this.app); //var _end = new Date().getTime();
        //$(document.body).append( "<br />render："+ (_end - _begin) );

        self._heartBeat = false; //渲染完了，打上最新时间挫

        self._preRenderTime = new Date().getTime();
      }
    }
  }, {
    key: "_convertCanvax",
    value: function _convertCanvax(opt) {
      var me = this;

      _.each(me.app.children, function (stage) {
        stage.context[opt.name] = opt.value;
      });
    }
  }, {
    key: "heartBeat",
    value: function heartBeat(opt) {
      //displayList中某个属性改变了
      var self = this;

      if (opt) {
        //心跳包有两种，一种是某元素的可视属性改变了。一种是children有变动
        //分别对应convertType  为 context  and children
        if (opt.convertType == "context") {
          var stage = opt.stage;
          var shape = opt.shape;
          var name = opt.name;
          var value = opt.value;
          var preValue = opt.preValue;

          if (shape.type == "canvax") {
            self._convertCanvax(opt);
          } else {
            if (!self.app.convertStages[stage.id]) {
              self.app.convertStages[stage.id] = {
                stage: stage,
                convertShapes: {}
              };
            }

            if (shape) {
              if (!self.app.convertStages[stage.id].convertShapes[shape.id]) {
                self.app.convertStages[stage.id].convertShapes[shape.id] = {
                  shape: shape,
                  convertType: opt.convertType
                };
              } else {
                //如果已经上报了该 shape 的心跳。
                return;
              }
            }
          }
        }

        if (opt.convertType == "children") {
          //元素结构变化，比如addchild removeChild等
          var target = opt.target;
          var stage = opt.src.getStage();

          if (stage || target.type == "stage") {
            //如果操作的目标元素是Stage
            stage = stage || target;

            if (!self.app.convertStages[stage.id]) {
              self.app.convertStages[stage.id] = {
                stage: stage,
                convertShapes: {}
              };
            }
          }
        }

        if (!opt.convertType) {
          //无条件要求刷新
          var stage = opt.stage;

          if (!self.app.convertStages[stage.id]) {
            self.app.convertStages[stage.id] = {
              stage: stage,
              convertShapes: {}
            };
          }
        }
      } else {
        //无条件要求全部刷新，一般用在resize等。
        _.each(self.app.children, function (stage, i) {
          self.app.convertStages[stage.id] = {
            stage: stage,
            convertShapes: {}
          };
        });
      }

      if (!self._heartBeat) {
        //如果发现引擎在静默状态，那么就唤醒引擎
        self._heartBeat = true;
        self.startEnter();
      } else {
        //否则智慧继续确认心跳
        self._heartBeat = true;
      }
    }
  }]);

  return SystemRenderer;
}();

var arrayLikeToArray = createCommonjsModule$1(function (module) {
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports$1(arrayLikeToArray);

var arrayWithoutHoles = createCommonjsModule$1(function (module) {
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports$1(arrayWithoutHoles);

var iterableToArray = createCommonjsModule$1(function (module) {
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports$1(iterableToArray);

var unsupportedIterableToArray = createCommonjsModule$1(function (module) {
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports$1(unsupportedIterableToArray);

var nonIterableSpread = createCommonjsModule$1(function (module) {
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports$1(nonIterableSpread);

var toConsumableArray = createCommonjsModule$1(function (module) {
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _toConsumableArray = unwrapExports$1(toConsumableArray);

var CanvasGraphicsRenderer = /*#__PURE__*/function () {
  function CanvasGraphicsRenderer(renderer) {
    _classCallCheck(this, CanvasGraphicsRenderer);

    this.renderer = renderer;
  }
  /**
  * @param displayObject
  * @stage 也可以displayObject.getStage()获取。
  */


  _createClass(CanvasGraphicsRenderer, [{
    key: "render",
    value: function render(displayObject, stage, globalAlpha, isClip) {
      var renderer = this.renderer;
      var graphicsData = displayObject.graphics.graphicsData;
      var ctx = stage.ctx;

      for (var i = 0; i < graphicsData.length; i++) {
        var data = graphicsData[i];
        var shape = data.shape;
        var fillStyle = data.fillStyle;

        if (fillStyle && _typeof(fillStyle) == 'object') {
          //兼容一下大小写
          var linearGradient = fillStyle.linearGradient || fillStyle.lineargradient;

          if (linearGradient && fillStyle.points) {
            (function () {
              var _style = ctx.createLinearGradient.apply(ctx, _toConsumableArray(fillStyle.points));

              linearGradient.forEach(function (item) {
                _style.addColorStop(item.position, item.color);
              });
              fillStyle = _style;
            })();
          }
        }

        var strokeStyle = data.strokeStyle;

        if (strokeStyle && _typeof(strokeStyle) == 'object') {
          //兼容一下大小写
          var _linearGradient = strokeStyle.linearGradient || strokeStyle.lineargradient;

          if (_linearGradient && strokeStyle.points) {
            (function () {
              var _style = ctx.createLinearGradient.apply(ctx, _toConsumableArray(strokeStyle.points));

              _linearGradient.forEach(function (item) {
                _style.addColorStop(item.position, item.color);
              });

              strokeStyle = _style;
            })();
          }
        }

        var fill = data.hasFill() && data.fillAlpha && !isClip;
        var line = data.hasLine() && data.strokeAlpha && !isClip;
        ctx.lineWidth = data.lineWidth;
        ctx.shadowColor = data.shadowColor;
        ctx.shadowBlur = data.shadowBlur;
        ctx.shadowOffsetX = data.shadowOffsetX;
        ctx.shadowOffsetY = data.shadowOffsetY;
        ctx.lineCap = data.lineCap;
        ctx.lineJoin = data.lineJoin;

        if (ctx.lineJoin == 'miter') {
          ctx.miterLimit = data.miterLimit;
        }

        if (data.type === SHAPES.POLY) {
          //只第一次需要beginPath()
          ctx.beginPath();
          this.renderPolygon(shape.points, shape.closed, ctx, isClip);

          if (fill) {
            ctx.globalAlpha = data.fillAlpha * globalAlpha;
            ctx.fillStyle = fillStyle;
            ctx.fill();
          }

          if (line) {
            ctx.globalAlpha = data.strokeAlpha * globalAlpha;
            ctx.strokeStyle = strokeStyle;

            if (fill && data.shadowBlur) {
              //如果有fill的时候也有shadow， 那么在描边的时候不需要阴影
              //因为fill的时候已经画过了
              ctx.shadowBlur = 0;
            }
            ctx.stroke();
          }
        } else if (data.type === SHAPES.RECT) {
          if (isClip) {
            //ctx.beginPath();
            //rect本身已经是个close的path
            ctx.rect(shape.x, shape.y, shape.width, shape.height); //ctx.closePath();
          }

          if (fill) {
            ctx.globalAlpha = data.fillAlpha * globalAlpha;
            ctx.fillStyle = fillStyle;
            ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
          }

          if (line) {
            ctx.globalAlpha = data.strokeAlpha * globalAlpha;
            ctx.strokeStyle = strokeStyle;

            if (fill && data.shadowBlur) {
              //如果有fill的时候也有shadow， 那么在描边的时候不需要阴影
              //因为fill的时候已经画过了
              ctx.shadowBlur = 0;
            }
            ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
          }
        } else if (data.type === SHAPES.CIRC) {
          // TODO - 这里应该可以不需要走graphics，而直接设置好radius
          ctx.beginPath();
          ctx.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
          ctx.closePath();

          if (fill) {
            ctx.globalAlpha = data.fillAlpha * globalAlpha;
            ctx.fillStyle = fillStyle;
            ctx.fill();
          }

          if (line) {
            ctx.globalAlpha = data.strokeAlpha * globalAlpha;
            ctx.strokeStyle = strokeStyle;

            if (fill && data.shadowBlur) {
              //如果有fill的时候也有shadow， 那么在描边的时候不需要阴影
              //因为fill的时候已经画过了
              ctx.shadowBlur = 0;
            }
            ctx.stroke();
          }
        } else if (data.type === SHAPES.ELIP) {
          var w = shape.width * 2;
          var h = shape.height * 2;
          var x = shape.x - w / 2;
          var y = shape.y - h / 2;
          ctx.beginPath();
          var kappa = 0.5522848;
          var ox = w / 2 * kappa; // control point offset horizontal

          var oy = h / 2 * kappa; // control point offset vertical

          var xe = x + w; // x-end

          var ye = y + h; // y-end

          var xm = x + w / 2; // x-middle

          var ym = y + h / 2; // y-middle

          ctx.moveTo(x, ym);
          ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
          ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
          ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
          ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
          ctx.closePath();

          if (fill) {
            ctx.globalAlpha = data.fillAlpha * globalAlpha;
            ctx.fillStyle = fillStyle;
            ctx.fill();
          }

          if (line) {
            ctx.globalAlpha = data.strokeAlpha * globalAlpha;
            ctx.strokeStyle = strokeStyle;

            if (fill && data.shadowBlur) {
              //如果有fill的时候也有shadow， 那么在描边的时候不需要阴影
              //因为fill的时候已经画过了
              ctx.shadowBlur = 0;
            }
            ctx.stroke();
          }
        }
      }
    }
  }, {
    key: "renderPolygon",
    value: function renderPolygon(points, close, ctx, isClip) {
      ctx.moveTo(points[0], points[1]);

      for (var j = 1; j < points.length / 2; ++j) {
        ctx.lineTo(points[j * 2], points[j * 2 + 1]);
      }

      if (close || isClip) {
        ctx.closePath();
      }
    }
  }]);

  return CanvasGraphicsRenderer;
}();

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var CanvasRenderer = /*#__PURE__*/function (_SystemRenderer) {
  _inherits(CanvasRenderer, _SystemRenderer);

  var _super = _createSuper$4(CanvasRenderer);

  function CanvasRenderer(app) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, CanvasRenderer);

    _this = _super.call(this, RENDERER_TYPE.CANVAS, app, options);
    _this.renderType = 'canvas';
    _this.CGR = new CanvasGraphicsRenderer(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(CanvasRenderer, [{
    key: "render",
    value: function render(app) {
      var me = this;
      me.app = app;

      _.each(_.values(app.convertStages), function (convertStage) {
        me.renderStage(convertStage.stage);
      });

      app.convertStages = {};
    }
  }, {
    key: "renderStage",
    value: function renderStage(stage) {
      if (!stage.ctx) {
        stage.ctx = stage.canvas.getContext("2d");
      }

      stage.stageRending = true;
      stage.setWorldTransform();

      this._clear(stage);

      this._render(stage, stage, stage.context.globalAlpha);

      stage.stageRending = false;
    }
  }, {
    key: "_render",
    value: function _render(stage, displayObject, globalAlpha) {
      var ctx = stage.ctx;

      if (!ctx) {
        return;
      }
      var $MC = displayObject.context.$model;

      if (!displayObject.worldTransform) {
        //第一次在舞台中渲染
        displayObject.fire("render");
      }

      if (!displayObject.worldTransform || displayObject._transformChange || displayObject.parent && displayObject.parent._transformChange) {
        displayObject.setWorldTransform();
        displayObject.fire("transform");
        displayObject._transformChange = true;
      }
      globalAlpha *= $MC.globalAlpha;

      if (!$MC.visible || displayObject.isClip) {
        return;
      }
      var worldMatrixArr = displayObject.worldTransform.toArray();

      if (worldMatrixArr) {
        ctx.setTransform.apply(ctx, worldMatrixArr);
      } else {
        //如果这个displayObject的世界矩阵有问题，那么就不绘制了
        return;
      }
      var isClipSave = false;

      if (displayObject.clip && displayObject.clip.graphics) {
        //如果这个对象有一个裁剪路径对象，那么就绘制这个裁剪路径
        var _clip = displayObject.clip;
        ctx.save();
        ctx.beginPath();
        isClipSave = true;

        if (!_clip.worldTransform || _clip._transformChange || _clip.parent._transformChange) {
          _clip.setWorldTransform();

          _clip._transformChange = true;
        }
        ctx.setTransform.apply(ctx, _clip.worldTransform.toArray()); //如果 graphicsData.length==0 的情况下才需要执行_draw来组织graphics数据

        if (!_clip.graphics.graphicsData.length) {
          //当渲染器开始渲染app的时候，app下面的所有displayObject都已经准备好了对应的世界矩阵
          _clip._draw(_clip.graphics); //_draw会完成绘制准备好 graphicsData

        }
        this.CGR.render(_clip, stage, globalAlpha, isClipSave);
        _clip._transformChange = false;
        ctx.clip();
      }

      if (displayObject.graphics) {
        //如果 graphicsData.length==0 的情况下才需要执行_draw来组织 graphics 数据
        if (!displayObject.graphics.graphicsData.length) {
          //当渲染器开始渲染app的时候，app下面的所有displayObject都已经准备好了对应的世界矩阵
          displayObject._draw(displayObject.graphics); //_draw会完成绘制准备好 graphicsData

        }
        //事件检测的时候需要用到graphics.graphicsData

        if (!!globalAlpha) {
          //默认要设置为实线
          ctx.setLineDash([]); //然后如果发现这个描边非实线的话，就设置为虚线

          if ($MC.lineType && $MC.lineType != 'solid') {
            ctx.setLineDash($MC.lineDash);
          }
          this.CGR.render(displayObject, stage, globalAlpha);
        }
      }

      if (displayObject.type == "text") {
        //如果是文本
        displayObject.render(ctx, globalAlpha);
      }

      if (displayObject.children) {
        for (var i = 0, len = displayObject.children.length; i < len; i++) {
          this._render(stage, displayObject.children[i], globalAlpha);
        }
      }
      displayObject._transformChange = false;

      if (isClipSave) {
        //如果这个对象有裁剪对象， 则要恢复，裁剪之前的环境
        ctx.closePath();
        ctx.restore();
      }

      if (ctx.draw) {
        ctx.draw(true);
      }
    }
  }, {
    key: "_clear",
    value: function _clear(stage) {
      var ctx = stage.ctx;
      ctx.setTransform.apply(ctx, stage.worldTransform.toArray());
      ctx.clearRect(0, 0, this.app.width, this.app.height);
    }
  }]);

  return CanvasRenderer;
}(SystemRenderer);

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var AlipayMiniRenderer = /*#__PURE__*/function (_CanvasRenderer) {
  _inherits(AlipayMiniRenderer, _CanvasRenderer);

  var _super = _createSuper$5(AlipayMiniRenderer);

  function AlipayMiniRenderer(app) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, AlipayMiniRenderer);

    _this = _super.call(this, app, options);
    _this.renderType = 'alipayMini';
    return _this;
  }

  return AlipayMiniRenderer;
}(CanvasRenderer);

function autoRenderer(app, opt) {
  var _renderer; //opt.renderer 支持cavnas alipayMini webGl(暂时弃用)


  if (opt.renderer == 'alipayMini') {
    _renderer = new AlipayMiniRenderer(app, opt);
  } else {
    _renderer = new CanvasRenderer(app, opt);
  }

  return _renderer;
  /*
     if (app.webGL && utils.isWebGLSupported())
     {
         return new WebGLRenderer( app , options);
     };
     return new CanvasRenderer( app , options);
     */
}

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Application = /*#__PURE__*/function (_DisplayObjectContain) {
  _inherits(Application, _DisplayObjectContain);

  var _super = _createSuper$6(Application);

  function Application(opt) {
    var _this;

    _classCallCheck(this, Application);

    opt.type = "canvax";
    _this = _super.call(this, opt);
    _this.uid = opt.uid || new Date().getTime() + "_" + Math.floor(Math.random() * 100);
    Settings.RESOLUTION = opt.devicePixelRatio || (typeof window !== 'undefined' ? window.devicePixelRatio : 1);
    _this.el = $.query(opt.el); //优先使用外部传入的width

    _this.width = opt.width || parseInt("width" in opt || _this.el.offsetWidth, 10);
    _this.height = opt.height || parseInt("height" in opt || _this.el.offsetHeight, 10); //小程序的话 没有el， 也就么有domview了

    if (_this.el) {
      var viewObj = $.createView(_this.width, _this.height, _this.uid);
      _this.view = viewObj.view;
      _this.stageView = viewObj.stageView;
      _this.domView = viewObj.domView;
      _this.el.innerHTML = "";

      _this.el.appendChild(_this.view);
    }
    _this.viewOffset = opt.viewOffset || $.offset(_this.view);
    _this.lastGetRO = 0; //最后一次获取 viewOffset 的时间

    _this.renderer = autoRenderer(_assertThisInitialized(_this), opt);
    _this.event = null; //该属性在systenRender里面操作，每帧由心跳上报的 需要重绘的stages 列表

    _this.convertStages = {};
    _this.context.$model.width = _this.width;
    _this.context.$model.height = _this.height; //然后创建一个用于绘制激活 shape 的 stage 到activation

    _this._bufferStage = _this._creatHoverStage(opt); //设置一个默认的matrix做为app的世界根节点坐标

    _this.worldTransform = new Matrix().identity();
    return _this;
  }

  _createClass(Application, [{
    key: "registEvent",
    value: function registEvent(opt) {
      //初始化事件委托到root元素上面
      this.event = new event.Handler(this, opt);
      this.event.init();
      return this.event;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      for (var i = 0, l = this.children.length; i < l; i++) {
        var stage = this.children[i];
        stage.destroy();
        stage.canvas = null;
        stage.ctx = null;
        stage = null;
        i--, l--;
      }

      try {
        this.view.removeChild(this.stageView);
        this.view.removeChild(this.domView);
        this.el.removeChild(this.view);
      } catch (e) {}
      this.el && (this.el.innerHTML = "");
      this.event = null;
      this._bufferStage = null;
    }
  }, {
    key: "resize",
    value: function resize(opt) {
      //重新设置坐标系统 高宽 等。
      this.width = parseInt(opt && "width" in opt || this.el.offsetWidth, 10);
      this.height = parseInt(opt && "height" in opt || this.el.offsetHeight, 10); //this.view  width height都一直设置为100%
      //this.view.style.width  = this.width +"px";
      //this.view.style.height = this.height+"px";

      if (this.view) {
        this.viewOffset = $.offset(this.view);
      }
      this.context.$model.width = this.width;
      this.context.$model.height = this.height;
      var me = this;

      var reSizeCanvas = function reSizeCanvas(canvas) {
        canvas.style.width = me.width + "px";
        canvas.style.height = me.height + "px";
        canvas.setAttribute("width", me.width * Settings.RESOLUTION);
        canvas.setAttribute("height", me.height * Settings.RESOLUTION);
      };

      _.each(this.children, function (s, i) {
        s.context.$model.width = me.width;
        s.context.$model.height = me.height;
        reSizeCanvas(s.canvas);
      });

      this.stageView.style.width = this.width + "px";
      this.stageView.style.height = this.height + "px";
      this.domView.style.width = this.width + "px";
      this.domView.style.height = this.height + "px";
      this.heartBeat();
    }
  }, {
    key: "getHoverStage",
    value: function getHoverStage() {
      return this._bufferStage;
    }
  }, {
    key: "_creatHoverStage",
    value: function _creatHoverStage(opt) {
      //TODO:创建stage的时候一定要传入width height  两个参数
      this._bufferStage = new Stage({
        id: "activCanvas" + new Date().getTime(),
        ctx: opt.activCanvas || null
      }); //该stage不参与事件检测

      this._bufferStage._eventEnabled = false;
      this.addChild(this._bufferStage);
      return this._bufferStage;
    } //小程序等不支持dom获取的地址需要手动调用下updateViewOffset()

  }, {
    key: "updateViewOffset",
    value: function updateViewOffset(viewOffset) {
      var now = new Date().getTime();

      if (now - this.lastGetRO > 1000) {
        this.viewOffset = viewOffset || $.offset(this.view);
        this.lastGetRO = now;
      }
    }
  }, {
    key: "_afterAddChild",
    value: function _afterAddChild(stage, index) {
      var canvas;

      if (!stage.canvas) {
        canvas = $.createCanvas(this.context.$model.width, this.context.$model.height, stage.id);
      } else {
        canvas = stage.canvas;
      }

      if (this.stageView) {
        if (this.children.length == 1) {
          this.stageView.appendChild(canvas);
        } else if (this.children.length > 1) {
          if (index === undefined) {
            //如果没有指定位置，那么就放到 _bufferStage 的下面。
            this.stageView.insertBefore(canvas, this._bufferStage.canvas);
          } else {
            //如果有指定的位置，那么就指定的位置来
            if (index >= this.children.length - 1) {
              this.stageView.appendChild(canvas);
            } else {
              this.stageView.insertBefore(canvas, this.children[index].canvas);
            }
          }
        }
      }
      Utils.initElement(canvas);
      stage.initStage(canvas, this.context.$model.width, this.context.$model.height);
    }
  }, {
    key: "_afterDelChild",
    value: function _afterDelChild(stage) {
      try {
        this.stageView && stage.canvas && this.stageView.removeChild(stage.canvas);
      } catch (error) {}
    }
  }, {
    key: "heartBeat",
    value: function heartBeat(opt) {
      if (this.children.length > 0) {
        this.renderer.heartBeat(opt);
      }
    }
  }, {
    key: "toDataURL",
    value: function toDataURL() {
      var canvas = $.createCanvas(this.width, this.height, "curr_base64_canvas");
      var ctx = canvas.getContext("2d");

      _.each(this.children, function (stage) {
        ctx.drawImage(stage.canvas, 0, 0);
      });

      return canvas.toDataURL();
    } //一些不能动态创建_pixelCtx用来做文本检测的环境，要支持可以从外面传一个ctx进来

  }, {
    key: "setPixelCtx",
    value: function setPixelCtx(ctx) {
      Utils._pixelCtx = ctx;
    }
  }]);

  return Application;
}(DisplayObjectContainer);

function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Sprite = /*#__PURE__*/function (_DisplayObjectContain) {
  _inherits(Sprite, _DisplayObjectContain);

  var _super = _createSuper$7(Sprite);

  function Sprite(opt) {
    _classCallCheck(this, Sprite);

    opt = Utils.checkOpt(opt);
    opt.type = "sprite";
    return _super.call(this, opt);
  }

  return Sprite;
}(DisplayObjectContainer);

var GraphicsData = /*#__PURE__*/function () {
  function GraphicsData(lineWidth, strokeStyle, strokeAlpha, fillStyle, fillAlpha, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, lineCap, lineJoin, miterLimit, shape) {
    _classCallCheck(this, GraphicsData);

    this.lineWidth = lineWidth;
    this.strokeStyle = strokeStyle;
    this.strokeAlpha = strokeAlpha;
    this.fillStyle = fillStyle;
    this.fillAlpha = fillAlpha;
    this.shadowOffsetX = shadowOffsetX;
    this.shadowOffsetY = shadowOffsetY;
    this.shadowBlur = shadowBlur;
    this.shadowColor = shadowColor;
    this.lineCap = lineCap;
    this.lineJoin = lineJoin;
    this.miterLimit = miterLimit;
    this.shape = shape;
    this.type = shape.type;
    this.holes = []; //这两个可以被后续修改， 具有一票否决权
    //比如polygon的 虚线描边。必须在fill的poly上面设置line为false

    this.fill = true;
    this.line = true;
  }

  _createClass(GraphicsData, [{
    key: "clone",
    value: function clone() {
      var cloneGraphicsData = new GraphicsData(this.lineWidth, this.strokeStyle, this.strokeAlpha, this.fillStyle, this.fillAlpha, this.shadowOffsetX, this.shadowOffsetY, this.shadowBlur, this.shadowColor, this.lineCap, this.lineJoin, this.miterLimit, this.shape);
      cloneGraphicsData.fill = this.fill;
      cloneGraphicsData.line = this.line;
      return cloneGraphicsData;
    }
  }, {
    key: "addHole",
    value: function addHole(shape) {
      this.holes.push(shape);
    } //从宿主graphics中同步最新的style属性

  }, {
    key: "synsStyle",
    value: function synsStyle(style) {
      //console.log("line:"+this.line+"__fill:"+this.fill)
      //从shape中把绘图需要的style属性同步过来
      if (this.line) {
        this.lineWidth = style.lineWidth;
        this.strokeStyle = style.strokeStyle;
        this.strokeAlpha = style.strokeAlpha;
      }

      if (this.fill) {
        this.fillStyle = style.fillStyle;
        this.fillAlpha = style.fillAlpha;
      }

      this.shadowOffsetX = style.shadowOffsetX; //阴影向右偏移量

      this.shadowOffsetY = style.shadowOffsetY; //阴影向下偏移量

      this.shadowBlur = style.shadowBlur; //阴影模糊效果

      this.shadowColor = style.shadowColor; //阴影颜色

      this.lineCap = style.lineCap;
      this.lineJoin = style.lineJoin;
      this.miterLimit = style.miterLimit;
    }
  }, {
    key: "hasFill",
    value: function hasFill() {
      return this.fillStyle && this.fill && this.shape.closed !== undefined && this.shape.closed;
    }
  }, {
    key: "hasLine",
    value: function hasLine() {
      return this.strokeStyle && this.lineWidth && this.line;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.shape = null;
      this.holes = null;
    }
  }]);

  return GraphicsData;
}();

var arcToSegmentsCache = {},
    segmentToBezierCache = {},
    boundsOfCurveCache = {},
    _join = Array.prototype.join;
/* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
 * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
 * http://mozilla.org/MPL/2.0/
 */

function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
  var argsString = _join.call(arguments);

  if (arcToSegmentsCache[argsString]) {
    return arcToSegmentsCache[argsString];
  }

  var PI = Math.PI,
      th = rotateX * PI / 180,
      sinTh = Math.sin(th),
      cosTh = Math.cos(th),
      fromX = 0,
      fromY = 0;
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
      py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
      rx2 = rx * rx,
      ry2 = ry * ry,
      py2 = py * py,
      px2 = px * px,
      pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
      root = 0;

  if (pl < 0) {
    var s = Math.sqrt(1 - pl / (rx2 * ry2));
    rx *= s;
    ry *= s;
  } else {
    root = (large === sweep ? -1.0 : 1.0) * Math.sqrt(pl / (rx2 * py2 + ry2 * px2));
  }

  var cx = root * rx * py / ry,
      cy = -root * ry * px / rx,
      cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
      cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
      mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
      dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);

  if (sweep === 0 && dtheta > 0) {
    dtheta -= 2 * PI;
  } else if (sweep === 1 && dtheta < 0) {
    dtheta += 2 * PI;
  } // Convert into cubic bezier segments <= 90deg


  var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
      result = [],
      mDelta = dtheta / segments,
      mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
      th3 = mTheta + mDelta;

  for (var i = 0; i < segments; i++) {
    result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
    fromX = result[i][4];
    fromY = result[i][5];
    mTheta = th3;
    th3 += mDelta;
  }

  arcToSegmentsCache[argsString] = result;
  return result;
}

function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
  var argsString2 = _join.call(arguments);

  if (segmentToBezierCache[argsString2]) {
    return segmentToBezierCache[argsString2];
  }

  var costh2 = Math.cos(th2),
      sinth2 = Math.sin(th2),
      costh3 = Math.cos(th3),
      sinth3 = Math.sin(th3),
      toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
      toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
      cp1X = fromX + mT * (-cosTh * rx * sinth2 - sinTh * ry * costh2),
      cp1Y = fromY + mT * (-sinTh * rx * sinth2 + cosTh * ry * costh2),
      cp2X = toX + mT * (cosTh * rx * sinth3 + sinTh * ry * costh3),
      cp2Y = toY + mT * (sinTh * rx * sinth3 - cosTh * ry * costh3);
  segmentToBezierCache[argsString2] = [cp1X, cp1Y, cp2X, cp2Y, toX, toY];
  return segmentToBezierCache[argsString2];
}
/*
 * Private
 */


function calcVectorAngle(ux, uy, vx, vy) {
  var ta = Math.atan2(uy, ux),
      tb = Math.atan2(vy, vx);

  if (tb >= ta) {
    return tb - ta;
  } else {
    return 2 * Math.PI - (ta - tb);
  }
}
/**
 * Draws arc
 * @param {graphics} graphics
 * @param {Number} fx
 * @param {Number} fy
 * @param {Array} coords
 */


var drawArc = function drawArc(graphics, fx, fy, coords) {
  var rx = coords[0],
      ry = coords[1],
      rot = coords[2],
      large = coords[3],
      sweep = coords[4],
      tx = coords[5],
      ty = coords[6],
      segs = [[], [], [], []],
      segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

  for (var i = 0, len = segsNorm.length; i < len; i++) {
    segs[i][0] = segsNorm[i][0] + fx;
    segs[i][1] = segsNorm[i][1] + fy;
    segs[i][2] = segsNorm[i][2] + fx;
    segs[i][3] = segsNorm[i][3] + fy;
    segs[i][4] = segsNorm[i][4] + fx;
    segs[i][5] = segsNorm[i][5] + fy;
    graphics.bezierCurveTo.apply(graphics, segs[i]);
  }
};
/**
 * Calculate bounding box of a elliptic-arc
 * @param {Number} fx start point of arc
 * @param {Number} fy
 * @param {Number} rx horizontal radius
 * @param {Number} ry vertical radius
 * @param {Number} rot angle of horizontal axe
 * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
 * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
 * @param {Number} tx end point of arc
 * @param {Number} ty
 */


var getBoundsOfArc = function getBoundsOfArc(fx, fy, rx, ry, rot, large, sweep, tx, ty) {
  var fromX = 0,
      fromY = 0,
      bound,
      bounds = [],
      segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

  for (var i = 0, len = segs.length; i < len; i++) {
    bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);
    bounds.push({
      x: bound[0].x + fx,
      y: bound[0].y + fy
    });
    bounds.push({
      x: bound[1].x + fx,
      y: bound[1].y + fy
    });
    fromX = segs[i][4];
    fromY = segs[i][5];
  }

  return bounds;
};
/**
 * Calculate bounding box of a beziercurve
 * @param {Number} x0 starting point
 * @param {Number} y0
 * @param {Number} x1 first control point
 * @param {Number} y1
 * @param {Number} x2 secondo control point
 * @param {Number} y2
 * @param {Number} x3 end of beizer
 * @param {Number} y3
 */
// taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.


function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
  var argsString = _join.call(arguments);

  if (boundsOfCurveCache[argsString]) {
    return boundsOfCurveCache[argsString];
  }

  var sqrt = Math.sqrt,
      min = Math.min,
      max = Math.max,
      abs = Math.abs,
      tvalues = [],
      bounds = [[], []],
      a,
      b,
      c,
      t,
      t1,
      t2,
      b2ac,
      sqrtb2ac;
  b = 6 * x0 - 12 * x1 + 6 * x2;
  a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
  c = 3 * x1 - 3 * x0;

  for (var i = 0; i < 2; ++i) {
    if (i > 0) {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }

    if (abs(a) < 1e-12) {
      if (abs(b) < 1e-12) {
        continue;
      }

      t = -c / b;

      if (0 < t && t < 1) {
        tvalues.push(t);
      }

      continue;
    }

    b2ac = b * b - 4 * c * a;

    if (b2ac < 0) {
      continue;
    }

    sqrtb2ac = sqrt(b2ac);
    t1 = (-b + sqrtb2ac) / (2 * a);

    if (0 < t1 && t1 < 1) {
      tvalues.push(t1);
    }

    t2 = (-b - sqrtb2ac) / (2 * a);

    if (0 < t2 && t2 < 1) {
      tvalues.push(t2);
    }
  }

  var x,
      y,
      j = tvalues.length,
      jlen = j,
      mt;

  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[0][j] = x;
    y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    bounds[1][j] = y;
  }

  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  var result = [{
    x: min.apply(null, bounds[0]),
    y: min.apply(null, bounds[1])
  }, {
    x: max.apply(null, bounds[0]),
    y: max.apply(null, bounds[1])
  }];
  boundsOfCurveCache[argsString] = result;
  return result;
}

var Arc = {
  drawArc: drawArc,
  getBoundsOfCurve: getBoundsOfCurve,
  getBoundsOfArc: getBoundsOfArc
};

var Rectangle = /*#__PURE__*/function () {
  function Rectangle() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    _classCallCheck(this, Rectangle);

    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.type = SHAPES.RECT;
    this.closed = true;
  }

  _createClass(Rectangle, [{
    key: "clone",
    value: function clone() {
      return new Rectangle(this.x, this.y, this.width, this.height);
    }
  }, {
    key: "copy",
    value: function copy(rectangle) {
      this.x = rectangle.x;
      this.y = rectangle.y;
      this.width = rectangle.width;
      this.height = rectangle.height;
      return this;
    }
  }, {
    key: "contains",
    value: function contains(x, y) {
      /*
      if (this.width <= 0 || this.height <= 0)
      {
          return false;
      }
      */
      if (this.height * y < 0 || this.width * x < 0) {
        return false;
      }

      if (x >= this.x && x <= this.x + this.width && (this.height >= 0 && y >= this.y && y <= this.y + this.height || this.height < 0 && y <= this.y && y >= this.y + this.height)) {
        return true;
      }

      return false; //当x和 width , y和height都 为正或者都未负数的情况下，才可能在范围内
    }
  }]);

  return Rectangle;
}();

var Circle = /*#__PURE__*/function () {
  function Circle() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, Circle);

    this.x = x;
    this.y = y;
    this.radius = radius;
    this.type = SHAPES.CIRC;
    this.closed = true;
  }

  _createClass(Circle, [{
    key: "clone",
    value: function clone() {
      return new Circle(this.x, this.y, this.radius);
    }
  }, {
    key: "contains",
    value: function contains(x, y) {
      if (this.radius <= 0) {
        return false;
      }

      var r2 = this.radius * this.radius;
      var dx = this.x - x;
      var dy = this.y - y;
      dx *= dx;
      dy *= dy;
      return dx + dy <= r2;
    }
  }, {
    key: "getBounds",
    value: function getBounds() {
      return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }
  }]);

  return Circle;
}();

var Ellipse = /*#__PURE__*/function () {
  function Ellipse() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    _classCallCheck(this, Ellipse);

    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.type = SHAPES.ELIP;
    this.closed = true;
  }

  _createClass(Ellipse, [{
    key: "clone",
    value: function clone() {
      return new Ellipse(this.x, this.y, this.width, this.height);
    }
  }, {
    key: "contains",
    value: function contains(x, y) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }

      var normx = (x - this.x) / this.width;
      var normy = (y - this.y) / this.height;
      normx *= normx;
      normy *= normy;
      return normx + normy <= 1;
    }
  }, {
    key: "getBounds",
    value: function getBounds() {
      return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    }
  }]);

  return Ellipse;
}();

var Polygon = /*#__PURE__*/function () {
  function Polygon() {
    for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
      points[_key] = arguments[_key];
    }

    _classCallCheck(this, Polygon);

    var point_0 = points[0];

    if (Array.isArray(point_0)) {
      points = point_0;
    }

    if (point_0 && "x" in point_0 && "y" in point_0) {
      var p = [];

      for (var i = 0, il = points.length; i < il; i++) {
        p.push(points[i].x, points[i].y);
      }

      points = p;
    }

    this.closed = true;
    this.points = points;
    this.type = SHAPES.POLY;
  }

  _createClass(Polygon, [{
    key: "clone",
    value: function clone() {
      return new Polygon(this.points.slice());
    }
  }, {
    key: "close",
    value: function close() {
      var points = this.points;

      if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1]) {
        points.push(points[0], points[1]);
      }

      this.closed = true;
    }
  }, {
    key: "contains",
    value: function contains(x, y) {
      return this._isInsidePolygon_WindingNumber(x, y);
    }
    /**
     * 多边形包含判断 Nonzero Winding Number Rule
     */

  }, {
    key: "_isInsidePolygon_WindingNumber",
    value: function _isInsidePolygon_WindingNumber(x, y) {
      var points = this.points;
      var wn = 0;

      for (var shiftP, shift = points[1] > y, i = 3; i < points.length; i += 2) {
        shiftP = shift;
        shift = points[i] > y;

        if (shiftP != shift) {
          var n = (shiftP ? 1 : 0) - (shift ? 1 : 0);

          if (n * ((points[i - 3] - x) * (points[i - 0] - y) - (points[i - 2] - y) * (points[i - 1] - x)) > 0) {
            wn += n;
          }
        }
      }
      return wn;
    }
  }]);

  return Polygon;
}();

function bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
  var path = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];
  var n = 20;
  var dt = 0;
  var dt2 = 0;
  var dt3 = 0;
  var t2 = 0;
  var t3 = 0;
  path.push(fromX, fromY);

  for (var i = 1, j = 0; i <= n; ++i) {
    j = i / n;
    dt = 1 - j;
    dt2 = dt * dt;
    dt3 = dt2 * dt;
    t2 = j * j;
    t3 = t2 * j;
    path.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
  }

  return path;
}

var Graphics = /*#__PURE__*/function () {
  function Graphics(shape) {
    _classCallCheck(this, Graphics);

    this.lineWidth = 1;
    this.strokeStyle = null;
    this.strokeAlpha = 1;
    this.fillStyle = null;
    this.fillAlpha = 1;
    this.shadowOffsetX = 0; //阴影向右偏移量

    this.shadowOffsetY = 0; //阴影向下偏移量

    this.shadowBlur = 0; //阴影模糊效果

    this.shadowColor = 'black'; //阴影颜色

    this.lineCap = 'round'; //默认都是直角

    this.lineJoin = 'round'; //这两个目前webgl里面没实现

    this.miterLimit = null; //miterLimit 属性设置或返回最大斜接长度,只有当 lineJoin 属性为 "miter" 时，miterLimit 才有效。
    //比如path m 0 0 l 0 0 m 1 1 l 1 1
    //就会有两条graphicsData数据产生

    this.graphicsData = [];
    this.currentPath = null;
    this.dirty = 0; //用于检测图形对象是否已更改。 如果这是设置为true，那么图形对象将被重新计算。

    this.clearDirty = 0; //用于检测我们是否清除了图形webGL数据

    this._webGL = {};
    this.worldAlpha = 1;
    this.tint = 0xFFFFFF; //目标对象附加颜色

    this.Bound = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }

  _createClass(Graphics, [{
    key: "setStyle",
    value: function setStyle(context) {
      //从 shape 中把绘图需要的style属性同步过来
      var model = context.$model;
      this.lineWidth = model.lineWidth;
      this.strokeStyle = model.strokeStyle;
      this.strokeAlpha = model.strokeAlpha * model.globalAlpha;
      this.fillStyle = model.fillStyle;
      this.fillAlpha = model.fillAlpha * model.globalAlpha;
      this.shadowOffsetX = model.shadowOffsetX; //阴影向右偏移量

      this.shadowOffsetY = model.shadowOffsetY; //阴影向下偏移量

      this.shadowBlur = model.shadowBlur; //阴影模糊效果

      this.shadowColor = model.shadowColor; //阴影颜色

      this.lineCap = model.lineCap;
      this.lineJoin = model.lineJoin;
      this.miterLimit = model.miterLimit;
      var g = this; //一般都是先设置好style的，所以 ， 当后面再次设置新的style的时候
      //会把所有的data都修改
      //TODO: 后面需要修改, 能精准的确定是修改 graphicsData 中的哪个data

      if (this.graphicsData.length) {
        _.each(this.graphicsData, function (gd, i) {
          gd.synsStyle(g);
        });
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      var clone = new Graphics();
      clone.dirty = 0; // copy graphics data

      for (var i = 0; i < this.graphicsData.length; ++i) {
        clone.graphicsData.push(this.graphicsData[i].clone());
      }

      clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];
      return clone;
    }
  }, {
    key: "moveTo",
    value: function moveTo(x, y) {
      var shape = new Polygon([x, y]);
      shape.closed = false;
      this.drawShape(shape);
      return this;
    }
  }, {
    key: "lineTo",
    value: function lineTo(x, y) {
      if (this.currentPath) {
        this.currentPath.shape.points.push(x, y);
        this.dirty++;
      } else {
        this.moveTo(0, 0);
      }

      return this;
    }
  }, {
    key: "quadraticCurveTo",
    value: function quadraticCurveTo(cpX, cpY, toX, toY) {
      if (this.currentPath) {
        if (this.currentPath.shape.points.length === 0) {
          this.currentPath.shape.points = [0, 0];
        }
      } else {
        this.moveTo(0, 0);
      }

      var n = 20;
      var points = this.currentPath.shape.points;
      var xa = 0;
      var ya = 0;

      if (points.length === 0) {
        this.moveTo(0, 0);
      }

      var fromX = points[points.length - 2];
      var fromY = points[points.length - 1];

      for (var i = 1; i <= n; ++i) {
        var j = i / n;
        xa = fromX + (cpX - fromX) * j;
        ya = fromY + (cpY - fromY) * j;
        points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
      }

      this.dirty++;
      return this;
    }
  }, {
    key: "bezierCurveTo",
    value: function bezierCurveTo$1(cpX, cpY, cpX2, cpY2, toX, toY) {
      if (this.currentPath) {
        if (this.currentPath.shape.points.length === 0) {
          this.currentPath.shape.points = [0, 0];
        }
      } else {
        this.moveTo(0, 0);
      }

      var points = this.currentPath.shape.points;
      var fromX = points[points.length - 2];
      var fromY = points[points.length - 1];
      points.length -= 2;

      bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, points);

      this.dirty++;
      return this;
    }
  }, {
    key: "arcTo",
    value: function arcTo(x1, y1, x2, y2, radius) {
      if (this.currentPath) {
        if (this.currentPath.shape.points.length === 0) {
          this.currentPath.shape.points.push(x1, y1);
        }
      } else {
        this.moveTo(x1, y1);
      }

      var points = this.currentPath.shape.points;
      var fromX = points[points.length - 2];
      var fromY = points[points.length - 1];
      var a1 = fromY - y1;
      var b1 = fromX - x1;
      var a2 = y2 - y1;
      var b2 = x2 - x1;
      var mm = Math.abs(a1 * b2 - b1 * a2);

      if (mm < 1.0e-8 || radius === 0) {
        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
          points.push(x1, y1);
        }
      } else {
        var dd = a1 * a1 + b1 * b1;
        var cc = a2 * a2 + b2 * b2;
        var tt = a1 * a2 + b1 * b2;
        var k1 = radius * Math.sqrt(dd) / mm;
        var k2 = radius * Math.sqrt(cc) / mm;
        var j1 = k1 * tt / dd;
        var j2 = k2 * tt / cc;
        var cx = k1 * b2 + k2 * b1;
        var cy = k1 * a2 + k2 * a1;
        var px = b1 * (k2 + j1);
        var py = a1 * (k2 + j1);
        var qx = b2 * (k1 + j2);
        var qy = a2 * (k1 + j2);
        var startAngle = Math.atan2(py - cy, px - cx);
        var endAngle = Math.atan2(qy - cy, qx - cx);
        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
      }

      this.dirty++;
      return this;
    }
  }, {
    key: "arc",
    value: function arc(cx, cy, radius, startAngle, endAngle) {
      var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

      if (startAngle === endAngle) {
        return this;
      }

      if (!anticlockwise && endAngle <= startAngle) {
        endAngle += Math.PI * 2;
      } else if (anticlockwise && startAngle <= endAngle) {
        startAngle += Math.PI * 2;
      }

      var sweep = endAngle - startAngle;
      var segs = Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 48;

      if (sweep === 0) {
        return this;
      }

      var startX = cx + Math.cos(startAngle) * radius;
      var startY = cy + Math.sin(startAngle) * radius; // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.

      var points = this.currentPath ? this.currentPath.shape.points : null;

      if (points) {
        if (points[points.length - 2] !== startX || points[points.length - 1] !== startY) {
          points.push(startX, startY);
        }
      } else {
        this.moveTo(startX, startY);
        points = this.currentPath.shape.points;
      }

      var theta = sweep / (segs * 2);
      var theta2 = theta * 2;
      var cTheta = Math.cos(theta);
      var sTheta = Math.sin(theta);
      var segMinus = segs - 1;
      var remainder = segMinus % 1 / segMinus;

      for (var i = 0; i <= segMinus; ++i) {
        var real = i + remainder * i;
        var angle = theta + startAngle + theta2 * real;
        var c = Math.cos(angle);
        var s = -Math.sin(angle);
        points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
      }

      this.dirty++;
      return this;
    }
  }, {
    key: "drawRect",
    value: function drawRect(x, y, width, height) {
      this.drawShape(new Rectangle(x, y, width, height));
      return this;
    }
  }, {
    key: "drawCircle",
    value: function drawCircle(x, y, radius) {
      this.drawShape(new Circle(x, y, radius));
      return this;
    }
  }, {
    key: "drawEllipse",
    value: function drawEllipse(x, y, width, height) {
      this.drawShape(new Ellipse(x, y, width, height));
      return this;
    }
  }, {
    key: "drawPolygon",
    value: function drawPolygon(path) {
      // prevents an argument assignment deopt
      // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
      var points = path;
      var closed = true;

      if (points instanceof Polygon) {
        closed = points.closed;
        points = points.points;
      }

      if (!Array.isArray(points)) {
        // prevents an argument leak deopt
        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        points = new Array(arguments.length);

        for (var i = 0; i < points.length; ++i) {
          points[i] = arguments[i]; // eslint-disable-line prefer-rest-params
        }
      }

      var shape = new Polygon(points);
      shape.closed = closed;
      this.drawShape(shape);
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      if (this.graphicsData.length > 0) {
        this.dirty++;
        this.clearDirty++;
        this.graphicsData.length = 0;
      }

      this.currentPath = null;
      return this;
    }
  }, {
    key: "drawShape",
    value: function drawShape(shape) {
      if (this.currentPath) {
        if (this.currentPath.shape.points.length <= 2) {
          this.graphicsData.pop();
        }
      } //this.currentPath = null;


      this.beginPath();
      var data = new GraphicsData(this.lineWidth, this.strokeStyle, this.strokeAlpha, this.fillStyle, this.fillAlpha, this.shadowOffsetX, //阴影向右偏移量
      this.shadowOffsetY, //阴影向下偏移量
      this.shadowBlur, //阴影模糊效果
      this.shadowColor, //阴影颜色
      this.lineCap, this.lineJoin, this.miterLimit, shape);
      this.graphicsData.push(data);

      if (data.type === SHAPES.POLY) {
        data.shape.closed = data.shape.closed;
        this.currentPath = data;
      }

      this.dirty++;
      return data;
    }
  }, {
    key: "beginPath",
    value: function beginPath() {
      this.currentPath = null;
    }
  }, {
    key: "closePath",
    value: function closePath() {
      var currentPath = this.currentPath;

      if (currentPath && currentPath.shape) {
        currentPath.shape.close();
      }

      return this;
    }
    /**
    * Update the bounds of the object
    *
    */

  }, {
    key: "updateLocalBounds",
    value: function updateLocalBounds() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;

      if (this.graphicsData.length) {
        var shape = 0;
        var x = 0;
        var y = 0;
        var w = 0;
        var h = 0;

        for (var i = 0; i < this.graphicsData.length; i++) {
          var data = this.graphicsData[i];
          var type = data.type;
          var lineWidth = data.lineWidth;
          shape = data.shape;

          if (type === SHAPES.RECT || type === SHAPES.RREC) {
            x = shape.x - lineWidth / 2;
            y = shape.y - lineWidth / 2;
            w = shape.width + lineWidth;
            h = shape.height + lineWidth;
            minX = x < minX ? x : minX;
            maxX = x + w > maxX ? x + w : maxX;
            minY = y < minY ? y : minY;
            maxY = y + h > maxY ? y + h : maxY;
          } else if (type === SHAPES.CIRC) {
            x = shape.x;
            y = shape.y;
            w = shape.radius + lineWidth / 2;
            h = shape.radius + lineWidth / 2;
            minX = x - w < minX ? x - w : minX;
            maxX = x + w > maxX ? x + w : maxX;
            minY = y - h < minY ? y - h : minY;
            maxY = y + h > maxY ? y + h : maxY;
          } else if (type === SHAPES.ELIP) {
            x = shape.x;
            y = shape.y;
            w = shape.width + lineWidth / 2;
            h = shape.height + lineWidth / 2;
            minX = x - w < minX ? x - w : minX;
            maxX = x + w > maxX ? x + w : maxX;
            minY = y - h < minY ? y - h : minY;
            maxY = y + h > maxY ? y + h : maxY;
          } else {
            // POLY
            var points = shape.points;
            var x2 = 0;
            var y2 = 0;
            var dx = 0;
            var dy = 0;
            var rw = 0;
            var rh = 0;
            var cx = 0;
            var cy = 0;

            for (var j = 0; j + 2 < points.length; j += 2) {
              x = points[j];
              y = points[j + 1];
              x2 = points[j + 2];
              y2 = points[j + 3];
              dx = Math.abs(x2 - x);
              dy = Math.abs(y2 - y);
              h = lineWidth;
              w = Math.sqrt(dx * dx + dy * dy);

              if (w < 1e-9) {
                continue;
              }

              rw = (h / w * dy + dx) / 2;
              rh = (h / w * dx + dy) / 2;
              cx = (x2 + x) / 2;
              cy = (y2 + y) / 2;
              minX = cx - rw < minX ? cx - rw : minX;
              maxX = cx + rw > maxX ? cx + rw : maxX;
              minY = cy - rh < minY ? cy - rh : minY;
              maxY = cy + rh > maxY ? cy + rh : maxY;
            }
          }
        }
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }

      this.Bound = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
      return this;
    }
  }, {
    key: "getBound",
    value: function getBound() {
      return this.updateLocalBounds().Bound;
    }
  }, {
    key: "destroy",
    value: function destroy(options) {
      for (var i = 0; i < this.graphicsData.length; ++i) {
        this.graphicsData[i].destroy();
      }

      for (var id in this._webGL) {
        for (var j = 0; j < this._webGL[id].data.length; ++j) {
          this._webGL[id].data[j].destroy();
        }
      }

      this.graphicsData = null;
      this.currentPath = null;
      this._webGL = null;
    }
  }]);

  return Graphics;
}();

function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Shape = /*#__PURE__*/function (_DisplayObject) {
  _inherits(Shape, _DisplayObject);

  var _super = _createSuper$8(Shape);

  function Shape(opt) {
    var _this;

    _classCallCheck(this, Shape);

    opt = Utils.checkOpt(opt);
    var styleContext = {
      cursor: opt.context.cursor || "default",
      fillAlpha: opt.context.fillAlpha || 1,
      //context2d里没有，自定义
      fillStyle: opt.context.fillStyle || null,
      //"#000000",
      lineCap: opt.context.lineCap || "round",
      //默认都是直角
      lineJoin: opt.context.lineJoin || "round",
      //这两个目前webgl里面没实现
      miterLimit: opt.context.miterLimit || null,
      //miterLimit 属性设置或返回最大斜接长度,只有当 lineJoin 属性为 "miter" 时，miterLimit 才有效。
      strokeAlpha: opt.context.strokeAlpha || 1,
      //context2d里没有，自定义
      strokeStyle: opt.context.strokeStyle || null,
      lineType: opt.context.lineType || "solid",
      //context2d里没有，自定义线条的type，默认为实线
      lineDash: opt.context.lineDash || [5, 2],
      lineWidth: opt.context.lineWidth || null,
      shadowOffsetX: opt.context.shadowOffsetX || 0,
      //阴影向右偏移量
      shadowOffsetY: opt.context.shadowOffsetY || 0,
      //阴影向下偏移量
      shadowBlur: opt.context.shadowBlur || 0,
      //阴影模糊效果
      shadowColor: opt.context.shadowColor || "#000000" //阴影颜色

    };

    var _context = _.extend(true, styleContext, opt.context);

    opt.context = _context;

    if (opt.id === undefined && opt.type !== undefined) {
      opt.id = Utils.createId(opt.type);
    }
    _this = _super.call(this, opt); //over的时候如果有修改样式，就为true

    _this._hoverClass = false;
    _this.hoverClone = true; //是否开启在hover的时候clone一份到active stage 中 

    _this.pointChkPriority = true; //在鼠标mouseover到该节点，然后mousemove的时候，是否优先检测该节点

    _this._eventEnabled = false; //是否响应事件交互,在添加了事件侦听后会自动设置为true

    _this.dragEnabled = opt.dragEnabled || false; //"dragEnabled" in opt ? opt.dragEnabled : false;   //是否启用元素的拖拽
    //拖拽drag的时候显示在activShape的副本

    _this._dragDuplicate = null;
    _this.type = _this.type || "shape"; //处理所有的图形一些共有的属性配置,把除开id,context之外的所有属性，全部挂载到this上面

    _this.initCompProperty(opt); //如果该元素是clone而来，则不需要绘制


    if (!_this.isClone) {
      //如果是clone对象的话就直接
      _this.graphics = new Graphics();

      _this._draw(_this.graphics);
    } else {
      _this.graphics = null;
    }

    return _this;
  }

  _createClass(Shape, [{
    key: "_draw",
    value: function _draw(graphics) {
      if (graphics.graphicsData.length == 0) {
        //先设置好当前graphics的style
        graphics.setStyle(this.context);
        this.draw(graphics);
      }
    }
  }, {
    key: "draw",
    value: function draw() {}
  }, {
    key: "clearGraphicsData",
    value: function clearGraphicsData() {
      this.graphics.clear();
    }
  }, {
    key: "$watch",
    value: function $watch(name, value, preValue) {
      if (_.indexOf(STYLE_PROPS, name) > -1) {
        this.graphics.setStyle(this.context);
      }
      this.watch(name, value, preValue);
    }
  }, {
    key: "initCompProperty",
    value: function initCompProperty(opt) {
      for (var i in opt) {
        if (i != "id" && i != "context") {
          this[i] = opt[i];
        }
      }
    }
  }, {
    key: "getBound",
    value: function getBound() {
      return this.graphics.updateLocalBounds().Bound;
    }
  }]);

  return Shape;
}(DisplayObject);

function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Text = /*#__PURE__*/function (_DisplayObject) {
  _inherits(Text, _DisplayObject);

  var _super = _createSuper$9(Text);

  function Text(text, opt) {
    var _this;

    _classCallCheck(this, Text);

    opt.type = "text";

    if (text === null || text === undefined) {
      text = "";
    }
    opt.context = _.extend({
      font: "",
      fontSize: 13,
      //字体大小默认13
      fontWeight: "normal",
      fontFamily: "微软雅黑,sans-serif",
      textBaseline: "top",
      textAlign: "left",
      textDecoration: null,
      fillStyle: 'blank',
      strokeStyle: null,
      lineWidth: 0,
      lineHeight: 1.2,
      backgroundColor: null,
      textBackgroundColor: null
    }, opt.context);
    _this = _super.call(this, opt);
    _this._reNewline = /\r?\n/;
    _this.fontProperts = ["fontStyle", "fontVariant", "fontWeight", "fontSize", "fontFamily"];
    _this.context.font = _this._getFontDeclaration();
    _this.text = text.toString();
    _this.context.width = _this.getTextWidth();
    _this.context.height = _this.getTextHeight();
    return _this;
  }

  _createClass(Text, [{
    key: "$watch",
    value: function $watch(name, value, preValue) {
      //context属性有变化的监听函数
      if (_.indexOf(this.fontProperts, name) >= 0) {
        this.context[name] = value; //如果修改的是font的某个内容，就重新组装一遍font的值，
        //然后通知引擎这次对context的修改上报心跳

        this.context.font = this._getFontDeclaration();
        this.context.width = this.getTextWidth();
        this.context.height = this.getTextHeight();
      }
    }
  }, {
    key: "_setContextStyle",
    value: function _setContextStyle(ctx, style, globalAlpha) {
      // 简单判断不做严格类型检测
      for (var p in style) {
        if (p != "textBaseline" && p in ctx) {
          if (style[p] || _.isNumber(style[p])) {
            if (p == "globalAlpha") {
              //透明度要从父节点继承
              //ctx[p] = style[p] * globalAlpha; //render里面已经做过相乘了，不需要重新*
              ctx.globalAlpha = globalAlpha;
            } else {
              ctx[p] = style[p];
            }
          }
        }
      }
      return;
    }
  }, {
    key: "render",
    value: function render(ctx, globalAlpha) {
      this._renderText(ctx, this._getTextLines(), globalAlpha);
    }
  }, {
    key: "resetText",
    value: function resetText(text) {
      this.text = text.toString();
      this.heartBeat();
    }
  }, {
    key: "getTextWidth",
    value: function getTextWidth() {
      var width = 0;

      if (Utils._pixelCtx) {
        Utils._pixelCtx.save();

        Utils._pixelCtx.font = this.context.$model.font;
        width = this._getTextWidth(Utils._pixelCtx, this._getTextLines());

        Utils._pixelCtx.restore();
      }
      return width;
    }
  }, {
    key: "getTextHeight",
    value: function getTextHeight() {
      return this._getTextHeight(this._getTextLines());
    }
  }, {
    key: "_getTextLines",
    value: function _getTextLines() {
      return this.text.split(this._reNewline);
    }
  }, {
    key: "_renderText",
    value: function _renderText(ctx, textLines, globalAlpha) {
      if (!ctx) return;
      ctx.save();

      this._setContextStyle(ctx, this.context.$model, globalAlpha);

      this._renderTextStroke(ctx, textLines);

      this._renderTextFill(ctx, textLines);

      ctx.restore();
    }
  }, {
    key: "_getFontDeclaration",
    value: function _getFontDeclaration() {
      var self = this;
      var fontArr = [];

      _.each(this.fontProperts, function (p) {
        var fontP = self.context[p];

        if (p == "fontSize") {
          fontP = parseFloat(fontP) + "px";
        }

        fontP && fontArr.push(fontP);
      });

      return fontArr.join(' ');
    }
  }, {
    key: "_renderTextFill",
    value: function _renderTextFill(ctx, textLines) {
      if (!this.context.$model.fillStyle) return;
      this._boundaries = [];
      var lineHeights = 0;

      for (var i = 0, len = textLines.length; i < len; i++) {
        var heightOfLine = this._getHeightOfLine(ctx, i, textLines);

        lineHeights += heightOfLine;

        this._renderTextLine('fillText', ctx, textLines[i], 0, //this._getLeftOffset(),
        this._getTopOffset() + lineHeights, i);
      }
    }
  }, {
    key: "_renderTextStroke",
    value: function _renderTextStroke(ctx, textLines) {
      if (!ctx) return;
      if (!this.context.$model.strokeStyle || !this.context.$model.lineWidth) return;
      var lineHeights = 0;
      ctx.save();

      if (this.strokeDashArray) {
        if (1 & this.strokeDashArray.length) {
          this.strokeDashArray.push.apply(this.strokeDashArray, this.strokeDashArray);
        }

        supportsLineDash && ctx.setLineDash(this.strokeDashArray);
      }

      ctx.beginPath();

      for (var i = 0, len = textLines.length; i < len; i++) {
        var heightOfLine = this._getHeightOfLine(ctx, i, textLines);

        lineHeights += heightOfLine;

        this._renderTextLine('strokeText', ctx, textLines[i], 0, //this._getLeftOffset(),
        this._getTopOffset() + lineHeights, i);
      }

      ctx.closePath();
      ctx.restore();
    }
  }, {
    key: "_renderTextLine",
    value: function _renderTextLine(method, ctx, line, left, top, lineIndex) {
      top -= this._getHeightOfLine() / 4;

      if (this.context.$model.textAlign !== 'justify') {
        this._renderChars(method, ctx, line, left, top, lineIndex);

        return;
      }
      var lineWidth = ctx.measureText(line).width;
      var totalWidth = this.context.$model.width;

      if (totalWidth > lineWidth) {
        var words = line.split(/\s+/);
        var wordsWidth = ctx.measureText(line.replace(/\s+/g, '')).width;
        var widthDiff = totalWidth - wordsWidth;
        var numSpaces = words.length - 1;
        var spaceWidth = widthDiff / numSpaces;
        var leftOffset = 0;

        for (var i = 0, len = words.length; i < len; i++) {
          this._renderChars(method, ctx, words[i], left + leftOffset, top, lineIndex);

          leftOffset += ctx.measureText(words[i]).width + spaceWidth;
        }
      } else {
        this._renderChars(method, ctx, line, left, top, lineIndex);
      }
    }
  }, {
    key: "_renderChars",
    value: function _renderChars(method, ctx, chars, left, top) {
      ctx[method](chars, 0, top);
    }
  }, {
    key: "_getHeightOfLine",
    value: function _getHeightOfLine() {
      return this.context.$model.fontSize * this.context.$model.lineHeight;
    }
  }, {
    key: "_getTextWidth",
    value: function _getTextWidth(ctx, textLines) {
      var maxWidth = ctx.measureText(textLines[0] || '|').width;

      for (var i = 1, len = textLines.length; i < len; i++) {
        var currentLineWidth = ctx.measureText(textLines[i]).width;

        if (currentLineWidth > maxWidth) {
          maxWidth = currentLineWidth;
        }
      }

      return maxWidth;
    }
  }, {
    key: "_getTextHeight",
    value: function _getTextHeight(textLines) {
      return this.context.$model.fontSize * textLines.length * this.context.$model.lineHeight;
    }
    /**
     * @private
     * @return {Number} Top offset
     */

  }, {
    key: "_getTopOffset",
    value: function _getTopOffset() {
      var t = 0;

      switch (this.context.$model.textBaseline) {
        case "top":
          t = 0;
          break;

        case "middle":
          t = -this.context.$model.height / 2;
          break;

        case "bottom":
          t = -this.context.$model.height;
          break;
      }

      return t;
    }
  }, {
    key: "getRect",
    value: function getRect() {
      var c = this.context;
      var x = 0;
      var y = 0; //更具textAlign 和 textBaseline 重新矫正 xy

      if (c.textAlign == "center") {
        x = -c.width / 2;
      }

      if (c.textAlign == "right") {
        x = -c.width;
      }

      if (c.textBaseline == "middle") {
        y = -c.height / 2;
      }

      if (c.textBaseline == "bottom") {
        y = -c.height;
      }
      return {
        x: x,
        y: y,
        width: c.width,
        height: c.height
      };
    }
  }]);

  return Text;
}(DisplayObject);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 向量操作类
 * */

function Vector(x, y) {
  var vx = 0,
      vy = 0;

  if (arguments.length == 1 && _.isObject(x)) {
    var arg = arguments[0];

    if (_.isArray(arg)) {
      vx = arg[0];
      vy = arg[1];
    } else if (arg.hasOwnProperty("x") && arg.hasOwnProperty("y")) {
      vx = arg.x;
      vy = arg.y;
    }
  }

  this._axes = [vx, vy];
}
Vector.prototype = {
  distance: function distance(v) {
    var x = this._axes[0] - v._axes[0];
    var y = this._axes[1] - v._axes[1];
    return Math.sqrt(x * x + y * y);
  }
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 处理为平滑线条
 */
/**
 * curvature 曲率
 */

function interpolate(p0, p1, p2, p3, t, t2, t3, curvature) {
  if (isNaN(curvature) || curvature == null) {
    curvature = 0.25;
  }
  var v0 = (p2 - p0) * curvature;
  var v1 = (p3 - p1) * curvature;
  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
}
/**
 * 多线段平滑曲线 
 * opt ==> points , isLoop
 */


function SmoothSpline (opt) {
  var points = opt.points;
  var isLoop = opt.isLoop;
  var smoothFilter = opt.smoothFilter;
  var curvature = opt.curvature; //曲率

  var len = points.length;

  if (len == 1) {
    return points;
  }

  var ret = [];
  var distance = 0;
  var preVertor = new Vector(points[0]);
  var iVtor = null;

  for (var i = 1; i < len; i++) {
    iVtor = new Vector(points[i]);
    distance += preVertor.distance(iVtor);
    preVertor = iVtor;
  }

  preVertor = null;
  iVtor = null; //基本上等于曲率

  var segs = distance / 6;
  segs = segs < len ? len : segs;

  for (var i = 0; i < segs; i++) {
    var pos = i / (segs - 1) * (isLoop ? len : len - 1);
    var idx = Math.floor(pos);
    var w = pos - idx;
    var p0;
    var p1 = points[idx % len];
    var p2;
    var p3;

    if (!isLoop) {
      p0 = points[idx === 0 ? idx : idx - 1];
      p2 = points[idx > len - 2 ? len - 1 : idx + 1];
      p3 = points[idx > len - 3 ? len - 1 : idx + 2];
    } else {
      p0 = points[(idx - 1 + len) % len];
      p2 = points[(idx + 1) % len];
      p3 = points[(idx + 2) % len];
    }

    var w2 = w * w;
    var w3 = w * w2;
    var rp = [interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3, curvature), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3, curvature)];
    _.isFunction(smoothFilter) && smoothFilter(rp);
    ret.push(rp);
  }

  return ret;
}

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 数学 类
 *
 **/
var _cache = {
  sin: {},
  //sin缓存
  cos: {} //cos缓存

};

var _radians = Math.PI / 180;
/**
 * @param angle 弧度（角度）参数
 * @param isDegrees angle参数是否为角度计算，默认为false，angle为以弧度计量的角度
 */


function sin(angle, isDegrees) {
  angle = (isDegrees ? angle * _radians : angle).toFixed(4);

  if (typeof _cache.sin[angle] == 'undefined') {
    _cache.sin[angle] = Math.sin(angle);
  }

  return _cache.sin[angle];
}
/**
 * @param radians 弧度参数
 */


function cos(angle, isDegrees) {
  angle = (isDegrees ? angle * _radians : angle).toFixed(4);

  if (typeof _cache.cos[angle] == 'undefined') {
    _cache.cos[angle] = Math.cos(angle);
  }

  return _cache.cos[angle];
}
/**
 * 角度转弧度
 * @param {Object} angle
 */


function degreeToRadian(angle) {
  return angle * _radians;
}
/**
 * 弧度转角度
 * @param {Object} angle
 */


function radianToDegree(angle) {
  return angle / _radians;
}
/*
 * 校验角度到360度内
 * @param {angle} number
 */


function degreeTo360(angle) {
  var reAng = (360 + angle % 360) % 360; //Math.abs(360 + Math.ceil( angle ) % 360) % 360;

  if (reAng == 0 && angle !== 0) {
    reAng = 360;
  }

  return reAng;
}

function getIsgonPointList(n, r) {
  var pointList = [];
  var dStep = 2 * Math.PI / n;
  var beginDeg = -Math.PI / 2;
  var deg = beginDeg;

  for (var i = 0, end = n; i < end; i++) {
    pointList.push([r * Math.cos(deg), r * Math.sin(deg)]);
    deg += dStep;
  }
  return pointList;
}

function getSmoothPointList(pList, smoothFilter, curvature) {
  //smoothFilter -- 比如在折线图中。会传一个smoothFilter过来做point的纠正。
  //让y不能超过底部的原点
  var List = [];
  var Len = pList.length;
  var _currList = [];

  _.each(pList, function (point, i) {
    if (isNotValibPoint(point)) {
      //undefined , [ number, null] 等结构
      if (_currList.length) {
        List = List.concat(_getSmoothGroupPointList(_currList, smoothFilter, curvature));
        _currList = [];
      }

      List.push(point);
    } else {
      //有效的point 都push 进_currList 准备做曲线设置
      _currList.push(point);
    }

    if (i == Len - 1) {
      if (_currList.length) {
        List = List.concat(_getSmoothGroupPointList(_currList, smoothFilter, curvature));
        _currList = [];
      }
    }
  });

  return List;
}

function _getSmoothGroupPointList(pList, smoothFilter, curvature) {
  var obj = {
    points: pList,
    curvature: curvature
  };

  if (_.isFunction(smoothFilter)) {
    obj.smoothFilter = smoothFilter;
  }

  var currL = SmoothSpline(obj);

  if (pList && pList.length > 0) {
    currL.push(pList[pList.length - 1]);
  }
  return currL;
}

function isNotValibPoint(point) {
  var res = !point || _.isArray(point) && point.length >= 2 && (!_.isNumber(point[0]) || !_.isNumber(point[1])) || "x" in point && !_.isNumber(point.x) || "y" in point && !_.isNumber(point.y);
  return res;
}

function isValibPoint(point) {
  return !isNotValibPoint(point);
}

var myMath = {
  PI: Math.PI,
  sin: sin,
  cos: cos,
  degreeToRadian: degreeToRadian,
  radianToDegree: radianToDegree,
  degreeTo360: degreeTo360,
  getIsgonPointList: getIsgonPointList,
  getSmoothPointList: getSmoothPointList,
  isNotValibPoint: isNotValibPoint,
  isValibPoint: isValibPoint
};

function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var mathMin = Math.min;
var mathMax = Math.max;

var BrokenLine = /*#__PURE__*/function (_Shape) {
  _inherits(BrokenLine, _Shape);

  var _super = _createSuper$a(BrokenLine);

  function BrokenLine(opt) {
    _classCallCheck(this, BrokenLine);

    opt = Utils.checkOpt(opt);

    var _context = _.extend(true, {
      lineType: null,
      smooth: false,
      smoothMonotone: 'none',
      pointList: [] //{Array}  // 必须，各个顶角坐标

    }, opt.context);

    if (_context.smooth === true || _context.smooth === 'true') {
      _context.smooth = 0.5; //smooth 0-1
    }

    opt.context = _context;
    opt.type = "brokenline";
    return _super.call(this, opt);
  }

  _createClass(BrokenLine, [{
    key: "watch",
    value: function watch(name, value, preValue) {
      var names = ['pointList', 'smooth', 'lineType', 'smoothMonotone'];

      if (names.indexOf(name) > -1) {
        this.graphics.clear();
        this.draw(this.graphics);
      }
    }
  }, {
    key: "draw",
    value: function draw(graphics) {
      var pointList = this.context.pointList;
      this.drawGraphics(graphics, pointList, this.context.smooth, this.context.smoothMonotone);
      return this;
    }
    /**
     * 绘制非单调的平滑线
     */

  }, {
    key: "drawGraphics",
    value: function drawGraphics(ctx) {
      var points = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var smooth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
      var smoothMonotone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'x' | 'y' | 'none';
      var start = 0;
      var dir = 1;
      var segLen = points.length;
      var prevX;
      var prevY;
      var cpx0;
      var cpy0;
      var cpx1;
      var cpy1;
      var idx = start;
      var beginPath = false;
      var k = 0;

      for (; k < segLen; k++) {
        var point = points[idx];

        if (!myMath.isValibPoint(point)) {
          //如果发现是空点，那么就跳过，同时吧 beginPath 设置为false，代表一个path已经结束
          idx += dir;
          beginPath = false;
          continue;
        }

        var x = point[0];
        var y = point[1];

        if (!beginPath) {
          ctx.moveTo(x, y);
          cpx0 = x;
          cpy0 = y;
        } else {
          var dx = x - prevX;
          var dy = y - prevY; //忽略太过微小的片段

          if (dx * dx + dy * dy < 0.5) {
            idx += dir;
            continue;
          }

          if (smooth > 0) {
            var nextIdx = idx + dir;
            var nextPoint = points[nextIdx];
            var nextX = nextPoint ? nextPoint[0] : null;
            var nextY = nextPoint ? nextPoint[1] : null; //忽略重复的点

            while (nextX === x && nextY === y && k < segLen) {
              k++;
              nextIdx += dir;
              idx += dir;
              nextPoint = points[nextIdx];
              nextX = nextPoint ? nextPoint[0] : null;
              nextY = nextPoint ? nextPoint[1] : null;
              x = points[idx][0];
              y = points[idx][1];
              dx = x - prevX;
              dy = y - prevY;
            }

            var tmpK = k + 1;
            var ratioNextSeg = 0.5;
            var vx = 0;
            var vy = 0;
            var nextCpx0 = void 0;
            var nextCpy0 = void 0; // 最后一个点

            if (tmpK >= segLen || !myMath.isValibPoint({
              x: nextX,
              y: nextY
            })) {
              cpx1 = x;
              cpy1 = y;
            } else {
              vx = nextX - prevX;
              vy = nextY - prevY;
              var dx0 = x - prevX;
              var dx1 = nextX - x;
              var dy0 = y - prevY;
              var dy1 = nextY - y;
              var lenPrevSeg = void 0;
              var lenNextSeg = void 0;

              if (smoothMonotone === 'x') {
                lenPrevSeg = Math.abs(dx0);
                lenNextSeg = Math.abs(dx1);

                var _dir = vx > 0 ? 1 : -1;

                cpx1 = x - _dir * lenPrevSeg * smooth;
                cpy1 = y;
                nextCpx0 = x + _dir * lenNextSeg * smooth;
                nextCpy0 = y;
              } else if (smoothMonotone === 'y') {
                lenPrevSeg = Math.abs(dy0);
                lenNextSeg = Math.abs(dy1);

                var _dir2 = vy > 0 ? 1 : -1;

                cpx1 = x;
                cpy1 = y - _dir2 * lenPrevSeg * smooth;
                nextCpx0 = x;
                nextCpy0 = y + _dir2 * lenNextSeg * smooth;
              } else {
                lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
                lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1); // seg长度的使用比例

                ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
                cpx1 = x - vx * smooth * (1 - ratioNextSeg);
                cpy1 = y - vy * smooth * (1 - ratioNextSeg); // 下一段的cp0

                nextCpx0 = x + vx * smooth * ratioNextSeg;
                nextCpy0 = y + vy * smooth * ratioNextSeg; // 点和下一个点之间的平滑约束。
                // 平滑后避免过度极端。

                nextCpx0 = mathMin(nextCpx0, mathMax(nextX, x));
                nextCpy0 = mathMin(nextCpy0, mathMax(nextY, y));
                nextCpx0 = mathMax(nextCpx0, mathMin(nextX, x));
                nextCpy0 = mathMax(nextCpy0, mathMin(nextY, y)); // 根据下一段调整后的 cp0 重新回收 cp1。

                vx = nextCpx0 - x;
                vy = nextCpy0 - y;
                cpx1 = x - vx * lenPrevSeg / lenNextSeg;
                cpy1 = y - vy * lenPrevSeg / lenNextSeg; // 点和上一个点之间的平滑约束。
                // 平滑后避免过度极端。

                cpx1 = mathMin(cpx1, mathMax(prevX, x));
                cpy1 = mathMin(cpy1, mathMax(prevY, y));
                cpx1 = mathMax(cpx1, mathMin(prevX, x));
                cpy1 = mathMax(cpy1, mathMin(prevY, y)); //再次調整下一個cp0。

                vx = x - cpx1;
                vy = y - cpy1;
                nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;
                nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;
              }
            }

            ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);
            cpx0 = nextCpx0;
            cpy0 = nextCpy0;
          } else {
            ctx.lineTo(x, y);
          }
        }

        prevX = x;
        prevY = y;
        idx += dir;
        beginPath = true;
      }

      return k;
    }
  }]);

  return BrokenLine;
}(Shape);

function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Circle$1 = /*#__PURE__*/function (_Shape) {
  _inherits(Circle, _Shape);

  var _super = _createSuper$b(Circle);

  function Circle(opt) {
    _classCallCheck(this, Circle);

    opt = _.extend(true, {
      type: "circle",
      xyToInt: false,
      context: {
        r: 0
      }
    }, Utils.checkOpt(opt));
    return _super.call(this, opt);
  }

  _createClass(Circle, [{
    key: "watch",
    value: function watch(name, value, preValue) {
      if (name == "r") {
        this.graphics.clear();
        this.draw(this.graphics);
      }
    }
  }, {
    key: "draw",
    value: function draw(graphics) {
      var r = this.context.$model.r;

      if (r < 0) {
        r = 0;
      }
      graphics.drawCircle(0, 0, r);
    }
  }]);

  return Circle;
}(Shape);

function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Path = /*#__PURE__*/function (_Shape) {
  _inherits(Path, _Shape);

  var _super = _createSuper$c(Path);

  function Path(opt) {
    _classCallCheck(this, Path);

    var _context = _.extend(true, {
      pointList: [],
      //从下面的path中计算得到的边界点的集合
      path: "" //字符串 必须，路径。例如:M 0 0 L 0 10 L 10 10 Z (一个三角形)
      //M = moveto
      //L = lineto
      //H = horizontal lineto
      //V = vertical lineto
      //C = curveto
      //S = smooth curveto
      //Q = quadratic Belzier curve
      //T = smooth quadratic Belzier curveto
      //Z = closepath

    }, opt.context);

    opt.context = _context;
    opt.__parsePathData = null;
    opt.type = "path";
    return _super.call(this, opt);
  }

  _createClass(Path, [{
    key: "watch",
    value: function watch(name, value, preValue) {
      if (name == "path") {
        //如果path有变动，需要自动计算新的pointList
        this.graphics.clear();
        this.draw(this.graphics);
      }
    }
  }, {
    key: "_parsePathData",
    value: function _parsePathData(data) {
      if (this.__parsePathData) {
        return this.__parsePathData;
      }

      if (!data) {
        return [];
      }

      this.__parsePathData = [];

      var paths = _.compact(data.replace(/[Mm]/g, "\\r$&").split('\\r'));

      var me = this;

      _.each(paths, function (pathStr) {
        me.__parsePathData.push(me._parseChildPathData(pathStr));
      });

      return this.__parsePathData;
    }
  }, {
    key: "_parseChildPathData",
    value: function _parseChildPathData(data) {
      // command string
      var cs = data; // command chars

      var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
      cs = cs.replace(/  /g, ' ');
      cs = cs.replace(/ /g, ','); //cs = cs.replace(/(.)-/g, "$1,-");

      cs = cs.replace(/(\d)-/g, '$1,-');
      cs = cs.replace(/,,/g, ',');
      var n; // create pipes so that we can split the data

      for (n = 0; n < cc.length; n++) {
        cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
      } // create array


      var arr = cs.split('|');
      var ca = []; // init context point

      var cpx = 0;
      var cpy = 0;

      for (n = 1; n < arr.length; n++) {
        var str = arr[n];
        var c = str.charAt(0);
        str = str.slice(1);
        str = str.replace(new RegExp('e,-', 'g'), 'e-'); //有的时候，比如“22，-22” 数据可能会经常的被写成22-22，那么需要手动修改
        //str = str.replace(new RegExp('-', 'g'), ',-');
        //str = str.replace(/(.)-/g, "$1,-")

        var p = str.split(',');

        if (p.length > 0 && p[0] === '') {
          p.shift();
        }

        for (var i = 0; i < p.length; i++) {
          p[i] = parseFloat(p[i]);
        }

        while (p.length > 0) {
          if (isNaN(p[0])) {
            break;
          }

          var cmd = null;
          var points = [];
          var ctlPtx;
          var ctlPty;
          var prevCmd;
          var rx;
          var ry;
          var psi;
          var fa;
          var fs;
          var x1 = cpx;
          var y1 = cpy; // convert l, H, h, V, and v to L

          switch (c) {
            case 'l':
              cpx += p.shift();
              cpy += p.shift();
              cmd = 'L';
              points.push(cpx, cpy);
              break;

            case 'L':
              cpx = p.shift();
              cpy = p.shift();
              points.push(cpx, cpy);
              break;

            case 'm':
              cpx += p.shift();
              cpy += p.shift();
              cmd = 'M';
              points.push(cpx, cpy);
              c = 'l';
              break;

            case 'M':
              cpx = p.shift();
              cpy = p.shift();
              cmd = 'M';
              points.push(cpx, cpy);
              c = 'L';
              break;

            case 'h':
              cpx += p.shift();
              cmd = 'L';
              points.push(cpx, cpy);
              break;

            case 'H':
              cpx = p.shift();
              cmd = 'L';
              points.push(cpx, cpy);
              break;

            case 'v':
              cpy += p.shift();
              cmd = 'L';
              points.push(cpx, cpy);
              break;

            case 'V':
              cpy = p.shift();
              cmd = 'L';
              points.push(cpx, cpy);
              break;

            case 'C':
              points.push(p.shift(), p.shift(), p.shift(), p.shift());
              cpx = p.shift();
              cpy = p.shift();
              points.push(cpx, cpy);
              break;

            case 'c':
              points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
              cpx += p.shift();
              cpy += p.shift();
              cmd = 'C';
              points.push(cpx, cpy);
              break;

            case 'S':
              ctlPtx = cpx;
              ctlPty = cpy;
              prevCmd = ca[ca.length - 1];

              if (prevCmd.command === 'C') {
                ctlPtx = cpx + (cpx - prevCmd.points[2]);
                ctlPty = cpy + (cpy - prevCmd.points[3]);
              }

              points.push(ctlPtx, ctlPty, p.shift(), p.shift());
              cpx = p.shift();
              cpy = p.shift();
              cmd = 'C';
              points.push(cpx, cpy);
              break;

            case 's':
              ctlPtx = cpx, ctlPty = cpy;
              prevCmd = ca[ca.length - 1];

              if (prevCmd.command === 'C') {
                ctlPtx = cpx + (cpx - prevCmd.points[2]);
                ctlPty = cpy + (cpy - prevCmd.points[3]);
              }

              points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
              cpx += p.shift();
              cpy += p.shift();
              cmd = 'C';
              points.push(cpx, cpy);
              break;

            case 'Q':
              points.push(p.shift(), p.shift());
              cpx = p.shift();
              cpy = p.shift();
              points.push(cpx, cpy);
              break;

            case 'q':
              points.push(cpx + p.shift(), cpy + p.shift());
              cpx += p.shift();
              cpy += p.shift();
              cmd = 'Q';
              points.push(cpx, cpy);
              break;

            case 'T':
              ctlPtx = cpx, ctlPty = cpy;
              prevCmd = ca[ca.length - 1];

              if (prevCmd.command === 'Q') {
                ctlPtx = cpx + (cpx - prevCmd.points[0]);
                ctlPty = cpy + (cpy - prevCmd.points[1]);
              }

              cpx = p.shift();
              cpy = p.shift();
              cmd = 'Q';
              points.push(ctlPtx, ctlPty, cpx, cpy);
              break;

            case 't':
              ctlPtx = cpx, ctlPty = cpy;
              prevCmd = ca[ca.length - 1];

              if (prevCmd.command === 'Q') {
                ctlPtx = cpx + (cpx - prevCmd.points[0]);
                ctlPty = cpy + (cpy - prevCmd.points[1]);
              }

              cpx += p.shift();
              cpy += p.shift();
              cmd = 'Q';
              points.push(ctlPtx, ctlPty, cpx, cpy);
              break;

            case 'A':
              rx = p.shift(); //x半径

              ry = p.shift(); //y半径

              psi = p.shift(); //旋转角度

              fa = p.shift(); //角度大小 

              fs = p.shift(); //时针方向

              x1 = cpx, y1 = cpy;
              cpx = p.shift(), cpy = p.shift();
              cmd = 'A';
              points = [rx, ry, psi, fa, fs, cpx, cpy, x1, y1];
              break;

            case 'a':
              rx = p.shift();
              ry = p.shift();
              psi = p.shift();
              fa = p.shift();
              fs = p.shift();
              x1 = cpx, y1 = cpy;
              cpx += p.shift();
              cpy += p.shift();
              cmd = 'A';
              points = [rx, ry, psi, fa, fs, cpx, cpy, x1, y1];
              break;
          }

          ca.push({
            command: cmd || c,
            points: points
          });
        }

        if (c === 'z' || c === 'Z') {
          ca.push({
            command: 'z',
            points: []
          });
        }
      }
      return ca;
    } //重新根的path绘制 graphics

  }, {
    key: "draw",
    value: function draw(graphics) {
      //graphics.beginPath();
      this.__parsePathData = null;
      this.context.$model.pointList = [];

      var pathArray = this._parsePathData(this.context.$model.path);

      for (var g = 0, gl = pathArray.length; g < gl; g++) {
        for (var i = 0, l = pathArray[g].length; i < l; i++) {
          var c = pathArray[g][i].command,
              p = pathArray[g][i].points;

          switch (c) {
            case 'L':
              graphics.lineTo(p[0], p[1]);
              break;

            case 'M':
              graphics.moveTo(p[0], p[1]);
              break;

            case 'C':
              graphics.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
              break;

            case 'Q':
              graphics.quadraticCurveTo(p[0], p[1], p[2], p[3]);
              break;

            case 'A':
              //前面6个元素用来放path的A 6个参数，path A命令详见
              Arc.drawArc(graphics, p[7], p[8], p);
              break;

            case 'z':
              graphics.closePath();
              break;
          }
        }
      }
      return this;
    }
  }]);

  return Path;
}(Shape);

function _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Droplet = /*#__PURE__*/function (_Path) {
  _inherits(Droplet, _Path);

  var _super = _createSuper$d(Droplet);

  function Droplet(opt) {
    var _this;

    _classCallCheck(this, Droplet);

    opt = _.extend(true, {
      type: "droplet",
      context: {
        hr: 0,
        //{number},  // 必须，水滴横宽（中心到水平边缘最宽处距离）
        vr: 0 //{number},  // 必须，水滴纵高（中心到尖端距离）

      }
    }, Utils.checkOpt(opt));

    var my = _this = _super.call(this, opt);

    _this.context.$model.path = _this.createPath();
    return _this;
  }

  _createClass(Droplet, [{
    key: "watch",
    value: function watch(name, value, preValue) {
      if (name == "hr" || name == "vr") {
        this.context.$model.path = this.createPath();
      }
    }
  }, {
    key: "createPath",
    value: function createPath() {
      var model = this.context.$model;
      var ps = "M 0 " + model.hr + " C " + model.hr + " " + model.hr + " " + model.hr * 3 / 2 + " " + -model.hr / 3 + " 0 " + -model.vr;
      ps += " C " + -model.hr * 3 / 2 + " " + -model.hr / 3 + " " + -model.hr + " " + model.hr + " 0 " + model.hr + "z";
      return ps;
    }
  }]);

  return Droplet;
}(Path);

function _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Ellipse$1 = /*#__PURE__*/function (_Shape) {
  _inherits(Ellipse, _Shape);

  var _super = _createSuper$e(Ellipse);

  function Ellipse(opt) {
    _classCallCheck(this, Ellipse);

    opt = _.extend(true, {
      type: "ellipse",
      context: {
        hr: 0,
        //{number},  // 必须，水滴横宽（中心到水平边缘最宽处距离）
        vr: 0 //{number},  // 必须，水滴纵高（中心到尖端距离）

      }
    }, Utils.checkOpt(opt));
    return _super.call(this, opt);
  }

  _createClass(Ellipse, [{
    key: "watch",
    value: function watch(name, value, preValue) {
      if (name == "hr" || name == "vr") {
        this.graphics.clear();
        this.draw(this.graphics);
      }
    }
  }, {
    key: "draw",
    value: function draw(graphics) {
      graphics.drawEllipse(0, 0, this.context.$model.hr * 2, this.context.$model.vr * 2);
    }
  }]);

  return Ellipse;
}(Shape);

function _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Polygon$1 = /*#__PURE__*/function (_Shape) {
  _inherits(Polygon, _Shape);

  var _super = _createSuper$f(Polygon);

  function Polygon(opt) {
    _classCallCheck(this, Polygon);

    var _context = _.extend(true, {
      lineType: null,
      smooth: false,
      pointList: [],
      //{Array}  // 必须，各个顶角坐标
      smoothFilter: Utils.__emptyFunc
    }, opt.context);

    if (!opt.isClone) {
      var start = _context.pointList[0];

      var end = _context.pointList.slice(-1)[0];

      if (_context.smooth) {
        _context.pointList.unshift(end);

        _context.pointList = myMath.getSmoothPointList(_context.pointList);
      }
    }
    opt.context = _context;
    opt.type = "polygon";
    return _super.call(this, opt);
  }

  _createClass(Polygon, [{
    key: "watch",
    value: function watch(name, value, preValue) {
      //调用parent的setGraphics
      if (name == "pointList" || name == "smooth" || name == "lineType") {
        this.graphics.clear();
        this.draw(this.graphics);
      }
    }
  }, {
    key: "draw",
    value: function draw(graphics) {
      //graphics.beginPath();
      var context = this.context;
      var pointList = context.pointList;

      if (pointList.length < 2) {
        //少于2个点就不画了~
        return;
      }
      graphics.moveTo(pointList[0][0], pointList[0][1]);

      for (var i = 1, l = pointList.length; i < l; i++) {
        graphics.lineTo(pointList[i][0], pointList[i][1]);
      }
      graphics.closePath();
      return;
    }
  }]);

  return Polygon;
}(Shape);

function _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$g() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Isogon = /*#__PURE__*/function (_Polygon) {
  _inherits(Isogon, _Polygon);

  var _super = _createSuper$g(Isogon);

  function Isogon(opt) {
    _classCallCheck(this, Isogon);

    var _context = _.extend(true, {
      pointList: [],
      //从下面的r和n计算得到的边界值的集合
      r: 0,
      //{number},  // 必须，正n边形外接圆半径
      n: 0 //{number},  // 必须，指明正几边形

    }, opt.context);

    _context.pointList = myMath.getIsgonPointList(_context.n, _context.r);
    opt.context = _context;
    opt.type = "isogon";
    return _super.call(this, opt);
  }

  _createClass(Isogon, [{
    key: "watch",
    value: function watch(name, value, preValue) {
      if (name == "r" || name == "n") {
        //如果path有变动，需要自动计算新的pointList
        this.context.$model.pointList = myMath.getIsgonPointList(this.context.$model.n, this.context.$model.r);
      }

      if (name == "pointList" || name == "smooth" || name == "lineType") {
        this.graphics.clear();
      }
    }
  }]);

  return Isogon;
}(Polygon$1);

function _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$h() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Line = /*#__PURE__*/function (_Shape) {
  _inherits(Line, _Shape);

  var _super = _createSuper$h(Line);

  function Line(opt) {
    _classCallCheck(this, Line);

    var _context = _.extend(true, {
      start: {
        x: 0,
        // 必须，起点横坐标
        y: 0 // 必须，起点纵坐标

      },
      end: {
        x: 0,
        // 必须，终点横坐标
        y: 0 // 必须，终点纵坐标

      }
    }, opt.context);

    opt.context = _context;
    opt.type = "line";
    return _super.call(this, opt);
  }

  _createClass(Line, [{
    key: "watch",
    value: function watch(name, value, preValue) {
      //并不清楚是start.x 还是end.x， 当然，这并不重要
      if (name == "x" || name == "y") {
        this.graphics.clear();
        this.draw(this.graphics);
      }
    }
  }, {
    key: "draw",
    value: function draw(graphics) {
      var model = this.context.$model;
      graphics.moveTo(model.start.x, model.start.y);
      graphics.lineTo(model.end.x, model.end.y);
      return this;
    }
  }]);

  return Line;
}(Shape);

function _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$i(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$i() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Rect = /*#__PURE__*/function (_Shape) {
  _inherits(Rect, _Shape);

  var _super = _createSuper$i(Rect);

  function Rect(opt) {
    _classCallCheck(this, Rect);

    var _context = _.extend(true, {
      width: 0,
      height: 0,
      radius: []
    }, opt.context);

    opt.context = _context;
    opt.type = "rect";
    return _super.call(this, opt);
  }

  _createClass(Rect, [{
    key: "watch",
    value: function watch(name, value, preValue) {
      if (name == "width" || name == "height" || name == "radius") {
        this.graphics.clear();
        this.draw(this.graphics);
      }
    }
    /**
     * 绘制圆角矩形
     */

  }, {
    key: "_buildRadiusPath",
    value: function _buildRadiusPath(graphics) {
      var model = this.context.$model; //左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
      //r缩写为1         相当于 [1, 1, 1, 1]
      //r缩写为[1]       相当于 [1, 1, 1, 1]
      //r缩写为[1, 2]    相当于 [1, 2, 1, 2]
      //r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]

      var x = 0;
      var y = 0;
      var width = model.width;
      var height = model.height;
      var r = Utils.getCssOrderArr(model.radius);
      var G = graphics;
      var sy = 1;

      if (height >= 0) {
        sy = -1;
      }

      G.moveTo(parseInt(x + r[0]), parseInt(height));
      G.lineTo(parseInt(x + width - r[1]), parseInt(height));
      r[1] !== 0 && G.quadraticCurveTo(x + width, height, parseInt(x + width), parseInt(height + r[1] * sy));
      G.lineTo(parseInt(x + width), parseInt(y - r[2] * sy));
      r[2] !== 0 && G.quadraticCurveTo(x + width, y, parseInt(x + width - r[2]), parseInt(y));
      G.lineTo(parseInt(x + r[3]), parseInt(y));
      r[3] !== 0 && G.quadraticCurveTo(x, y, parseInt(x), parseInt(y - r[3] * sy));
      G.lineTo(parseInt(x), parseInt(y + height + r[0] * sy));
      r[0] !== 0 && G.quadraticCurveTo(x, y + height, parseInt(x + r[0]), parseInt(y + height));
    }
  }, {
    key: "draw",
    value: function draw(graphics) {
      var model = this.context.$model;

      if (!model.radius.length) {
        graphics.drawRect(0, 0, model.width, model.height);
      } else {
        this._buildRadiusPath(graphics);
      }

      graphics.closePath();
      return;
    }
  }]);

  return Rect;
}(Shape);

function _createSuper$j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$j() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Sector = /*#__PURE__*/function (_Shape) {
  _inherits(Sector, _Shape);

  var _super = _createSuper$j(Sector);

  function Sector(opt) {
    _classCallCheck(this, Sector);

    var _context = _.extend(true, {
      pointList: [],
      //边界点的集合,私有，从下面的属性计算的来
      r0: 0,
      // 默认为0，内圆半径指定后将出现内弧，同时扇边长度 = r - r0
      r: 0,
      //{number},  // 必须，外圆半径
      startAngle: 0,
      //{number},  // 必须，起始角度[0, 360)
      endAngle: 0,
      //{number},  // 必须，结束角度(0, 360]
      clockwise: false //是否顺时针，默认为false(顺时针)

    }, opt.context);

    opt.context = _context;
    opt.regAngle = [];
    opt.isRing = false; //是否为一个圆环

    opt.type = "sector";
    return _super.call(this, opt);
  }

  _createClass(Sector, [{
    key: "watch",
    value: function watch(name, value, preValue) {
      if (name == "r0" || name == "r" || name == "startAngle" || name == "endAngle" || name == "clockwise") {
        //因为这里的graphs不一样。
        this.isRing = false; //是否为一个圆环，这里也要开始初始化一下

        this.graphics.clear();
        this.draw(this.graphics);
      }
    }
  }, {
    key: "draw",
    value: function draw(graphics) {
      var model = this.context.$model; // 形内半径[0,r)

      var r0 = typeof model.r0 == 'undefined' ? 0 : model.r0;
      var r = model.r; // 扇形外半径(0,r]

      var startAngle = myMath.degreeTo360(model.startAngle); // 起始角度[0,360)

      var endAngle = myMath.degreeTo360(model.endAngle); // 结束角度(0,360]

      if (model.startAngle != model.endAngle && Math.abs(model.startAngle - model.endAngle) % 360 == 0) {
        //if( startAngle == endAngle && model.startAngle != model.endAngle ) {
        //如果两个角度相等，那么就认为是个圆环了
        this.isRing = true;
        startAngle = 0;
        endAngle = 360;
      }

      startAngle = myMath.degreeToRadian(startAngle);
      endAngle = myMath.degreeToRadian(endAngle); //处理下极小夹角的情况
      //if( endAngle - startAngle < 0.025 ){
      //    startAngle -= 0.003
      //}

      var G = graphics; //G.beginPath();

      if (this.isRing) {
        if (model.r0 == 0) {
          //圆
          G.drawCircle(0, 0, model.r);
        } else {
          //圆环
          if (model.fillStyle && model.fillAlpha) {
            G.beginPath();
            G.arc(0, 0, r, startAngle, endAngle, model.clockwise);

            if (model.r0 == 0) {
              G.lineTo(0, 0);
            } else {
              G.arc(0, 0, r0, endAngle, startAngle, !model.clockwise);
            }

            G.closePath();
            G.currentPath.lineWidth = 0;
            G.currentPath.strokeStyle = null;
            G.currentPath.strokeAlpha = 0;
            G.currentPath.line = false;
          }

          if (model.lineWidth && model.strokeStyle && model.strokeAlpha) {
            G.beginPath();
            G.arc(0, 0, r, startAngle, endAngle, model.clockwise);
            G.closePath();
            G.currentPath.fillStyle = null;
            G.currentPath.fill = false;
            G.beginPath();
            G.arc(0, 0, r0, endAngle, startAngle, !model.clockwise);
            G.closePath();
            G.currentPath.fillStyle = null;
            G.currentPath.fill = false;
          }
        }
      } else {
        //正常的扇形状
        G.beginPath();
        G.arc(0, 0, r, startAngle, endAngle, model.clockwise);

        if (model.r0 == 0) {
          G.lineTo(0, 0);
        } else {
          G.arc(0, 0, r0, endAngle, startAngle, !model.clockwise);
        }

        G.closePath();
      } //G.closePath();

    }
  }]);

  return Sector;
}(Shape);

function _createSuper$k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$k(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$k() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Arrow = /*#__PURE__*/function (_Shape) {
  _inherits(Arrow, _Shape);

  var _super = _createSuper$k(Arrow);

  function Arrow(opt) {
    _classCallCheck(this, Arrow);

    var _context = _.extend(true, {
      control: {
        x: 0,
        // 必须，起点横坐标
        y: 0 // 必须，起点纵坐标

      },
      point: {
        x: 0,
        // 必须，终点横坐标
        y: 0 // 必须，终点纵坐标

      },
      angle: null,
      // control的存在，也就是为了计算出来这个angle
      theta: 30,
      // 箭头夹角
      headlen: 6,
      // 斜边长度
      lineWidth: 1,
      strokeStyle: '#666',
      fillStyle: null
    }, opt.context);

    opt.context = _context;
    opt.type = "arrow";
    return _super.call(this, opt);
  }

  _createClass(Arrow, [{
    key: "watch",
    value: function watch(name, value, preValue) {
      //并不清楚是start.x 还是end.x， 当然，这并不重要
      if (name == "x" || name == "y" || name == "theta" || name == "headlen" || name == "angle") {
        this.graphics.clear();
      }
    }
  }, {
    key: "draw",
    value: function draw(graphics) {
      var model = this.context.$model;
      var fromX = model.control.x;
      var fromY = model.control.y;
      var toX = model.point.x;
      var toY = model.point.y; // 计算各角度和对应的P2,P3坐标 

      var angle = model.angle != null ? model.angle - 180 : Math.atan2(fromY - toY, fromX - toX) * 180 / Math.PI,
          angle1 = (angle + model.theta) * Math.PI / 180,
          angle2 = (angle - model.theta) * Math.PI / 180,
          topX = model.headlen * Math.cos(angle1),
          topY = model.headlen * Math.sin(angle1),
          botX = model.headlen * Math.cos(angle2),
          botY = model.headlen * Math.sin(angle2);
      var arrowX = toX + topX;
      var arrowY = toY + topY;
      graphics.moveTo(arrowX, arrowY);
      graphics.lineTo(toX, toY);
      graphics.lineTo(toX + botX, toY + botY);

      if (model.fillStyle) {
        graphics.lineTo(arrowX, arrowY);
        graphics.closePath();
      }
      return this;
    }
  }]);

  return Arrow;
}(Shape);

function _createSuper$l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$l(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$l() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Diamond = /*#__PURE__*/function (_Shape) {
  _inherits(Diamond, _Shape);

  var _super = _createSuper$l(Diamond);

  function Diamond(opt) {
    _classCallCheck(this, Diamond);

    var _context = _.extend(true, {
      innerRect: {
        //菱形的内接矩形
        width: 0,
        height: 0
      },
      includedAngle: 60 //菱形x方向的夹角

    }, opt.context);

    opt.context = _context;
    opt.type = "diamond";
    return _super.call(this, opt);
  }

  _createClass(Diamond, [{
    key: "watch",
    value: function watch(name, value, preValue) {
      //并不清楚是start.x 还是end.x， 当然，这并不重要
      if (['includedAngle'].indexOf(name) > -1) {
        this.graphics.clear();
        this.draw(this.graphics);
      }
    }
  }, {
    key: "draw",
    value: function draw(graphics) {
      var model = this.context.$model;
      var innerRect = model.innerRect;
      var includedAngle = model.includedAngle / 2;
      var includeRad = includedAngle * Math.PI / 180;
      var newWidthDiff = innerRect.height / Math.tan(includeRad);
      var newHeightDiff = innerRect.width * Math.tan(includeRad); //在内接矩形基础上扩展出来的外界矩形

      var newWidth = innerRect.width + newWidthDiff;
      var newHeight = innerRect.height + newHeightDiff;
      graphics.moveTo(0, newHeight / 2);
      graphics.lineTo(newWidth / 2, 0);
      graphics.lineTo(0, -newHeight / 2);
      graphics.lineTo(-newWidth / 2, 0);
      graphics.lineTo(0, newHeight / 2);
      graphics.closePath();
      return this;
    }
  }]);

  return Diamond;
}(Shape);

var Canvax = {
  version: "2.0.86",
  _: _,
  $: $,
  event: event,
  //这三个共享给 chartx用
  App: Application
};
Canvax.Display = {
  DisplayObject: DisplayObject,
  DisplayObjectContainer: DisplayObjectContainer,
  Stage: Stage,
  Sprite: Sprite,
  Shape: Shape,
  Point: Point,
  Text: Text
};
Canvax.Shapes = {
  BrokenLine: BrokenLine,
  //BrokenLineOld: BrokenLineOld,
  Circle: Circle$1,
  Droplet: Droplet,
  Ellipse: Ellipse$1,
  Isogon: Isogon,
  Line: Line,
  Path: Path,
  Polygon: Polygon$1,
  Rect: Rect,
  Sector: Sector,
  Arrow: Arrow,
  Diamond: Diamond
};
Canvax.AnimationFrame = AnimationFrame;
Canvax.utils = Utils;

var parse = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;



var _default = {
  _eval: function _eval(code, target, paramName, paramValue) {
    return paramName ? new Function(paramName, code + "; return ".concat(target, ";"))(paramValue) : new Function(code + "; return ".concat(target, ";"))();
  },
  parse: function parse(code, range, data, variablesFromComponent) {
    try {
      var isVariablesDefined = range && range.length && range.length === 2 && range[1] > range[0]; // 若未定义

      if (!isVariablesDefined) {
        return this._eval(code, 'options');
      }

      var variablesInCode = this._eval(code, 'variables');

      if (typeof variablesInCode === 'function') {
        variablesInCode = variablesInCode(data) || {};
      }

      var variables = {};

      if (variablesFromComponent !== undefined) {
        variables = typeof variablesFromComponent === 'function' ? variablesFromComponent(data) : variablesFromComponent;
      }

      variables = Canvax._.extend(true, {}, variablesInCode, variables);
      var codeWithoutVariables = code.slice(0, range[0]) + code.slice(range[1]);
      return this._eval(codeWithoutVariables, 'options', 'variables', variables);
    } catch (e) {
      return {};
    }
  }
};
exports["default"] = _default;
});

unwrapExports(parse);

var setting = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = {
  //设备分辨率
  padding: 20
};
exports["default"] = _default;
});

unwrapExports(setting);

var global$1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _canvax = interopRequireDefault(Canvax);

var _parse = interopRequireDefault(parse);

var _setting = interopRequireDefault(setting);

//图表皮肤
var _ = _canvax["default"]._,
    $ = _canvax["default"].$,
    AnimationFrame = _canvax["default"].AnimationFrame;
var globalTheme = ["#ff8533", "#73ace6", "#82d982", "#e673ac", "#cd6bed", "#8282d9", "#c0e650", "#e6ac73", "#6bcded", "#73e6ac", "#ed6bcd", "#9966cc"];
var components = {
  /*
  modules:{
      coord : {
          empty : ..,
          rect  : ..,
          ...
      },
      graphs : {
          //empty : .., //一般只有coord才会有empty
          bar   : ..,
          ...
      }
  },
  get: function( name, type ){}
  */
};
var _default = {
  chartxVersion: '1.1.142',
  create: function create(el, data, opt) {
    var otherOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var chart = null;
    var me = this;

    var _destroy = function _destroy() {
      me.instances[chart.id] = null;
      delete me.instances[chart.id];
    }; //这个el如果之前有绘制过图表，那么就要在instances中找到图表实例，然后销毁
    //小程序版本中外面会带id过来


    var chart_id = el.id || $.query(el).getAttribute("chart_id");

    if (chart_id != undefined) {
      var _chart = me.instances[chart_id];

      if (_chart) {
        _chart.destroy();

        _chart.off && _chart.off("destroy", _destroy);
      }
      delete me.instances[chart_id];
    }

    var componentModules = me._getComponentModules(); //如果用户没有配置coord，说明这个图表是一个默认目标系的图表，比如标签云


    var Chart = me._getComponentModule('chart'); //try {


    chart = new Chart(el, data, this._optionsHandle(opt), componentModules, otherOptions);

    if (chart) {
      chart.draw();
      me.instances[chart.id] = chart;
      chart.on("destroy", _destroy);
    }
    //    throw "Chatx Error：" + err
    //};

    return chart;
  },
  setGlobalTheme: function setGlobalTheme(colors) {
    globalTheme = colors;
  },
  getGlobalTheme: function getGlobalTheme() {
    return globalTheme;
  },
  parse: _parse["default"],
  instances: {},
  getChart: function getChart(chartId) {
    return this.instances[chartId];
  },
  resize: function resize() {
    //调用全局的这个resize方法，会把当前所有的 chart instances 都执行一遍resize
    for (var c in this.instances) {
      this.instances[c].resize();
    }
  },
  //第二个参数是用户要用来覆盖chartpark中的配置的options
  getOptionsOld: function getOptionsOld(chartPark_cid) {
    var JsonSerialize = {
      prefix: '[[JSON_FUN_PREFIX_',
      suffix: '_JSON_FUN_SUFFIX]]'
    };

    var parse = function parse(string) {
      return JSON.parse(string, function (key, value) {
        if (typeof value === 'string' && value.indexOf(JsonSerialize.suffix) > 0 && value.indexOf(JsonSerialize.prefix) == 0) {
          return new Function('return ' + value.replace(JsonSerialize.prefix, '').replace(JsonSerialize.suffix, ''))();
        }
        return value;
      }) || {};
    };

    return parse(decodeURIComponent(this.options[chartPark_cid] || '%7B%7D'));
  },
  getOptionsNew: function getOptionsNew(chartPark_cid, data, variables) {
    var chartConfig = this.options[chartPark_cid];
    var code = decodeURIComponent(chartConfig.code);
    var range = chartConfig.range;
    return _parse["default"].parse(code, range, data, variables);
  },

  /** 
   * 获取图表配置并解析
   * 
   * @param {int} chartPark_cid  chartpark图表id
   * @param {Object} userOptions 用户自定义图表options，若无chartPark_cid时默认使用该配置，否则使用该配置覆盖原chartpark中的图表配置
   * @param {Array} data 绘制图表使用的数据
   * @param {Object | Function} variables 用于覆盖chartpark图表配置的变量，为Function时，其返回值必须为Object
   * @returns {Object} 正常情况返回图表配置，否则返回{}
  */
  getOptions: function getOptions(chartPark_cid, userOptions, data, variables) {
    if (!this.options[chartPark_cid]) {
      return userOptions || {};
    }
    var chartConfig = this.options[chartPark_cid];
    var optionsFromChartPark = typeof chartConfig === 'string' ? this.getOptionsOld(chartPark_cid) : this.getOptionsNew(chartPark_cid, data || [], variables || {});

    if (userOptions) {
      optionsFromChartPark = _.extend(true, optionsFromChartPark, userOptions);
    }
    return this._optionsHandle(optionsFromChartPark);
  },
  _optionsHandle: function _optionsHandle() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    //剔除掉所有 enabled为false的组件, 或者组件被设置为null的组件
    for (var k in options) {
      // if( k == 'coord' ){
      //     //坐标系组件不需要处理
      //     continue;
      // }
      var prop = options[k];

      if (!Array.isArray(prop)) {
        if (!prop) {
          // ( typeof prop == 'object' && 'enabled' in prop && !prop.enabled) ||
          delete options[k];
        }
      } else {
        for (var i = 0, l = prop.length; i < l; i++) {
          var comp = prop[i];

          if (!comp) {
            //(typeof comp == 'object' && 'enabled' in comp && !comp.enabled) || 
            prop.splice(i, 1);
            i--;
            l--;
          }
        }

        if (!prop.length) {
          delete options[k];
        }
      }
    }

    return options;
  },
  calculateOptions: function calculateOptions(chartPark_cid, data, variables) {
    return this.getOptions(chartPark_cid, undefined, data, variables);
  },
  _getComponentModules: function _getComponentModules() {
    var comps = components;

    if (!comps.modules) {
      comps.modules = {};
    }

    if (!comps.get) {
      comps.get = function (name, type) {
        if (!type) {
          type = "empty";
        }
        name = name.toLowerCase();
        type = type.toLowerCase();
        var _module = comps.modules[name];

        if (_module && _module[type]) {
          return _module[type];
        }
      };
    }
    return comps;
  },

  /**
   * @param {compModule} 要注册进去的模块名称
   * @param {name} 要获取的comp名称
   * @param {type} 模块子类型 graphs.bar
   */
  registerComponent: function registerComponent(compModule, name) {
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "empty";

    var comps = this._getComponentModules().modules;

    name = name.toLowerCase();
    type = type.toLowerCase();
    var _comp = comps[name];

    if (!_comp) {
      _comp = comps[name] = {};
    }

    if (!_comp[type]) {
      _comp[type] = compModule;
    }
    return comps;
  },

  /**
   * 
   * @param {name} 要获取的comp名称
   * @param { type } 后面可以传传两个参数 
   */
  _getComponentModule: function _getComponentModule(name) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'empty';
    name = name.toLowerCase();
    type = type.toLowerCase();

    var _comp = this._getComponentModules().modules[name];

    return _comp ? _comp[type] : undefined;
  },
  setAnimationEnabled: function setAnimationEnabled(bool) {
    return AnimationFrame.setAnimationEnabled(bool);
  },
  getAnimationEnabled: function getAnimationEnabled(bool) {
    return AnimationFrame.getAnimationEnabled();
  },
  //所有布局算法
  layout: {},
  registerLayout: function registerLayout(name, algorithm) {
    this.layout[name] = algorithm;
  },
  props: {},
  getProps: function getProps() {
    //计算全量的 props 属性用来提供智能提示 begin
    //这部分代码没必要部署到 打包的环境， 只是chartpark需要用来做智能提示， 自动化测试
    var allProps = {};

    var allModules = this._getComponentModules().modules;

    var _loop = function _loop(n) {
      if (n == 'chart') return "continue";
      allProps[n] = {
        detail: n,
        propertys: {} //typeMap: {}

      };

      var _graphNames = void 0;

      if (n == 'graphs') {
        _graphNames = _.map(allModules.graphs, function (val, key) {
          return key;
        });
        allProps.graphs.documentation = "可选的graphs类型有：\n" + _graphNames.join('\n');
      }
      var allConstructorProps = {}; //整个原型链路上面的 defaultProps

      var protoModule = null;

      for (var mn in allModules[n]) {
        if (protoModule) break;
        protoModule = allModules[n][mn].prototype;
      }

      function _setProps(m) {
        var constructorModule = m.constructor.__proto__; //m.constructor;

        if (!constructorModule._isComponentRoot) {
          _setProps(constructorModule.prototype);
        }

        if (constructorModule.defaultProps && _.isFunction(constructorModule.defaultProps)) {
          var _dprops = constructorModule.defaultProps();

          _.extend(allConstructorProps, _dprops);
        }
      }

      _setProps(protoModule);

      allProps[n].propertys = _.extend(allConstructorProps, allProps[n].propertys);

      var _loop2 = function _loop2(_mn) {
        var module = allModules[n][_mn];
        var moduleProps = module.defaultProps ? module.defaultProps() : {}; //处理props上面所有的 _props 依赖 begin

        function setChildProps(p) {
          if (p._props) {
            var _propsIsArray = _.isArray(p._props);

            for (var k in p._props) {
              if (!_propsIsArray) {
                p[k] = {
                  detail: k,
                  propertys: {}
                };
              }
              var _module = p._props[k];

              if (_module.defaultProps) {
                (function () {
                  var _setProps = function _setProps(m) {
                    if (m.__proto__.__proto__) {
                      _setProps(m.__proto__);
                    }

                    if (m.defaultProps && _.isFunction(m.defaultProps)) {
                      var _dprops = m.defaultProps();

                      if (_dprops._props) {
                        //如果子元素还有 _props 依赖， 那么就继续处理
                        setChildProps(_dprops);
                      }
                      _dprops && _.extend(allConstructorProps, _dprops);
                    }
                  };

                  var _moduleProps = _module.defaultProps(); //先把ta原型上面的所有属性都添加到 _moduleProps 


                  var allConstructorProps = {};

                  _setProps(_module.__proto__);

                  _moduleProps = _.extend(allConstructorProps, _moduleProps);

                  if (_propsIsArray) {
                    _.extend(p, _moduleProps);
                  } else {
                    p[k].propertys = _moduleProps;
                    setChildProps(p[k].propertys);
                  }
                })();
              }
            }
          }
        }
        setChildProps(moduleProps); //处理props上面所有的 _props 依赖 end
        //这里不能用下面的 extend 方法，

        moduleProps = _.extend({}, allConstructorProps, moduleProps); //如果原型上面是有type 属性的，那么说明，自己是type分类路由的一个分支，放到typeMap下面

        if (allConstructorProps.type) {
          if (!allProps[n].typeMap) allProps[n].typeMap = {};

          if (n == 'graphs') {
            moduleProps.type.values = _graphNames;
            moduleProps.type.documentation = "可选的graphs类型有：\n" + _graphNames.join('\n');
          }
          allProps[n].typeMap[_mn] = moduleProps;
        } else {
          _.extend(allProps[n].propertys, moduleProps);
        }
      };

      for (var _mn in allModules[n]) {
        _loop2(_mn);
      }
    };

    for (var n in allModules) {
      var _ret = _loop(n);

      if (_ret === "continue") continue;
    }
    this.props = allProps; //计算全量的 props 属性用来提供智能提示 begin

    return this.props;
  },
  setPadding: function setPadding(padding) {
    _setting["default"].padding = padding;
  },
  //兼容有的地方已经用了Chartx.Canvax
  canvax: _canvax["default"]
};
exports["default"] = _default;
});

unwrapExports(global$1);

var classCallCheck$1 = createCommonjsModule(function (module) {
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(classCallCheck$1);

var createClass$1 = createCommonjsModule(function (module) {
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(createClass$1);

var setPrototypeOf$1 = createCommonjsModule(function (module) {
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(setPrototypeOf$1);

var inherits$1 = createCommonjsModule(function (module) {
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf$1(subClass, superClass);
}

module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(inherits$1);

var _typeof_1$1 = createCommonjsModule(function (module) {
function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}

module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(_typeof_1$1);

var assertThisInitialized$1 = createCommonjsModule(function (module) {
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(assertThisInitialized$1);

var possibleConstructorReturn$1 = createCommonjsModule(function (module) {
var _typeof = _typeof_1$1["default"];



function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized$1(self);
}

module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(possibleConstructorReturn$1);

var getPrototypeOf$1 = createCommonjsModule(function (module) {
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(getPrototypeOf$1);

var dataFrame = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;



/**
* 把原始的数据
* field1 field2 field3
*   1      2      3
*   2      3      4
* 这样的数据格式转换为内部的
* [{field:'field1',index:0,data:[1,2]} ......]
* 这样的结构化数据格式。
*/
//如果应用传入的数据是[{name:name, sex:sex ...} , ...] 这样的数据，就自动转换为chartx需要的矩阵格式数据
function parse2MatrixData(list) {
  if (list === undefined || list === null) {
    list = [];
  }

  if (list.length > 0 && !Canvax._.isArray(list[0])) {
    var newArr = [];
    var fields = [];
    var fieldNum = 0;

    for (var i = 0, l = list.length; i < l; i++) {
      var row = list[i];

      if (i == 0) {
        for (var f in row) {
          fields.push(f);
        }
        newArr.push(fields);
        fieldNum = fields.length;
      }
      var _rowData = [];

      for (var ii = 0; ii < fieldNum; ii++) {
        _rowData.push(row[fields[ii]]);
      }
      newArr.push(_rowData);
    }
    return newArr;
  } else {
    return list;
  }
}

function parse2JsonData(list) {
  var newArr = list; //检测第一个数据是否为一个array, 否就是传入了一个json格式的数据

  if (list.length > 0 && Canvax._.isArray(list[0])) {
    newArr = [];
    var fields = list[0];
    var fl = fields.length;

    for (var i = 1, l = list.length; i < l; i++) {
      var obj = {};

      for (var fi = 0; fi < fl; fi++) {
        obj[fields[fi]] = list[i][fi];
      }
      newArr.push(obj);
    }
    return newArr;
  }
}

function _default(dataOrg, opt) {
  var dataFrame = {
    //数据框架集合
    length: 0,
    org: [],
    //最原始的数据，一定是个行列式，因为如果发现是json格式数据，会自动转换为行列式
    jsonOrg: [],
    //原始数据的json格式
    data: [],
    //最原始的数据转化后的数据格式(range取段过后的数据)：[o,o,o] o={field:'val1',index:0,data:[1,2,3]}
    getRowDataAt: _getRowDataAt,
    getRowDataOf: _getRowDataOf,
    getFieldData: _getFieldData,
    getDataOrg: getDataOrg,
    resetData: _resetData,
    fields: [],
    range: {
      start: 0,
      end: 0
    },
    filters: {} //数据过滤器，在range的基础上

  };

  function _init(dataOrg) {
    //数据的最外面一定是个数组
    if (!Array.isArray(dataOrg)) {
      dataOrg = [dataOrg];
    }

    if (!dataOrg || dataOrg.length == 0) {
      return dataFrame;
    }

    if (dataOrg.length > 0 && !Canvax._.isArray(dataOrg[0])) {
      dataFrame.jsonOrg = dataOrg;
      dataOrg = parse2MatrixData(dataOrg);
      dataFrame.org = dataOrg;
    } else {
      dataFrame.org = dataOrg;
      dataFrame.jsonOrg = parse2JsonData(dataOrg);
    }

    dataFrame.range.end = dataOrg.length - 1 - 1; //然后检查opts中是否有dataZoom.range

    if (opt) {
      //兼容下dataZoom 和 datazoom 的大小写配置
      var _datazoom = opt.dataZoom || opt.datazoom;

      _datazoom && _datazoom.range && Canvax._.extend(dataFrame.range, _datazoom.range);
    }

    if (dataOrg.length && dataOrg[0].length && !~dataOrg[0].indexOf("__index__")) {
      //如果数据中没有用户自己设置的__index__，那么就主动添加一个__index__，来记录元数据中的index
      for (var i = 0, l = dataOrg.length; i < l; i++) {
        if (!i) {
          dataOrg[0].push("__index__");
        } else {
          dataOrg[i].push(i - 1);
          dataFrame.jsonOrg[i - 1]["__index__"] = i - 1;
        }
      }
    }
    dataFrame.fields = dataOrg[0] ? dataOrg[0] : []; //所有的字段集合;

    return dataFrame;
  }

  function _resetData(dataOrg) {
    if (dataOrg) {
      //重置一些数据
      dataFrame.org = [];
      dataFrame.jsonOrg = [];
      dataFrame.fields = [];
      dataFrame.data = [];

      var preRange = Canvax._.extend(true, {}, dataFrame.range);

      var preLen = dataFrame.length; //设置数据之前的数据长度

      _init(dataOrg);

      dataFrame.data = _getDataAndSetDataLen(); //如果之前是有数据的情况，一些当前状态恢复到dataFrame里去 begin

      if (preLen !== 0) {
        if (opt && opt.dataZoom && opt.dataZoom.range) {
          //如果有配置过dataZoom.range， 那么就要回复最近一次的range
          Canvax._.extend(true, dataFrame.range, preRange);

          if (dataFrame.range.end > dataFrame.length - 1) {
            dataFrame.range.end = dataFrame.length - 1;
          }

          if (dataFrame.range.start > dataFrame.length - 1 || dataFrame.range.start > dataFrame.range.end) {
            dataFrame.range.start = 0;
          }
        } //一些当前状态恢复到dataFrame里去 end  

      }
    } else {
      //就算没有dataOrg，但是data还是要重新构建一边的，因为可能dataFrame上面的其他状态被外界改变了
      //比如datazoom修改了dataFrame.range
      dataFrame.data = _getDataAndSetDataLen();
    }
  }

  function _getDataAndSetDataLen() {
    var total = []; //已经处理成[o,o,o]   o={field:'val1',index:0,data:[1,2,3]}

    for (var a = 0, al = dataFrame.fields.length; a < al; a++) {
      var o = {};
      o.field = dataFrame.fields[a];
      o.index = a;
      o.data = [];
      total.push(o);
    }

    var rows = _getValidRows(function (rowData) {
      Canvax._.each(dataFrame.fields, function (_field) {
        var _val = rowData[_field];

        if (opt && opt.coord && (opt.coord.xAxis && _field == opt.coord.xAxis.field && opt.coord.xAxis.layoutType != 'proportion' || opt.coord.aAxis && _field == opt.coord.aAxis.field)) ; else {
          //其他数据都需要保证是number
          //如果是可以转换为number的数据就尽量转换为number
          if (!isNaN(_val) && _val !== "" && _val !== null) {
            _val = Number(_val);
          }
        }

        var gData = Canvax._.find(total, function (g) {
          return g.field == _field;
        });

        gData && gData.data.push(_val);
      });
    }); //到这里保证了data一定是行列式


    dataFrame.length = rows.length;
    return total;
  }

  function _getValidRows(callback) {
    var validRowDatas = [];

    Canvax._.each(dataFrame.jsonOrg.slice(dataFrame.range.start, dataFrame.range.end + 1), function (rowData) {
      var validRowData = true;

      if (Canvax._.keys(dataFrame.filters).length) {
        Canvax._.each(dataFrame.filters, function (filter) {
          if (Canvax._.isFunction(filter) && !filter(rowData)) {
            validRowData = false;
            return false;
          }
        });
      }

      if (validRowData) {
        callback && callback(rowData);
        validRowDatas.push(rowData);
      }
    });

    return validRowDatas;
  }

  function getDataOrg($field, format, totalList, lev) {
    if (!lev) lev = 0;

    var arr = totalList || _getDataAndSetDataLen();

    if (!arr) {
      return;
    }

    if (!format) {
      format = function format(e) {
        return e;
      };
    }

    function _format(d) {
      for (var i = 0, l = d.length; i < l; i++) {
        d[i] = format(d[i]);
      }
      return d;
    }

    if (!Canvax._.isArray($field)) {
      $field = [$field];
    }

    var newData = [];

    for (var i = 0, l = $field.length; i < l; i++) {

      if (Canvax._.isArray($field[i])) {
        newData.push(getDataOrg($field[i], format, totalList, lev + 1));
      } else {
        var _fieldData = newData;

        if (!lev) {
          _fieldData = [];
        }

        for (var ii = 0, iil = arr.length; ii < iil; ii++) {
          if ($field[i] == arr[ii].field) {

            _fieldData.push(_format(arr[ii].data));

            break;
          }
        }

        if (!lev) {
          newData.push(_fieldData);
        }
      }
    }

    return newData;
  }
  /*
   * 获取某一行数据,当前dataFrame.data中
  */

  function _getRowDataAt(index) {
    var o = {};
    var data = dataFrame.data;

    for (var a = 0; a < data.length; a++) {
      o[data[a].field] = data[a].data[index];
    }
    return o;
  }
  /**
   * obj => {uv: 100, pv: 10 ...}
   */


  function _getRowDataOf(obj) {
    !obj && (obj = {});
    var arr = [];
    var expCount = 0;

    for (var p in obj) {
      expCount++;
    }

    if (expCount) {
      var _loop = function _loop(i) {
        var matchNum = 0;

        Canvax._.each(dataFrame.data, function (fd) {
          if (fd.field in obj && fd.data[i] == obj[fd.field]) {
            matchNum++;
          }
        });

        if (matchNum == expCount) {
          //说明这条数据是完全和查询
          arr.push(_getRowDataAt(i));
        }
      };

      for (var i = dataFrame.range.start; i <= dataFrame.range.end; i++) {
        _loop(i);
      }
    }
    return arr;
  }

  function _getFieldData(field) {
    var list = [];

    var _f = Canvax._.find(dataFrame.data, function (obj) {
      return obj.field == field;
    });

    _f && (list = _f.data);
    return list;
  }

  _init(dataOrg);

  dataFrame.data = _getDataAndSetDataLen();
  return dataFrame;
}
});

unwrapExports(dataFrame);

var defineProperty$1 = createCommonjsModule(function (module) {
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(defineProperty$1);

var tools = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultProps = getDefaultProps;
exports.getDisMinATArr = getDisMinATArr;



//在一个数组中 返回比对$arr中的值离$n最近的值的索引
function getDisMinATArr($n, $arr) {
  var index = 0;
  var n = Math.abs($n - $arr[0]);

  for (var a = 1, al = $arr.length; a < al; a++) {
    if (n > Math.abs($n - $arr[a])) {
      n = Math.abs($n - $arr[a]);
      index = a;
    }
  }

  return index;
}

function getDefaultProps(dProps) {
  var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  for (var p in dProps) {
    if (!!p.indexOf("_")) {
      if (!dProps[p] || !dProps[p].propertys) {
        //如果这个属性没有子属性了，那么就说明这个已经是叶子节点了
        if (Canvax._.isObject(dProps[p]) && !Canvax._.isFunction(dProps[p]) && !Canvax._.isArray(dProps[p])) {
          target[p] = dProps[p]["default"];
        } else {
          target[p] = dProps[p];
        }
      } else {
        target[p] = {};
        getDefaultProps(dProps[p].propertys, target[p]);
      }
    }
  }

  return target;
}
});

unwrapExports(tools);
var tools_1 = tools.getDefaultProps;
var tools_2 = tools.getDisMinATArr;

var component = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _global = interopRequireDefault(global$1);

var _canvax = interopRequireDefault(Canvax);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var event = _canvax["default"].event,
    _ = _canvax["default"]._;

var Component = /*#__PURE__*/function (_event$Dispatcher) {
  (0, _inherits2["default"])(Component, _event$Dispatcher);

  var _super = _createSuper(Component);

  function Component(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, Component);
    _this = _super.call(this, opt, app);

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(Component.defaultProps()), opt);

    _this.name = "component"; //组件名称

    _this.type = null; //组件子类型，比如 Graphs组件下面的bar,line,scat等
    //this.enabled = false; //是否加载该组件

    _this._opt = opt;
    _this.app = app; //这个组件挂在哪个app上面（图表）

    _this.width = 0;
    _this.height = 0; //height 不包含margin

    _this.pos = {
      x: 0,
      y: 0
    };
    _this.margin = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
    _this.__cid = _canvax["default"].utils.createId("comp_");
    _this.ctx = app.stage.ctx || app.stage.canvas.getContext("2d");
    return _this;
  }

  (0, _createClass2["default"])(Component, [{
    key: "init",
    value: function init(opt, data) {}
  }, {
    key: "draw",
    value: function draw() {} //组件的销毁

  }, {
    key: "destroy",
    value: function destroy() {}
  }, {
    key: "reset",
    value: function reset() {} // resetData(){
    //     console.log( ( this.type || '' ) + '暂无resetData的实现' );
    // }

  }, {
    key: "setPosition",
    value: function setPosition(pos) {
      !pos && (pos = this.pos);
      pos.x && (this.sprite.context.x = pos.x);
      pos.y && (this.sprite.context.y = pos.y);
    }
  }, {
    key: "layout",
    value: function layout() {}
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        enabled: {
          detail: '是否开启该组件',
          "default": false
        }
      };
    }
  }, {
    key: "registerComponent",
    value: function registerComponent(compModule, name, type) {
      return _global["default"].registerComponent(compModule, name, type);
    }
  }, {
    key: "_isComponentRoot",
    value: function _isComponentRoot() {
      return true;
    } //global.getProps 中会用到

  }, {
    key: "polyfill",
    value: function polyfill(opt) {
      //所有组件可以提供一个静态方法， 就是用来做配置变动的向下兼容
      return opt;
    }
  }]);
  return Component;
}(event.Dispatcher);

var _default = Component;
exports["default"] = _default;
});

unwrapExports(component);

var numeral = createCommonjsModule(function (module) {
/*! @preserve
 * numeral.js
 * version : 2.0.6
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function (global, factory) {
    if ( module.exports) {
        module.exports = factory();
    } else {
        global.numeral = factory();
    }
}(commonjsGlobal, function () {
    /************************************
        Variables
    ************************************/

    var numeral,
        _,
        VERSION = '2.0.6',
        formats = {},
        locales = {},
        defaults = {
            currentLocale: 'en',
            zeroFormat: null,
            nullFormat: null,
            defaultFormat: '0,0',
            scalePercentBy100: true
        },
        options = {
            currentLocale: defaults.currentLocale,
            zeroFormat: defaults.zeroFormat,
            nullFormat: defaults.nullFormat,
            defaultFormat: defaults.defaultFormat,
            scalePercentBy100: defaults.scalePercentBy100
        };


    /************************************
        Constructors
    ************************************/

    // Numeral prototype object
    function Numeral(input, number) {
        this._input = input;

        this._value = number;
    }

    numeral = function(input) {
        var value,
            kind,
            unformatFunction,
            regexp;

        if (numeral.isNumeral(input)) {
            value = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            value = 0;
        } else if (input === null || _.isNaN(input)) {
            value = null;
        } else if (typeof input === 'string') {
            if (options.zeroFormat && input === options.zeroFormat) {
                value = 0;
            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {
                value = null;
            } else {
                for (kind in formats) {
                    regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;

                    if (regexp && input.match(regexp)) {
                        unformatFunction = formats[kind].unformat;

                        break;
                    }
                }

                unformatFunction = unformatFunction || numeral._.stringToNumber;

                value = unformatFunction(input);
            }
        } else {
            value = Number(input)|| null;
        }

        return new Numeral(input, value);
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function(obj) {
        return obj instanceof Numeral;
    };

    // helper functions
    numeral._ = _ = {
        // formats numbers separators, decimals places, signs, abbreviations
        numberToFormat: function(value, format, roundingFunction) {
            var locale = locales[numeral.options.currentLocale],
                negP = false,
                optDec = false,
                leadingCount = 0,
                abbr = '',
                trillion = 1000000000000,
                billion = 1000000000,
                million = 1000000,
                thousand = 1000,
                decimal = '',
                neg = false,
                abbrForce, // force abbreviation
                abs,
                int,
                precision,
                signed,
                thousands,
                output;

            // make sure we never format a null value
            value = value || 0;

            abs = Math.abs(value);

            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (numeral._.includes(format, '(')) {
                negP = true;
                format = format.replace(/[\(|\)]/g, '');
            } else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {
                signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;
                format = format.replace(/[\+|\-]/g, '');
            }

            // see if abbreviation is wanted
            if (numeral._.includes(format, 'a')) {
                abbrForce = format.match(/a(k|m|b|t)?/);

                abbrForce = abbrForce ? abbrForce[1] : false;

                // check for space before abbreviation
                if (numeral._.includes(format, ' a')) {
                    abbr = ' ';
                }

                format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');

                if (abs >= trillion && !abbrForce || abbrForce === 't') {
                    // trillion
                    abbr += locale.abbreviations.trillion;
                    value = value / trillion;
                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === 'b') {
                    // billion
                    abbr += locale.abbreviations.billion;
                    value = value / billion;
                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === 'm') {
                    // million
                    abbr += locale.abbreviations.million;
                    value = value / million;
                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === 'k') {
                    // thousand
                    abbr += locale.abbreviations.thousand;
                    value = value / thousand;
                }
            }

            // check for optional decimals
            if (numeral._.includes(format, '[.]')) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            // break number and format
            int = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');
            leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;

            if (precision) {
                if (numeral._.includes(precision, '[')) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);
                }

                int = decimal.split('.')[0];

                if (numeral._.includes(decimal, '.')) {
                    decimal = locale.delimiters.decimal + decimal.split('.')[1];
                } else {
                    decimal = '';
                }

                if (optDec && Number(decimal.slice(1)) === 0) {
                    decimal = '';
                }
            } else {
                int = numeral._.toFixed(value, 0, roundingFunction);
            }

            // check abbreviation again after rounding
            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {
                int = String(Number(int) / 1000);

                switch (abbr) {
                    case locale.abbreviations.thousand:
                        abbr = locale.abbreviations.million;
                        break;
                    case locale.abbreviations.million:
                        abbr = locale.abbreviations.billion;
                        break;
                    case locale.abbreviations.billion:
                        abbr = locale.abbreviations.trillion;
                        break;
                }
            }


            // format number
            if (numeral._.includes(int, '-')) {
                int = int.slice(1);
                neg = true;
            }

            if (int.length < leadingCount) {
                for (var i = leadingCount - int.length; i > 0; i--) {
                    int = '0' + int;
                }
            }

            if (thousands > -1) {
                int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + locale.delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                int = '';
            }

            output = int + decimal + (abbr ? abbr : '');

            if (negP) {
                output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');
            } else {
                if (signed >= 0) {
                    output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');
                } else if (neg) {
                    output = '-' + output;
                }
            }

            return output;
        },
        // unformats numbers separators, decimals places, signs, abbreviations
        stringToNumber: function(string) {
            var locale = locales[options.currentLocale],
                stringOriginal = string,
                abbreviations = {
                    thousand: 3,
                    million: 6,
                    billion: 9,
                    trillion: 12
                },
                abbreviation,
                value,
                regexp;

            if (options.zeroFormat && string === options.zeroFormat) {
                value = 0;
            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {
                value = null;
            } else {
                value = 1;

                if (locale.delimiters.decimal !== '.') {
                    string = string.replace(/\./g, '').replace(locale.delimiters.decimal, '.');
                }

                for (abbreviation in abbreviations) {
                    regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\)|(\\' + locale.currency.symbol + ')?(?:\\))?)?$');

                    if (stringOriginal.match(regexp)) {
                        value *= Math.pow(10, abbreviations[abbreviation]);
                        break;
                    }
                }

                // check for negative number
                value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;

                // remove non numbers
                string = string.replace(/[^0-9\.]+/g, '');

                value *= Number(string);
            }

            return value;
        },
        isNaN: function(value) {
            return typeof value === 'number' && isNaN(value);
        },
        includes: function(string, search) {
            return string.indexOf(search) !== -1;
        },
        insert: function(string, subString, start) {
            return string.slice(0, start) + subString + string.slice(start);
        },
        reduce: function(array, callback /*, initialValue*/) {
            if (this === null) {
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }

            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }

            var t = Object(array),
                len = t.length >>> 0,
                k = 0,
                value;

            if (arguments.length === 3) {
                value = arguments[2];
            } else {
                while (k < len && !(k in t)) {
                    k++;
                }

                if (k >= len) {
                    throw new TypeError('Reduce of empty array with no initial value');
                }

                value = t[k++];
            }
            for (; k < len; k++) {
                if (k in t) {
                    value = callback(value, t[k], k, t);
                }
            }
            return value;
        },
        /**
         * Computes the multiplier necessary to make x >= 1,
         * effectively eliminating miscalculations caused by
         * finite precision.
         */
        multiplier: function (x) {
            var parts = x.toString().split('.');

            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
        },
        /**
         * Given a variable number of arguments, returns the maximum
         * multiplier that must be used to normalize an operation involving
         * all of them.
         */
        correctionFactor: function () {
            var args = Array.prototype.slice.call(arguments);

            return args.reduce(function(accum, next) {
                var mn = _.multiplier(next);
                return accum > mn ? accum : mn;
            }, 1);
        },
        /**
         * Implementation of toFixed() that treats floats more like decimals
         *
         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
         * problems for accounting- and finance-related software.
         */
        toFixed: function(value, maxDecimals, roundingFunction, optionals) {
            var splitValue = value.toString().split('.'),
                minDecimals = maxDecimals - (optionals || 0),
                boundedPrecision,
                optionalsRegExp,
                power,
                output;

            // Use the smallest precision value possible to avoid errors from floating point representation
            if (splitValue.length === 2) {
              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
            } else {
              boundedPrecision = minDecimals;
            }

            power = Math.pow(10, boundedPrecision);

            // Multiply up by precision, round accurately, then divide and use native toFixed():
            output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);

            if (optionals > maxDecimals - boundedPrecision) {
                optionalsRegExp = new RegExp('\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');
                output = output.replace(optionalsRegExp, '');
            }

            return output;
        }
    };

    // avaliable options
    numeral.options = options;

    // avaliable formats
    numeral.formats = formats;

    // avaliable formats
    numeral.locales = locales;

    // This function sets the current locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    numeral.locale = function(key) {
        if (key) {
            options.currentLocale = key.toLowerCase();
        }

        return options.currentLocale;
    };

    // This function provides access to the loaded locale data.  If
    // no arguments are passed in, it will simply return the current
    // global locale object.
    numeral.localeData = function(key) {
        if (!key) {
            return locales[options.currentLocale];
        }

        key = key.toLowerCase();

        if (!locales[key]) {
            throw new Error('Unknown locale : ' + key);
        }

        return locales[key];
    };

    numeral.reset = function() {
        for (var property in defaults) {
            options[property] = defaults[property];
        }
    };

    numeral.zeroFormat = function(format) {
        options.zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.nullFormat = function (format) {
        options.nullFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function(format) {
        options.defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    numeral.register = function(type, name, format) {
        name = name.toLowerCase();

        if (this[type + 's'][name]) {
            throw new TypeError(name + ' ' + type + ' already registered.');
        }

        this[type + 's'][name] = format;

        return format;
    };


    numeral.validate = function(val, culture) {
        var _decimalSep,
            _thousandSep,
            _currSymbol,
            _valArray,
            _abbrObj,
            _thousandRegEx,
            localeData,
            temp;

        //coerce val to string
        if (typeof val !== 'string') {
            val += '';

            if (console.warn) {
                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
            }
        }

        //trim whitespaces from either sides
        val = val.trim();

        //if val is just digits return true
        if (!!val.match(/^\d+$/)) {
            return true;
        }

        //if val is empty return false
        if (val === '') {
            return false;
        }

        //get the decimal and thousands separator from numeral.localeData
        try {
            //check if the culture is understood by numeral. if not, default it to current locale
            localeData = numeral.localeData(culture);
        } catch (e) {
            localeData = numeral.localeData(numeral.locale());
        }

        //setup the delimiters and currency symbol based on culture/locale
        _currSymbol = localeData.currency.symbol;
        _abbrObj = localeData.abbreviations;
        _decimalSep = localeData.delimiters.decimal;
        if (localeData.delimiters.thousands === '.') {
            _thousandSep = '\\.';
        } else {
            _thousandSep = localeData.delimiters.thousands;
        }

        // validating currency symbol
        temp = val.match(/^[^\d]+/);
        if (temp !== null) {
            val = val.substr(1);
            if (temp[0] !== _currSymbol) {
                return false;
            }
        }

        //validating abbreviation symbol
        temp = val.match(/[^\d]+$/);
        if (temp !== null) {
            val = val.slice(0, -1);
            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
                return false;
            }
        }

        _thousandRegEx = new RegExp(_thousandSep + '{2}');

        if (!val.match(/[^\d.,]/g)) {
            _valArray = val.split(_decimalSep);
            if (_valArray.length > 2) {
                return false;
            } else {
                if (_valArray.length < 2) {
                    return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx));
                } else {
                    if (_valArray[0].length === 1) {
                        return ( !! _valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
                    } else {
                        return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
                    }
                }
            }
        }

        return false;
    };


    /************************************
        Numeral Prototype
    ************************************/

    numeral.fn = Numeral.prototype = {
        clone: function() {
            return numeral(this);
        },
        format: function(inputString, roundingFunction) {
            var value = this._value,
                format = inputString || options.defaultFormat,
                kind,
                output,
                formatFunction;

            // make sure we have a roundingFunction
            roundingFunction = roundingFunction || Math.round;

            // format based on value
            if (value === 0 && options.zeroFormat !== null) {
                output = options.zeroFormat;
            } else if (value === null && options.nullFormat !== null) {
                output = options.nullFormat;
            } else {
                for (kind in formats) {
                    if (format.match(formats[kind].regexps.format)) {
                        formatFunction = formats[kind].format;

                        break;
                    }
                }

                formatFunction = formatFunction || numeral._.numberToFormat;

                output = formatFunction(value, format, roundingFunction);
            }

            return output;
        },
        value: function() {
            return this._value;
        },
        input: function() {
            return this._input;
        },
        set: function(value) {
            this._value = Number(value);

            return this;
        },
        add: function(value) {
            var corrFactor = _.correctionFactor.call(null, this._value, value);

            function cback(accum, curr, currI, O) {
                return accum + Math.round(corrFactor * curr);
            }

            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;

            return this;
        },
        subtract: function(value) {
            var corrFactor = _.correctionFactor.call(null, this._value, value);

            function cback(accum, curr, currI, O) {
                return accum - Math.round(corrFactor * curr);
            }

            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;

            return this;
        },
        multiply: function(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = _.correctionFactor(accum, curr);
                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
            }

            this._value = _.reduce([this._value, value], cback, 1);

            return this;
        },
        divide: function(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = _.correctionFactor(accum, curr);
                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
            }

            this._value = _.reduce([this._value, value], cback);

            return this;
        },
        difference: function(value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }
    };

    /************************************
        Default Locale && Format
    ************************************/

    numeral.register('locale', 'en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function(number) {
            var b = number % 10;
            return (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    

(function() {
        numeral.register('format', 'bps', {
            regexps: {
                format: /(BPS)/,
                unformat: /(BPS)/
            },
            format: function(value, format, roundingFunction) {
                var space = numeral._.includes(format, ' BPS') ? ' ' : '',
                    output;

                value = value * 10000;

                // check for space before BPS
                format = format.replace(/\s?BPS/, '');

                output = numeral._.numberToFormat(value, format, roundingFunction);

                if (numeral._.includes(output, ')')) {
                    output = output.split('');

                    output.splice(-1, 0, space + 'BPS');

                    output = output.join('');
                } else {
                    output = output + space + 'BPS';
                }

                return output;
            },
            unformat: function(string) {
                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);
            }
        });
})();


(function() {
        var decimal = {
            base: 1000,
            suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
        },
        binary = {
            base: 1024,
            suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
        };

    var allSuffixes =  decimal.suffixes.concat(binary.suffixes.filter(function (item) {
            return decimal.suffixes.indexOf(item) < 0;
        }));
        var unformatRegex = allSuffixes.join('|');
        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)
        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';

    numeral.register('format', 'bytes', {
        regexps: {
            format: /([0\s]i?b)/,
            unformat: new RegExp(unformatRegex)
        },
        format: function(value, format, roundingFunction) {
            var output,
                bytes = numeral._.includes(format, 'ib') ? binary : decimal,
                suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '',
                power,
                min,
                max;

            // check for space before
            format = format.replace(/\s?i?b/, '');

            for (power = 0; power <= bytes.suffixes.length; power++) {
                min = Math.pow(bytes.base, power);
                max = Math.pow(bytes.base, power + 1);

                if (value === null || value === 0 || value >= min && value < max) {
                    suffix += bytes.suffixes[power];

                    if (min > 0) {
                        value = value / min;
                    }

                    break;
                }
            }

            output = numeral._.numberToFormat(value, format, roundingFunction);

            return output + suffix;
        },
        unformat: function(string) {
            var value = numeral._.stringToNumber(string),
                power,
                bytesMultiplier;

            if (value) {
                for (power = decimal.suffixes.length - 1; power >= 0; power--) {
                    if (numeral._.includes(string, decimal.suffixes[power])) {
                        bytesMultiplier = Math.pow(decimal.base, power);

                        break;
                    }

                    if (numeral._.includes(string, binary.suffixes[power])) {
                        bytesMultiplier = Math.pow(binary.base, power);

                        break;
                    }
                }

                value *= (bytesMultiplier || 1);
            }

            return value;
        }
    });
})();


(function() {
        numeral.register('format', 'currency', {
        regexps: {
            format: /(\$)/
        },
        format: function(value, format, roundingFunction) {
            var locale = numeral.locales[numeral.options.currentLocale],
                symbols = {
                    before: format.match(/^([\+|\-|\(|\s|\$]*)/)[0],
                    after: format.match(/([\+|\-|\)|\s|\$]*)$/)[0]
                },
                output,
                symbol,
                i;

            // strip format of spaces and $
            format = format.replace(/\s?\$\s?/, '');

            // format the number
            output = numeral._.numberToFormat(value, format, roundingFunction);

            // update the before and after based on value
            if (value >= 0) {
                symbols.before = symbols.before.replace(/[\-\(]/, '');
                symbols.after = symbols.after.replace(/[\-\)]/, '');
            } else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {
                symbols.before = '-' + symbols.before;
            }

            // loop through each before symbol
            for (i = 0; i < symbols.before.length; i++) {
                symbol = symbols.before[i];

                switch (symbol) {
                    case '$':
                        output = numeral._.insert(output, locale.currency.symbol, i);
                        break;
                    case ' ':
                        output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);
                        break;
                }
            }

            // loop through each after symbol
            for (i = symbols.after.length - 1; i >= 0; i--) {
                symbol = symbols.after[i];

                switch (symbol) {
                    case '$':
                        output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));
                        break;
                    case ' ':
                        output = i === symbols.after.length - 1 ? output + ' ' : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));
                        break;
                }
            }


            return output;
        }
    });
})();


(function() {
        numeral.register('format', 'exponential', {
        regexps: {
            format: /(e\+|e-)/,
            unformat: /(e\+|e-)/
        },
        format: function(value, format, roundingFunction) {
            var output,
                exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0',
                parts = exponential.split('e');

            format = format.replace(/e[\+|\-]{1}0/, '');

            output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);

            return output + 'e' + parts[1];
        },
        unformat: function(string) {
            var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'),
                value = Number(parts[0]),
                power = Number(parts[1]);

            power = numeral._.includes(string, 'e-') ? power *= -1 : power;

            function cback(accum, curr, currI, O) {
                var corrFactor = numeral._.correctionFactor(accum, curr),
                    num = (accum * corrFactor) * (curr * corrFactor) / (corrFactor * corrFactor);
                return num;
            }

            return numeral._.reduce([value, Math.pow(10, power)], cback, 1);
        }
    });
})();


(function() {
        numeral.register('format', 'ordinal', {
        regexps: {
            format: /(o)/
        },
        format: function(value, format, roundingFunction) {
            var locale = numeral.locales[numeral.options.currentLocale],
                output,
                ordinal = numeral._.includes(format, ' o') ? ' ' : '';

            // check for space before
            format = format.replace(/\s?o/, '');

            ordinal += locale.ordinal(value);

            output = numeral._.numberToFormat(value, format, roundingFunction);

            return output + ordinal;
        }
    });
})();


(function() {
        numeral.register('format', 'percentage', {
        regexps: {
            format: /(%)/,
            unformat: /(%)/
        },
        format: function(value, format, roundingFunction) {
            var space = numeral._.includes(format, ' %') ? ' ' : '',
                output;

            if (numeral.options.scalePercentBy100) {
                value = value * 100;
            }

            // check for space before %
            format = format.replace(/\s?\%/, '');

            output = numeral._.numberToFormat(value, format, roundingFunction);

            if (numeral._.includes(output, ')')) {
                output = output.split('');

                output.splice(-1, 0, space + '%');

                output = output.join('');
            } else {
                output = output + space + '%';
            }

            return output;
        },
        unformat: function(string) {
            var number = numeral._.stringToNumber(string);
            if (numeral.options.scalePercentBy100) {
                return number * 0.01;
            }
            return number;
        }
    });
})();


(function() {
        numeral.register('format', 'time', {
        regexps: {
            format: /(:)/,
            unformat: /(:)/
        },
        format: function(value, format, roundingFunction) {
            var hours = Math.floor(value / 60 / 60),
                minutes = Math.floor((value - (hours * 60 * 60)) / 60),
                seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));

            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
        },
        unformat: function(string) {
            var timeArray = string.split(':'),
                seconds = 0;

            // turn hours and minutes into seconds and add them all up
            if (timeArray.length === 3) {
                // hours
                seconds = seconds + (Number(timeArray[0]) * 60 * 60);
                // minutes
                seconds = seconds + (Number(timeArray[1]) * 60);
                // seconds
                seconds = seconds + Number(timeArray[2]);
            } else if (timeArray.length === 2) {
                // minutes
                seconds = seconds + (Number(timeArray[0]) * 60);
                // seconds
                seconds = seconds + Number(timeArray[1]);
            }
            return Number(seconds);
        }
    });
})();

return numeral;
}));
});

var coord = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = interopRequireDefault(_typeof_1$1);

var _defineProperty2 = interopRequireDefault(defineProperty$1);

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);



var _numeral = interopRequireDefault(numeral);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._;

var coordBase = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(coordBase, _Component);

  var _super = _createSuper(coordBase);

  function coordBase(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, coordBase);
    _this = _super.call(this, opt, app);

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(coordBase.defaultProps()));

    _this.name = "coord";
    _this._opt = opt;
    _this.app = app;
    _this.dataFrame = _this.app.dataFrame;
    _this.sprite = new _canvax["default"].Display.Sprite({
      name: "coord_" + opt.type
    });

    _this.app.coordSprite.addChild(_this.sprite);
    /*
    吧原始的field转换为对应结构的显示树
    ["uv"] --> [
        {field:'uv',enabled:true ,yAxis: yAxisleft }
        ...
    ]
    */


    _this.graphsFieldsMap = null;
    _this.induce = null;
    _this._axiss = []; //所有轴的集合
    //DOTO：注意，这里不能调用init 因为在rect polar等派生自这个空坐标系的组件里就会有问题
    //只能在用到空坐标组件的时候手动init()执行一下
    //this.init()

    return _this;
  } //空坐标系的init，在rect polar中会被覆盖


  (0, _createClass2["default"])(coordBase, [{
    key: "init",
    value: function init() {
      //this._initModules();
      //创建好了坐标系统后，设置 _fieldsDisplayMap 的值，
      // _fieldsDisplayMap 的结构里包含每个字段是否在显示状态的enabled 和 这个字段属于哪个yAxis
      this.graphsFieldsMap = this.setGraphsFieldsMap();
    } //空坐标系的draw，在rect polar中会被覆盖

  }, {
    key: "draw",
    value: function draw() {
      var _padding = this.app.padding;
      this.width = this.app.width - _padding.left - _padding.right;
      this.height = this.app.height - _padding.top - _padding.bottom;
      this.origin.x = _padding.left;
      this.origin.y = _padding.top;
    } //和原始field结构保持一致，但是对应的field换成 {field: , enabled:...}结构

  }, {
    key: "setGraphsFieldsMap",
    value: function setGraphsFieldsMap(axisExp) {
      var me = this;
      var ind = 0;
      var fieldsArr = [];

      if (axisExp) {
        _.each(this.getAxiss(axisExp), function (_axis) {
          if (_axis.field) {
            fieldsArr = fieldsArr.concat(_axis.field);
          }
        });
      }
      var graphs = this.app._opt.graphs ? _.flatten([this.app._opt.graphs]) : [];
      graphs.forEach(function (graph) {
        if (graph.field) {
          var graphFields = _.flatten([graph.field]);

          if (graphFields.length && _.flatten(fieldsArr).indexOf(graphFields[0]) == -1) {
            fieldsArr = fieldsArr.concat(graph.field);
          }
        }
      });

      function _set(fields) {
        if (_.isString(fields)) {
          fields = [fields];
        }

        var clone_fields = _.clone(fields);

        for (var i = 0, l = fields.length; i < l; i++) {
          var field = fields[i];

          if (_.isString(field)) {
            (function () {
              var color = me.app.getTheme(ind);
              var graph = void 0;
              var graphFieldInd = void 0;
              var graphColorProp = void 0; //graphs.find( graph => {_.flatten([graph.field]).indexOf( field )} ).color;

              for (var _i = 0, _l = graphs.length; _i < _l; _i++) {
                graph = graphs[_i];
                graphFieldInd = _.flatten([graph.field]).indexOf(field);

                if (graphFieldInd > -1) {
                  graphColorProp = graph.color;
                  break;
                }
              }

              if (graphColorProp) {
                if (typeof graphColorProp == 'string') {
                  color = graphColorProp;
                }

                if (Array.isArray(graphColorProp)) {
                  color = graphColorProp[graphFieldInd];
                }

                if (typeof graphColorProp == 'function') {
                  color = graphColorProp.apply(me.app, [graph]);
                }
              }
              var config = me.fieldsConfig[field];

              var fieldItem = _objectSpread({
                field: field,
                name: field,
                //fieldConfig中可能会覆盖
                type: graph.type,
                enabled: true,
                color: color,
                ind: ind++
              }, me.fieldsConfig[field] || {});

              fieldItem.getFormatValue = function (value) {
                return me.getFormatValue(value, config, fieldItem);
              };

              var axisType = axisExp ? axisExp.type || "yAxis" : null;

              if (axisType) {
                fieldItem[axisType] = me.getAxis({
                  type: axisType,
                  field: field
                });
              }
              clone_fields[i] = fieldItem;
            })();
          }

          if (_.isArray(field)) {
            clone_fields[i] = _set(field);
          }
        }
        return clone_fields;
      }
      return _set(fieldsArr);
    }
  }, {
    key: "getFormatValue",
    value: function getFormatValue(value, config) {
      if (config && config.format) {
        if (typeof config.format == 'string') {
          //如果传入的是 字符串，那么就认为是 numeral 的格式字符串
          value = (0, _numeral["default"])(value).format(config.format);
        }

        if (typeof config.format == 'function') {
          //如果传入的是函数
          value = config.format.apply(this, arguments);
        }
      } else {
        if ((0, _typeof2["default"])(value) == "object") {
          value = JSON.stringify(value);
        } else if (!isNaN(value) && value !== "" && value !== null) {
          //可以转换为number的， 就用 numeral 来格式化一下
          var values = value.toString().split('.');
          value = (0, _numeral["default"])(values[0]).format('0,0');

          if (values.length > 1) {
            value += '.' + values[1];
          }
        }
      }
      return value;
    } //设置 graphsFieldsMap 中对应field 的 enabled状态

  }, {
    key: "setFieldEnabled",
    value: function setFieldEnabled(field) {
      var me = this;

      function set(maps) {
        _.each(maps, function (map) {
          if (_.isArray(map)) {
            set(map);
          } else if (map.field && map.field == field) {
            map.enabled = !map.enabled;
          }
        });
      }

      set(me.graphsFieldsMap);
    } //从FieldsMap中获取对应的config

  }, {
    key: "getFieldConfig",
    value: function getFieldConfig(field) {
      var me = this;
      var fieldConfig = null;

      function get(maps) {
        _.each(maps, function (map) {
          if (_.isArray(map)) {
            get(map);
          } else if (map.field && map.field == field) {
            fieldConfig = map;
            return false;
          }
        });
      }

      get(me.graphsFieldsMap);

      if (!fieldConfig) {
        //如果再graphsFieldsMap中找不到， 也可能是传入的keyField parentKeyField 等
        //从opt中找一次
        var config = (this._opt.fieldsConfig || {})[field];

        if (config) {
          config.getFormatValue = function (value) {
            return me.getFormatValue(value, config, config);
          };

          fieldConfig = config;
        }
      }

      return fieldConfig;
    } //从 graphsFieldsMap 中过滤筛选出来一个一一对应的 enabled为true的对象结构
    //这个方法还必须要返回的数据里描述出来多y轴的结构。否则外面拿到数据后并不好处理那个数据对应哪个轴

  }, {
    key: "getEnabledFieldsOf",
    value: function getEnabledFieldsOf(axis) {
      var enabledFields = [];
      var axisType = axis ? axis.type : "yAxis";

      _.each(this.graphsFieldsMap, function (bamboo) {
        if (_.isArray(bamboo)) {
          //多节竹子，堆叠
          var fields = []; //设置完fields后，返回这个group属于left还是right的axis

          _.each(bamboo, function (obj) {
            if (obj[axisType] === axis && obj.field && obj.enabled) {
              fields.push(obj.field);
            }
          });

          fields.length && enabledFields.push(fields);
        } else {
          //单节棍
          if (bamboo[axisType] === axis && bamboo.field && bamboo.enabled) {
            enabledFields.push(bamboo.field);
          }
        }
      });

      return enabledFields;
    } //如果有传参数 fields 进来，那么就把这个指定的 fields 过滤掉 enabled==false的field
    //只留下enabled的field 结构

  }, {
    key: "filterEnabledFields",
    value: function filterEnabledFields(fields) {
      var me = this;
      var arr = [];
      if (!_.isArray(fields)) fields = [fields];

      _.each(fields, function (f) {
        if (!_.isArray(f)) {
          if (me.getFieldConfig(f).enabled) {
            arr.push(f);
          }
        } else {
          //如果这个是个纵向数据，说明就是堆叠配置
          var varr = [];

          _.each(f, function (v_f) {
            if (me.getFieldConfig(v_f).enabled) {
              varr.push(v_f);
            }
          });

          if (varr.length) {
            arr.push(varr);
          }
        }
      });

      return arr;
    }
  }, {
    key: "getAxisDataFrame",
    value: function getAxisDataFrame(fields) {
      return {
        field: fields,
        org: this.dataFrame.getDataOrg(fields, function (val) {
          if (val === undefined || val === null || val == "") {
            return val;
          }

          return isNaN(Number(val)) ? val : Number(val);
        })
      };
    } //空坐标系的getTipsInfoHandler，在rect polar中会被覆盖

  }, {
    key: "getTipsInfoHandler",
    value: function getTipsInfoHandler(e) {
      var obj = {
        nodes: [//遍历_graphs 去拿东西
        ]
      };

      if (e.eventInfo) {
        _.extend(true, obj, e.eventInfo);
      }
      return obj;
    }
  }, {
    key: "hide",
    value: function hide(field) {
      this.changeFieldEnabled(field);
    }
  }, {
    key: "show",
    value: function show(field) {
      this.changeFieldEnabled(field);
    }
  }, {
    key: "getSizeAndOrigin",
    value: function getSizeAndOrigin() {
      return {
        width: this.width,
        height: this.height,
        origin: this.origin
      };
    }
    /**
     * @param { opt.field  } field 用来查找对应的yAxis
     * @param { opt.iNode  } iNode 用来查找对应的xaxis的value
     * @param { opt.value {xval: yval:} }
     */

  }, {
    key: "getPoint",
    value: function getPoint() {}
  }, {
    key: "getAxisOriginPoint",
    value: function getAxisOriginPoint() {}
  }, {
    key: "getOriginPos",
    value: function getOriginPos() {}
  }, {
    key: "resetData",
    value: function resetData() {} //获取对应轴的接口

  }, {
    key: "getAxis",
    value: function getAxis(opt) {
      var axiss = this.getAxiss(opt);
      return axiss[0];
    }
  }, {
    key: "getAxiss",
    value: function getAxiss(opt) {
      var arr = [];
      var expCount = Object.keys(opt).length;

      _.each(this._axiss, function (item) {
        var i = 0;

        for (var p in opt) {
          if (p == 'field') {
            (function () {
              //字段的判断条件不同
              var fs = _.flatten([item[p]]);

              var expFs = _.flatten([opt[p]]);

              var inFs = true;

              _.each(expFs, function (exp) {
                if (_.indexOf(fs, exp) == -1) {
                  //任何一个field不再fs内， 说明配对不成功
                  inFs = false;
                }
              });

              if (inFs) {
                i++;
              }
            })();
          } else {
            if (JSON.stringify(item[p]) == JSON.stringify(opt[p])) {
              i++;
            }
          }
        }

        if (expCount == i) {
          arr.push(item);
        }
      });

      return arr;
    } //某axis变化了后，对应的依附于该axis的graphs都要重新reset

  }, {
    key: "resetGraphsOfAxis",
    value: function resetGraphsOfAxis(axis) {
      var graphs = this.app.getGraphs();
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        type: {
          detail: '坐标系组件',
          documentation: "坐标系组件，可选值有'rect'（二维直角坐标系）,'polar'（二维极坐标系）,'box'（三维直角坐标系） ",
          insertText: "type: ",
          "default": "",
          values: ["rect", "polar", "box", "polar3d"]
        },
        width: {
          detail: '坐标系width',
          "default": 0
        },
        height: {
          detail: '坐标系height',
          "default": 0
        },
        origin: {
          detail: '坐标系原点',
          propertys: {
            x: {
              detail: '原点x位置',
              "default": 0
            },
            y: {
              detail: '原点x位置',
              "default": 0
            }
          }
        },
        fieldsConfig: {
          detail: '字段的配置信息({uv:{name:"",format:""}})，包括中文名称和格式化单位，内部使用numeral做格式化',
          "default": {}
        }
      };
    }
  }]);
  return coordBase;
}(_component["default"]);

_component["default"].registerComponent(coordBase, 'coord');

var _default = coordBase;
exports["default"] = _default;
});

unwrapExports(coord);

var chart = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _global = interopRequireDefault(global$1);

var _canvax = interopRequireDefault(Canvax);

var _dataFrame = interopRequireDefault(dataFrame);

var _setting = interopRequireDefault(setting);

var _index = interopRequireDefault(coord);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    $ = _canvax["default"].$,
    event = _canvax["default"].event; //注册右键菜单事件

event.types.register('contextmenu');

var Chart = /*#__PURE__*/function (_event$Dispatcher) {
  (0, _inherits2["default"])(Chart, _event$Dispatcher);

  var _super = _createSuper(Chart);

  //node 为外部宿主的id 或者 dom节点
  //也可能就是外部已经创建好的 canvax对象 { canvax（实例）, stage, width, height }
  function Chart(node, data, opt, componentModules, otherOptions) {
    var _this;

    (0, _classCallCheck2["default"])(this, Chart);
    _this = _super.call(this);
    _this.otherOptions = otherOptions;
    _this.componentModules = componentModules;
    _this._node = node;

    if (!data) {
      data = [];
    }

    if (!_this.otherOptions.noDataClone) {
      data = JSON.parse(JSON.stringify(data, function (k, v) {
        if (v === undefined) {
          return null;
        }

        return v;
      }));
    }

    _this._data = data; //注意，resetData不能为null，必须是 数组格式

    _this._opt = _this.polyfill(opt);
    _this.dataFrame = _this._initDataFrame(_this._data, _this._opt); //legend如果在top，就会把图表的padding.top修改，减去legend的height

    _this.padding = null; //node可能是意外外面一件准备好了canvax对象， 包括 stage  width height 等

    _this.el = $.query(node); //chart 在页面里面的容器节点，也就是要把这个chart放在哪个节点里

    _this.width = node.width || parseInt(_this.el.offsetWidth); //图表区域宽

    _this.height = node.height || parseInt(_this.el.offsetHeight); //图表区域高
    //Canvax实例

    if (!node.canvax) {
      _this.canvax = new _canvax["default"].App({
        el: _this.el,
        webGL: false
      });

      _this.canvax.registEvent();

      _this.id = "chartx_" + _this.canvax.id;

      _this.el.setAttribute("chart_id", _this.id); //设置stage ---------------------------------------------------------begin


      _this.stage = new _canvax["default"].Display.Stage({
        id: "main-chart-stage"
      });

      _this.canvax.addChild(_this.stage); //设置stage ---------------------------------------------------------end

    } else {
      _this.canvax = node.canvax;
      _this.stage = node.stage;
    }

    _this.setCoord_Graphs_Sp(); //这三类组件是优先级最高的组件，所有的组件的模块化和绘制，都要一次在这三个完成后实现


    _this.__highModules = ["theme", "coord", "graphs"]; //组件管理机制,所有的组件都绘制在这个地方

    _this.components = [];
    _this.inited = false;

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(Chart, [{
    key: "polyfill",
    value: function polyfill(opt) {
      var _this2 = this;

      var _loop = function _loop(compName) {
        var comps = _.flatten([opt[compName]]);

        comps.forEach(function (comp) {
          var compModule = _this2.componentModules.get(compName, comp.type);

          compModule && compModule.polyfill(comp);
        });
      };

      for (var compName in opt) {
        _loop(compName);
      }

      return opt;
    }
  }, {
    key: "init",
    value: function init() {
      var _this3 = this;

      var me = this; //init全部用 this._opt

      var opt = this._opt; //padding数据也要重置为起始值

      this.padding = this._getPadding();
      this._initPadding = JSON.parse(JSON.stringify(this.padding)); //首先判断如果没有coord配置，那么就配置一个空坐标系，所有的图表都会依赖一个坐标系， 哪怕是个空坐标系

      if (!opt.coord) {
        var _coord = new _index["default"]({}, me);

        _coord.init();

        me.components.push(_coord);
      }

      _.each(this.__highModules, function (compName) {
        if (!opt[compName]) return;

        var comps = _.flatten([opt[compName]]); //them是一个数组的组件。so特殊处理


        if (compName == "theme") {
          comps = [comps];
        }

        _.each(comps, function (comp) {
          if ( //没有type的coord和没有field(or keyField)的graphs，都无效，不要创建该组件
          //关系图中是keyField
          //(compName == "coord" && !comp.type ) || 
          compName == "graphs" && (!comp.field && !comp.keyField && !comp.adcode && !comp.geoJson && !comp.geoJsonUrl //地图的话只要有个adcode就可以了
          || 'enabled' in comp && !comp.enabled)) return;
          var compModule = me.componentModules.get(compName, comp.type);

          if (compModule) {
            var _preComp = (me._preComponents || []).find(function (_c) {
              return _c.type == comp.type && _c.field == comp.field;
            });

            var _comp = new compModule(comp, me, _preComp || {}); //可能用户配置了一个空的coord坐标系，没有type，里面配置了一些fieldsConfig之类的全局配置的时候
            //就要手动init一下这个空坐标系


            if (compName == 'coord' && !comp.type) {
              //空坐标组件， 就要手动调用一下组件的init()
              _comp.init();
            }
            me.components.push(_comp);
          }
        });
      }); //PS: theme 组件优先级最高，在registerComponents之前已经加载过


      var _loop2 = function _loop2(_p) {
        //非coord graphs theme，其实后面也可以统一的
        if (_.indexOf(_this3.__highModules, _p) == -1) {
          var comps = _this3._opt[_p]; //所有的组件都按照数组方式处理，这里，组件里面就不需要再这样处理了

          if (!_.isArray(comps)) {
            comps = [comps];
          }

          _.each(comps, function (comp) {
            var compModule = me.componentModules.get(_p, comp.type);

            if (compModule && !('enabled' in comp && !comp.enabled)) {
              var _comp = new compModule(comp, me);

              me.components.push(_comp);
            }
          });
        }
      };

      for (var _p in this._opt) {
        _loop2(_p);
      }
    }
  }, {
    key: "draw",
    value: function draw(_opt) {
      var me = this;
      var opt = Object.assign({}, _opt || {});

      var _coord = this.getComponent({
        name: 'coord'
      });

      if (_coord && _coord.horizontal) {
        this._drawBeginHorizontal();
      }
      var width = this.width - this.padding.left - this.padding.right;
      var height = this.height - this.padding.top - this.padding.bottom;
      var origin = {
        x: this.padding.left,
        y: this.padding.top
      };

      if (_coord) {
        //先绘制好坐标系统
        _coord.draw(opt);

        width = _coord.width;
        height = _coord.height;
        origin = _coord.origin;
      }
      //如果没有数据，不需要绘制graphs
      //me.fire("complete");
      //return;
      //};

      var _graphs = this.getComponents({
        name: 'graphs'
      });

      var graphsCount = _graphs.length;
      var completeNum = 0;
      opt = _.extend(opt, {
        width: width,
        height: height,
        origin: origin
      }); //没有数据的时候可以不绘制graphs，但是下面的其他components还是需要绘制的，比如图例

      if (this.dataFrame.length > 0) {
        _.each(_graphs, function (_g) {
          _g.on("complete", function (g) {
            completeNum++;

            if (completeNum == graphsCount) {
              me.fire("complete");
            }
            _g.inited = true;
          });

          _g.draw(opt);
        });
      }

      for (var i = 0, l = this.components.length; i < l; i++) {
        var p = this.components[i];

        if (_.indexOf(this.__highModules, p.name) == -1) {
          p.draw(opt);
        }
      }

      this._bindEvent();

      if (_coord && _coord.horizontal) {
        this._drawEndHorizontal();
      }
    }
  }, {
    key: "_drawBeginHorizontal",
    value: function _drawBeginHorizontal() {
      //横向了之后， 要把4个padding值轮换一下
      //top,right 对调 ， bottom,left 对调
      var padding = this.padding;
      var num = padding.top;
      padding.top = padding.right;
      padding.right = padding.bottom;
      padding.bottom = padding.left;
      padding.left = num;
    } //绘制完毕后的横向处理

  }, {
    key: "_drawEndHorizontal",
    value: function _drawEndHorizontal() {
      var ctx = this.graphsSprite.context;
      ctx.x += (this.width - this.height) / 2;
      ctx.y += (this.height - this.width) / 2;
      ctx.rotation = 90;
      ctx.rotateOrigin = {
        x: this.height / 2,
        y: this.width / 2
      };

      this._horizontalGraphsText();
    }
  }, {
    key: "_horizontalGraphsText",
    value: function _horizontalGraphsText() {
      var me = this;

      function _horizontalText(el) {
        if (el.children) {
          _.each(el.children, function (_el) {
            _horizontalText(_el);
          });
        }

        if (el.type == "text" && !el.__horizontal) {
          var ctx = el.context;
          ctx.rotation = ctx.rotation - 90;
          el.__horizontal = true;
        }
      }

      _.each(me.getComponents({
        name: 'graphs'
      }), function (_graphs) {
        _horizontalText(_graphs.sprite);
      });
    }
  }, {
    key: "_getPadding",
    value: function _getPadding() {
      var paddingVal = _setting["default"].padding;

      if (this._opt.coord && "padding" in this._opt.coord) {
        if (!_.isObject(this._opt.coord.padding)) {
          paddingVal = this._opt.coord.padding;
        }
      }
      var paddingObj = {
        top: paddingVal,
        right: paddingVal,
        bottom: paddingVal,
        left: paddingVal
      };

      if (this._opt.coord && "padding" in this._opt.coord) {
        if (_.isObject(this._opt.coord.padding)) {
          paddingObj = _.extend(paddingObj, this._opt.coord.padding);
        }
      }
      return paddingObj;
    } //ind 如果有就获取对应索引的具体颜色值

  }, {
    key: "getTheme",
    value: function getTheme(ind) {
      var colors = _global["default"].getGlobalTheme();

      var _theme = this.getComponent({
        name: 'theme'
      });

      if (_theme) {
        colors = _theme.get();
      }

      if (ind != undefined) {
        return colors[ind % colors.length] || "#ccc";
      }
      return colors;
    }
  }, {
    key: "setCoord_Graphs_Sp",
    value: function setCoord_Graphs_Sp() {
      //坐标系存放的容器
      this.coordSprite = new _canvax["default"].Display.Sprite({
        id: 'coordSprite'
      });
      this.stage.addChild(this.coordSprite); //graphs管理

      this.graphsSprite = new _canvax["default"].Display.Sprite({
        id: 'graphsSprite'
      });
      this.stage.addChild(this.graphsSprite);
    }
    /*
     * chart的销毁
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.clean();

      if (this.el) {
        this.el.removeAttribute("chart_id");
        this.el.removeAttribute("chartx_version");
        this.canvax.destroy();
        this.el = null;
      }
      this._destroy && this._destroy();
      this.fire("destroy");
    }
    /*
     * 清除整个图表
     **/

  }, {
    key: "clean",
    value: function clean() {
      //保留所有的stage，stage下面得元素全部 destroy 掉
      for (var i = 0, l = this.canvax.children.length; i < l; i++) {
        var stage = this.canvax.getChildAt(i);

        for (var s = 0, sl = stage.children.length; s < sl; s++) {
          stage.getChildAt(s).destroy();
          s--;
          sl--;
        }
      }
      //所以要重新设置一遍准备好。

      this.setCoord_Graphs_Sp();
      this._preComponents = this.components;
      this.components = []; //组件清空

      this.canvax.domView && (this.canvax.domView.innerHTML = ""); //清空事件的当前状态

      if (this.canvax.event) {
        this.canvax.event.curPointsTarget = [];
      }

      this.padding = this._initPadding;
    }
    /**
     * 容器的尺寸改变重新绘制
     */

  }, {
    key: "resize",
    value: function resize() {
      var _w = parseInt(this.el.offsetWidth);

      var _h = parseInt(this.el.offsetHeight);

      if (_w == this.width && _h == this.height) return;
      this.width = _w;
      this.height = _h;
      this.canvax.resize();
      this.inited = false;
      this.clean();
      this.init();
      this.draw({
        resize: true
      });
      this.inited = true;
    }
    /**
     * reset 其实就是重新绘制整个图表，不再做详细的拆分opts中有哪些变化，来做对应的细致的变化，简单粗暴的全部重新创立
     * opt 必须全量options，不在支持局部opt传递，所以对opt的处理不再支持extend
     */

  }, {
    key: "reset",
    value: function reset(opt, data) {
      opt = _global["default"]._optionsHandle(opt); //opt && (this._opt = opt);

      if (opt) {
        this._opt = this.polyfill(opt);
      }

      if (arguments.length == 1) {
        //如果只传了一个opt配置，就说明数据要用图本身的原数据
        data = this._data;
      } else {
        if (!data) {
          data = [];
        }
      }

      if (!this.otherOptions.noDataClone) {
        data = JSON.parse(JSON.stringify(data, function (k, v) {
          if (v === undefined) {
            return null;
          }

          return v;
        }));
      }

      this._data = data; //注意，resetData不能为null，必须是 数组格式

      this.dataFrame = this._initDataFrame(this._data, this._opt);
      this.clean();
      this.init();
      this.draw();
    }
    /*
     * 只响应数据的变化，不涉及配置变化
     * 
     * @trigger 一般是触发这个data reset的一些场景数据，内部触发才会有，比如datazoom， tree的收缩节点
     * 外部调用resetData的时候，是只会传递第一个data数据的
     * 比如如果是 datazoom 触发的， 就会有 trigger数据{ name:'datazoom', left:1,right:1 }
     */

  }, {
    key: "resetData",
    value: function resetData(data, trigger) {
      var me = this;
      var preDataLenth = this.dataFrame.org.length;

      if (!trigger || !trigger.comp) {
        //直接chart级别的resetData调用
        //只有非内部trigger的的resetData，才会有原数据的改变， 
        if (!data) {
          data = [];
        }

        if (!this.otherOptions.noDataClone) {
          data = JSON.parse(JSON.stringify(data, function (k, v) {
            if (v === undefined) {
              return null;
            }

            return v;
          }));
        }

        this._data = data; //注意，resetData不能为null，必须是 数组格式

        this.dataFrame.resetData(this._data);
      } else {
        //内部组件trigger的话，比如datazoom
        this.dataFrame.resetData();
      }

      var graphsList = this.getComponents({
        name: 'graphs'
      });
      var allGraphsHasResetData = true;

      _.each(graphsList, function (_g) {
        if (!_g.resetData && allGraphsHasResetData) {
          allGraphsHasResetData = false;
          return false;
        }
      });

      if (!preDataLenth || !allGraphsHasResetData) {
        //如果之前的数据为空， 那么我们应该这里就直接重绘吧
        //如果有其中一个graphs没实现resetData 也 重绘
        this.clean();
        this.init();
        this.draw(this._opt);
        this.fire("resetData");
        return;
      }

      var _coord = this.getComponent({
        name: 'coord'
      });

      var width = _coord.width;
      var height = _coord.height;
      var origin = _coord.origin;

      if (_coord) {
        _coord.resetData(this.dataFrame, trigger);
      }

      _.each(graphsList, function (_g) {
        _g.resetData(me.dataFrame, trigger, {
          origin: origin,
          width: width,
          height: height
        });
      });

      this.componentsReset(trigger, origin);

      if (_coord && _coord.horizontal) {
        this._horizontalGraphsText();
      }
      this.fire("resetData");
    }
  }, {
    key: "_initDataFrame",
    value: function _initDataFrame() {
      return _dataFrame["default"].apply(this, arguments);
    }
  }, {
    key: "componentsReset",
    value: function componentsReset(trigger) {
      var me = this;

      _.each(this.components, function (p, i) {
        //theme coord graphs额外处理
        if (_.indexOf(me.__highModules, p.name) != -1) {
          return;
        }

        if (trigger && trigger.comp && trigger.comp.__cid == p.__cid) {
          //如果这次reset就是由自己触发的，那么自己这个components不需要reset，负责观察就好
          return;
        }
        p.reset && p.reset(me[p.type] || {}, me.dataFrame);
      });
    }
  }, {
    key: "getComponentById",
    value: function getComponentById(id) {
      var comp;

      _.each(this.components, function (c) {
        if (c.id && c.id == id) {
          comp = c;
          return false;
        }
      });

      return comp;
    }
  }, {
    key: "getComponent",
    value: function getComponent(opt) {
      return this.getComponents(opt)[0];
    }
  }, {
    key: "getComponents",
    value: function getComponents(opt, components) {
      var arr = [];
      var expCount = 0;

      if (!components) {
        components = this.components;
      }

      for (var p in opt) {
        expCount++;
      }

      if (!expCount) {
        return components;
      }

      _.each(components, function (comp) {
        var i = 0;

        for (var _p2 in opt) {
          if (JSON.stringify(comp[_p2]) == JSON.stringify(opt[_p2])) {
            i++;
          }
        }

        if (expCount == i) {
          arr.push(comp);
        }
      });

      return arr;
    } //从graphs里面去根据opt做一一对比，比对成功为true
    //count为要查询的数量， 如果为1，则

  }, {
    key: "getGraph",
    value: function getGraph(opt) {
      var graphs = this.getGraphs(opt);
      return graphs[0];
    }
  }, {
    key: "getGraphs",
    value: function getGraphs(opt) {
      return this.getComponents(opt, this.getComponents({
        name: 'graphs'
      }));
    } //获取graphs根据id

  }, {
    key: "getGraphById",
    value: function getGraphById(id) {
      var _g;

      _.each(this.getComponents({
        name: 'graphs'
      }), function (g) {
        if (g.id == id) {
          _g = g;
          return false;
        }
      });

      return _g;
    } //从coord里面去根据opt做一一对比，比对成功为true
    //目前没有多个坐标系的图表，所以不需要 getCoords 

  }, {
    key: "getCoord",
    value: function getCoord(opt) {
      return this.getComponent(_.extend(true, {
        name: 'coord'
      }, opt));
    } //只有field为多组数据的时候才需要legend，给到legend组件来调用

  }, {
    key: "getLegendData",
    value: function getLegendData() {
      var me = this;
      var data = []; //这里涌来兼容pie等的图例，其实后续可以考虑后面所有的graphs都提供一个getLegendData的方法

      _.each(this.getComponents({
        name: 'graphs'
      }), function (_g) {
        _.each(_g.getLegendData(), function (item) {
          if (_.find(data, function (d) {
            return d.name == item.name;
          })) return;

          var legendItem = _.extend(true, {
            enabled: true
          }, item);

          legendItem.color = item.fillStyle || item.color || item.style;
          data.push(legendItem);
        });
      });

      if (data.length) {
        return data;
      }

      var _coord = me.getComponent({
        name: 'coord'
      });

      _.each(_.flatten(_coord.graphsFieldsMap), function (map, i) {
        //因为yAxis上面是可以单独自己配置field的，所以，这部分要过滤出 legend data
        var isGraphsField = false;

        _.each(me._opt.graphs, function (gopt) {
          if (_.indexOf(_.flatten([gopt.field]), map.field) > -1) {
            isGraphsField = true;
            return false;
          }
        });

        if (isGraphsField) {
          data.push({
            enabled: map.enabled,
            name: map.name || map.field,
            field: map.field,
            ind: map.ind,
            color: map.color,
            type: map.type,
            yAxis: map.yAxis
          });
        }
      });

      return data;
    }
  }, {
    key: "show",
    value: function show(field, trigger) {
      var _coord = this.getComponent({
        name: 'coord'
      });

      _coord && _coord.show(field, trigger);

      _.each(this.getComponents({
        name: 'graphs'
      }), function (_g) {
        _g.show(field, trigger);
      });

      this.componentsReset(trigger);
    }
  }, {
    key: "hide",
    value: function hide(field, trigger) {
      var _coord = this.getComponent({
        name: 'coord'
      });

      _coord && _coord.hide(field, trigger);

      _.each(this.getComponents({
        name: 'graphs'
      }), function (_g) {
        _g.hide(field, trigger);
      });

      this.componentsReset(trigger);
    }
  }, {
    key: "triggerEvent",
    value: function triggerEvent(event) {
      //触发每个graphs级别的事件（在 graph 上面 用 on 绑定的事件），
      //用户交互事件先执行，还可以修改e的内容修改tips内容(e.eventInfo)
      if (event.eventInfo) {
        var graphs = this.getGraphs();
        graphs.forEach(function (graph) {
          graph.triggerEvent(event);
        });
      }

      var _tips = this.getComponent({
        name: 'tips'
      });

      var _coord = this.getComponent({
        name: 'coord'
      });

      if (_tips) {
        this._setGraphsTipsInfo.apply(this, [event]);

        if ('mouseover,mousedown,tap,longTap'.indexOf(event.type) > -1) {
          _tips.show(event);

          this._tipsPointerAtAllGraphs(event);
        }

        if ('mousemove,touchMove'.indexOf(event.type) > -1) {
          _tips.move(event);

          this._tipsPointerAtAllGraphs(event);
        }

        if ('mouseout'.indexOf(event.type) > -1 && !(event.toTarget && _coord && _coord.induce && _coord.induce.containsPoint(_coord.induce.globalToLocal(event.target.localToGlobal(event.point))))) {
          _tips.hide(event);

          this._tipsPointerHideAtAllGraphs(event);
        }
      }

      var _contextmenu = this.getComponent({
        name: 'contextmenu'
      });

      if (_contextmenu) {
        if ('mousedown,click'.indexOf(event.type) > -1) {
          _contextmenu.hide(event);
        }

        if (event.type == 'contextmenu') {
          _contextmenu.show(event);
        }
      }
    }
  }, {
    key: "_bindEvent",
    value: function _bindEvent() {
      var _this4 = this;

      if (this.__bindEvented) return;
      this.on(event.types.get(), function (e) {
        //先触发自己的事件
        _this4.triggerEvent(e); //然后
        //如果这个图表的tips组件有设置linkageName，
        //那么就寻找到所有的图表实例中有相同linkageName的图表，执行相应的事件


        var tipsComp = _this4.getComponent({
          name: "tips"
        });

        if (tipsComp && tipsComp.linkageName) {
          for (var c in _global["default"].instances) {
            var linkageChart = _global["default"].instances[c];
            if (linkageChart == _this4) continue;
            var linkageChartTipsComp = linkageChart.getComponent({
              name: "tips"
            });

            if (linkageChartTipsComp && linkageChartTipsComp.linkageName && linkageChartTipsComp.linkageName == tipsComp.linkageName) {
              if (e.eventInfo && e.eventInfo.nodes) {
                e.eventInfo.nodes = [];
              }

              e.eventInfo.isLinkageTrigger = true;
              linkageChart.triggerEvent.apply(linkageChart, [e]);
            }
          }
        }
      }); //一个项目只需要bind一次

      this.__bindEvented = true;
    } //默认的基本tipsinfo处理，极坐标和笛卡尔坐标系统会覆盖

  }, {
    key: "_setGraphsTipsInfo",
    value: function _setGraphsTipsInfo(e) {
      if (!e.eventInfo) {
        e.eventInfo = {};
      }

      var _coord = this.getComponent({
        name: 'coord'
      });

      if (_coord) {
        e.eventInfo = _coord.getTipsInfoHandler(e);
      }

      if (!("tipsEnabled" in e.eventInfo)) {
        e.eventInfo.tipsEnabled = true; //默认都开始tips
      }
      //比如鼠标移动到多柱子组合的具体某根bar上面，e.eventInfo.nodes = [ {bardata} ] 就有了这个bar的数据
      //那么tips就只显示这个bardata的数据

      if (!e.eventInfo.nodes || !e.eventInfo.nodes.length) {
        var nodes = [];
        var iNode = e.eventInfo.iNode;

        _.each(this.getComponents({
          name: 'graphs'
        }), function (_g) {
          if (_g.getNodesAt && iNode !== undefined) {
            var _nodes = _g.getNodesAt(iNode, e);

            if (!_nodes || !_nodes.length) return;

            if (!Array.isArray(_nodes)) {
              _nodes = [_nodes];
            }

            nodes = nodes.concat(_nodes);
          }
        });

        e.eventInfo.nodes = nodes;
      }
    } //把这个point拿来给每一个graphs执行一次测试，给graphs上面的shape触发激活样式

  }, {
    key: "_tipsPointerAtAllGraphs",
    value: function _tipsPointerAtAllGraphs(e) {
      _.each(this.getComponents({
        name: 'graphs'
      }), function (_g) {
        _g.tipsPointerOf(e);
      });
    }
  }, {
    key: "_tipsPointerHideAtAllGraphs",
    value: function _tipsPointerHideAtAllGraphs(e) {
      _.each(this.getComponents({
        name: 'graphs'
      }), function (_g) {
        _g.tipsPointerHideOf(e);
      });
    }
  }]);
  return Chart;
}(event.Dispatcher);

_global["default"].registerComponent(Chart, 'chart');

var _default = Chart;
exports["default"] = _default;
});

unwrapExports(chart);

var dataSection_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;



function normalizeTickInterval(interval, magnitude) {
  var normalized; // let multiples = [1, 2, 2.5, 5, 10];

  var multiples = [1, 2, 5, 10]; // round to a tenfold of 1, 2, 2.5 or 5

  normalized = interval / magnitude; // normalize the interval to the nearest multiple

  for (var _i = 0; _i < multiples.length; _i++) {
    interval = multiples[_i];

    if (normalized <= (multiples[_i] + (multiples[_i + 1] || multiples[_i])) / 2) {
      break;
    }
  } // multiply back to the correct magnitude


  interval *= magnitude;
  return interval;
}

function correctFloat(num) {
  return parseFloat(num.toPrecision(14));
}

function getLinearTickPositions(arr, $maxPart, $cfg) {
  arr = Canvax._.without(arr, undefined, null, "");
  var scale = $cfg && $cfg.scale ? parseFloat($cfg.scale) : 1; //返回的数组中的值 是否都为整数(思霏)  防止返回[8, 8.2, 8.4, 8.6, 8.8, 9]   应该返回[8, 9]

  var isInt = $cfg && $cfg.isInt ? 1 : 0;

  if (isNaN(scale)) {
    scale = 1;
  }

  var max = Canvax._.max(arr);

  var initMax = max;
  max *= scale;

  var min = Canvax._.min(arr);

  if (min == max) {
    if (max > 0) {
      min = 0;
      return [min, max]; // min= Math.round(max/2);
    } else if (max < 0) {
      return [max, 0]; //min = max*2;
    } else {
      max = 1;
      return [0, max];
    }
  }

  var length = max - min;

  if (length) {
    var tempmin = min; //保证min>0的时候不会出现负数

    min -= length * 0.05; // S.log(min +":"+ tempmin)

    if (min < 0 && tempmin >= 0) {
      min = 0;
    }

    max += length * 0.05;
  }

  var tickInterval = (max - min) * 0.3; //72 / 365;

  var magnitude = Math.pow(10, Math.floor(Math.log(tickInterval) / Math.LN10));
  tickInterval = normalizeTickInterval(tickInterval, magnitude);

  if (isInt) {
    tickInterval = Math.ceil(tickInterval);
  }

  var pos,
      lastPos,
      roundedMin = correctFloat(Math.floor(min / tickInterval) * tickInterval),
      roundedMax = correctFloat(Math.ceil(max / tickInterval) * tickInterval),
      tickPositions = []; // Populate the intermediate values

  pos = roundedMin;

  while (pos <= roundedMax) {
    // Place the tick on the rounded value
    tickPositions.push(pos); // Always add the raw tickInterval, not the corrected one.

    pos = correctFloat(pos + tickInterval); // If the interval is not big enough in the current min - max range to actually increase
    // the loop variable, we need to break out to prevent endless loop. Issue #619

    if (pos === lastPos) {
      break;
    } // Record the last value


    lastPos = pos;
  }

  if (tickPositions.length >= 3) {
    if (tickPositions[tickPositions.length - 2] >= initMax) {
      tickPositions.pop();
    }
  }

  return tickPositions;
}

var dataSection = {
  section: function section($arr, $maxPart, $cfg) {
    return Canvax._.uniq(getLinearTickPositions($arr, $maxPart, $cfg));
  }
};
var _default = dataSection;
exports["default"] = _default;
});

unwrapExports(dataSection_1);

var axis_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);



var _dataSection = interopRequireDefault(dataSection_1);



//TODO 所有的get xxx OfVal 在非proportion下面如果数据有相同的情况，就会有风险
var axis = /*#__PURE__*/function () {
  function axis(opt, dataOrg) {
    (0, _classCallCheck2["default"])(this, axis);
    //源数据
    //这个是一个一定会有两层数组的数据结构，是一个标准的dataFrame数据
    // [ 
    //    [   
    //        [1,2,3],  
    //        [1,2,3]    //这样有堆叠的数据只会出现在proportion的axis里，至少目前是这样
    //    ] 
    //   ,[    
    //        [1,2,3] 
    //    ]   
    // ]
    this._opt = Canvax._.clone(opt);
    this.dataOrg = dataOrg || [];
    this._dataSectionLayout = []; //和dataSection一一对应的，每个值的pos，//get xxx OfPos的时候，要先来这里做一次寻找

    this._cellCount = null;
    this._cellLength = null; //数据变动的时候要置空
    //默认的 _dataSectionGroup = [ dataSection ], dataSection 其实就是 _dataSectionGroup 去重后的一维版本

    this._dataSectionGroup = [];
    this.originPos = 0; //value为 origin 对应的pos位置

    this._originTrans = 0; //当设置的 origin 和datasection的min不同的时候，
    //min,max不需要外面配置，没意义

    this._min = null;
    this._max = null;

    Canvax._.extend(true, this, (0, tools.getDefaultProps)(axis.defaultProps()), opt);
  }

  (0, _createClass2["default"])(axis, [{
    key: "resetDataOrg",
    value: function resetDataOrg(dataOrg) {
      //配置和数据变化
      this.dataSection = [];
      this._dataSectionGroup = [];
      this.dataOrg = dataOrg;
      this._cellCount = null;
      this._cellLength = null;
    }
  }, {
    key: "setAxisLength",
    value: function setAxisLength(length) {
      this.axisLength = length;
      this.calculateProps();
    }
  }, {
    key: "calculateProps",
    value: function calculateProps() {
      var me = this;

      if (this.layoutType == "proportion") {
        this._min = Canvax._.min(this.dataSection);
        this._max = Canvax._.max(this.dataSection); //默认情况下 origin 就是datasection的最小值
        //如果用户设置了origin，那么就已用户的设置为准

        if (!("origin" in this._opt)) {
          this.origin = 0; //this.dataSection[0];//_.min( this.dataSection );

          if (Canvax._.max(this.dataSection) < 0) {
            this.origin = Canvax._.max(this.dataSection);
          }

          if (Canvax._.min(this.dataSection) > 0) {
            this.origin = Canvax._.min(this.dataSection);
          }
        }
        this._originTrans = this._getOriginTrans(this.origin);
        this.originPos = this.getPosOfVal(this.origin);
      }

      this._dataSectionLayout = [];

      Canvax._.each(this.dataSection, function (val, i) {
        var ind = i;

        if (me.layoutType == "proportion") {
          ind = me.getIndexOfVal(val);
        }
        var pos = parseInt(me.getPosOf({
          ind: i,
          val: val
        }), 10);

        me._dataSectionLayout.push({
          val: val,
          ind: ind,
          pos: pos
        });
      });
    }
  }, {
    key: "getDataSection",
    value: function getDataSection() {
      //对外返回的dataSection
      return this.dataSection;
    }
  }, {
    key: "setDataSection",
    value: function setDataSection() {
      if (Array.isArray(this._opt.dataSection) && this._opt.dataSection.length) {
        this.dataSection = this._opt.dataSection;
        this._dataSectionGroup = [this.dataSection];
      } else {
        if (this.layoutType == "proportion") {
          //如果像柱状图中有堆叠的情况出现， arr中已经把堆叠的数据加起来了
          var arr = this._getDataSection();

          if ("origin" in this._opt) {
            arr.push(this._opt.origin);
          }

          if (arr.length == 1) {
            var n = arr[0];

            if (Math.abs(n) > 10) {
              arr = [n - 1, n, n + 1];
            } else if (Math.abs(n) >= 1 && Math.abs(n) <= 10) {
              arr = [n - 0.1, n, n + 0.1];
            } else {
              arr = [n * .5, n, n * 2];
            }
          }

          if (Array.isArray(this.verniers) && this.verniers.length) {
            arr = arr.concat(this.verniers);
          }

          if (this.symmetric) {
            //如果需要处理为对称数据
            var _min = Canvax._.min(arr);

            var _max = Canvax._.max(arr);

            if (Math.abs(_min) > Math.abs(_max)) {
              arr.push(Math.abs(_min));
            } else {
              arr.push(-Math.abs(_max));
            }
          }

          for (var ai = 0, al = arr.length; ai < al; ai++) {
            arr[ai] = Number(arr[ai]);

            if (isNaN(arr[ai])) {
              arr.splice(ai, 1);
              ai--;
              al--;
            }
          }

          if (Canvax._.isFunction(this.sectionHandler)) {
            this.dataSection = this.sectionHandler(arr);
          }

          if (!this.dataSection || !this.dataSection.length) {
            this.dataSection = _dataSection["default"].section(arr, 3);
          }

          if (this.symmetric) {
            //可能得到的区间是偶数， 非对称，强行补上
            var _min2 = Canvax._.min(this.dataSection);

            var _max2 = Canvax._.max(this.dataSection);

            if (Math.abs(_min2) > Math.abs(_max2)) {
              this.dataSection.push(Math.abs(_min2));
            } else {
              this.dataSection.unshift(-Math.abs(_max2));
            }
          } //如果还是0


          if (this.dataSection.length == 0) {
            this.dataSection = [0];
          } //如果有 middleWeight 设置，就会重新设置dataSectionGroup


          this._dataSectionGroup = [Canvax._.clone(this.dataSection)];

          this._middleweight(); //如果有middleweight配置，需要根据配置来重新矫正下datasection


          this._sort();
        } else {
          //非proportion 也就是 rule peak 模式下面
          this.dataSection = Canvax._.flatten(this.dataOrg); //this._getDataSection();

          this._dataSectionGroup = [this.dataSection];
        }
      }

      this._middleWeightPos();
    }
  }, {
    key: "_getDataSection",
    value: function _getDataSection() {
      //如果有堆叠，比如[ ["uv","pv"], "ppc" ]
      //那么这个 this.dataOrg， 也是个对应的结构
      //vLen就会等于2
      var vLen = 1;

      Canvax._.each(this.dataOrg, function (arr) {
        vLen = Math.max(arr.length, vLen);
      });

      if (vLen == 1) {
        return this._oneDimensional();
      }

      if (vLen > 1) {
        return this._twoDimensional();
      }
    } //后续也会做堆叠的折线图，就是面积图， 和堆叠图不同的是走的是一维数据计算

  }, {
    key: "_oneDimensional",
    value: function _oneDimensional() {
      var arr = Canvax._.flatten(this.dataOrg); //_.flatten( data.org );


      var _arr = [];

      for (var i = 0, il = arr.length; i < il; i++) {
        if (arr[i] != null && arr[i] != undefined && arr[i] != '') {
          _arr.push(arr[i]);
        }
      }
      return Canvax._.unique(_arr);
    } //二维的yAxis设置，肯定是堆叠的比如柱状图，

  }, {
    key: "_twoDimensional",
    value: function _twoDimensional() {
      var d = this.dataOrg;
      var arr = [];
      var min;

      Canvax._.each(d, function (d) {
        if (!d.length) {
          return;
        }

        if (!Canvax._.isArray(d[0])) {
          arr.push(d);
          return;
        }
        var varr = [];
        var len = d[0].length;
        var vLen = d.length;

        for (var i = 0; i < len; i++) {
          var up_count = 0;
          var up_i = 0;
          var down_count = 0;
          var down_i = 0;

          for (var ii = 0; ii < vLen; ii++) {
            var _val = d[ii][i];

            if (!_val && _val !== 0) {
              continue;
            }
            min == undefined && (min = _val);
            min = Math.min(min, _val);

            if (_val >= 0) {
              up_count += _val;
              up_i++;
            } else {
              down_count += _val;
              down_i++;
            }
          }

          up_i && varr.push(up_count);
          down_i && varr.push(down_count);
        }
        arr.push(varr);
      });

      arr.push(min);
      return Canvax._.flatten(arr);
    } //val 要被push到datasection 中去的 值
    //主要是用在markline等组件中，当自己的y值超出了yaxis的范围

  }, {
    key: "_addValToSection",
    value: function _addValToSection(val) {
      this.addVerniers(val);
      this.setDataSection();
      this.calculateProps();
    }
  }, {
    key: "addVerniers",
    value: function addVerniers(val) {
      if (this.verniers.indexOf(val) == -1) {
        this.verniers.push(val);
      }
    }
  }, {
    key: "_sort",
    value: function _sort() {
      if (this.sort) {
        var sort = this._getSortType();

        if (sort == "desc") {
          this.dataSection.reverse(); //_dataSectionGroup 从里到外全部都要做一次 reverse， 这样就可以对应上 dataSection.reverse()

          Canvax._.each(this._dataSectionGroup, function (dsg) {
            dsg.reverse();
          });

          this._dataSectionGroup.reverse(); //_dataSectionGroup reverse end

        }
      }
    }
  }, {
    key: "_getSortType",
    value: function _getSortType() {
      var _sort;

      if (Canvax._.isString(this.sort)) {
        _sort = this.sort;
      }

      if (!_sort) {
        _sort = "asc";
      }

      return _sort;
    }
  }, {
    key: "_middleweight",
    value: function _middleweight() {
      if (this.middleWeight) {
        //支持多个量级的设置
        if (!Canvax._.isArray(this.middleWeight)) {
          this.middleWeight = [this.middleWeight];
        }

        var dMin = Canvax._.min(this.dataSection);

        var dMax = Canvax._.max(this.dataSection);

        var newDS = [dMin];
        var newDSG = [];

        for (var i = 0, l = this.middleWeight.length; i < l; i++) {
          var preMiddleweight = dMin;

          if (i > 0) {
            preMiddleweight = this.middleWeight[i - 1];
          }
          var middleVal = preMiddleweight + parseInt((this.middleWeight[i] - preMiddleweight) / 2);
          newDS.push(middleVal);
          newDS.push(this.middleWeight[i]);
          newDSG.push([preMiddleweight, middleVal, this.middleWeight[i]]);
        }
        var lastMW = this.middleWeight.slice(-1)[0];

        if (dMax > lastMW) {
          newDS.push(lastMW + (dMax - lastMW) / 2);
          newDS.push(dMax);
          newDSG.push([lastMW, lastMW + (dMax - lastMW) / 2, dMax]);
        } //好了。 到这里用简单的规则重新拼接好了新的 dataSection


        this.dataSection = newDS;
        this._dataSectionGroup = newDSG;
      }
    }
  }, {
    key: "_middleWeightPos",
    value: function _middleWeightPos() {
      var me = this;

      if (this.middleWeightPos) {
        if (!Canvax._.isArray(this.middleWeightPos)) {
          this.middleWeightPos = [this.middleWeightPos];
        }
        //如果大于1了则默认按照均分设置

        var _count = 0;

        Canvax._.each(this.middleWeightPos, function (pos) {
          _count += pos;
        });

        if (_count < 1) {
          this.middleWeightPos.push(1 - _count);
        }

        if (_count > 1) {
          this.middleWeightPos = null;
        }
      }

      if (this.middleWeight) {
        if (!this.middleWeightPos) {
          this.middleWeightPos = [];
          var _prePos = 0;

          Canvax._.each(this.middleWeight, function () {
            var _pos = 1 / (me.middleWeight.length + 1);

            _prePos += _pos;
            me.middleWeightPos.push(_pos);
          });

          this.middleWeightPos.push(1 - _prePos);
        }
      } else {
        this.middleWeightPos = [1];
      }
    } //origin 对应 this.origin 的值

  }, {
    key: "_getOriginTrans",
    value: function _getOriginTrans(origin) {
      var _this = this;

      var pos = 0;
      var me = this;
      var dsgLen = this._dataSectionGroup.length;
      var groupLength = this.axisLength / dsgLen;

      var _loop = function _loop(i, l) {
        var ds = _this._dataSectionGroup[i];
        groupLength = _this.axisLength * _this.middleWeightPos[i];
        var preGroupLenth = 0;

        Canvax._.each(_this.middleWeightPos, function (mp, mi) {
          if (mi < i) {
            preGroupLenth += me.axisLength * mp;
          }
        });

        if (_this.layoutType == "proportion") {
          var min = Canvax._.min(ds);

          var max = Canvax._.max(ds);

          var amountABS = Math.abs(max - min);

          if (origin >= min && origin <= max) {
            pos = (origin - min) / amountABS * groupLength + preGroupLenth;
            return "break";
          }
        }
      };

      for (var i = 0, l = dsgLen; i < l; i++) {
        var _ret = _loop(i);

        if (_ret === "break") break;
      }

      if (this.sort == "desc") {
        //如果是倒序的
        pos = -(groupLength - pos);
      }
      return parseInt(pos);
    } //opt { val ind pos } 一次只能传一个

  }, {
    key: "_getLayoutDataOf",
    value: function _getLayoutDataOf(opt) {
      var props = ["val", "ind", "pos"];
      var prop;

      Canvax._.each(props, function (_p) {
        if (_p in opt) {
          prop = _p;
        }
      });

      var layoutData;

      Canvax._.each(this._dataSectionLayout, function (item) {
        if (item[prop] === opt[prop]) {
          layoutData = item;
        }
      });

      return layoutData || {};
    }
  }, {
    key: "getPosOfVal",
    value: function getPosOfVal(val) {
      /* val可能会重复，so 这里得到的会有问题，先去掉
      //先检查下 _dataSectionLayout 中有没有对应的记录
      let _pos = this._getLayoutDataOf({ val : val }).pos;
      if( _pos != undefined ){
          return _pos;
      };
      */
      return this.getPosOf({
        val: val
      });
    }
  }, {
    key: "getPosOfInd",
    value: function getPosOfInd(ind) {
      //先检查下 _dataSectionLayout 中有没有对应的记录
      var _pos = this._getLayoutDataOf({
        ind: ind
      }).pos;

      if (_pos != undefined) {
        return _pos;
      }
      return this.getPosOf({
        ind: ind
      });
    } //opt {val, ind} val 或者ind 一定有一个

  }, {
    key: "getPosOf",
    value: function getPosOf(opt) {
      var _this2 = this;

      var me = this;
      var pos;

      var cellCount = this._getCellCount(); //dataOrg上面的真实数据节点数，把轴分成了多少个节点


      if (this.layoutType == "proportion") {
        var dsgLen = this._dataSectionGroup.length;

        var _loop2 = function _loop2(i, l) {
          var ds = _this2._dataSectionGroup[i];
          var groupLength = _this2.axisLength * _this2.middleWeightPos[i];
          var preGroupLenth = 0;

          Canvax._.each(_this2.middleWeightPos, function (mp, mi) {
            if (mi < i) {
              preGroupLenth += me.axisLength * mp;
            }
          });

          var min = Canvax._.min(ds);

          var max = Canvax._.max(ds);

          var val = "val" in opt ? opt.val : _this2.getValOfInd(opt.ind);
          var _origin = _this2.origin;
          var origiInRange = !(_origin < min || _origin > max); //如果 origin 并不在这个区间

          if (!origiInRange) {
            _origin = min;
          }

          if (val >= min && val <= max) {
            //origin不在区间内的话，maxGroupDisABS一定是整个区间， 也就是说这个区间的原点在起点min
            var maxGroupDisABS = Math.max(Math.abs(max - _origin), Math.abs(_origin - min));
            var amountABS = Math.abs(max - min);
            var originPos = maxGroupDisABS / amountABS * groupLength;
            pos = (val - _origin) / maxGroupDisABS * originPos + preGroupLenth;

            if (isNaN(pos)) {
              pos = parseInt(preGroupLenth);
            }

            if (origiInRange) {
              //origin在区间内的时候，才需要偏移_originTrans
              pos += _this2._originTrans;
            }
          } else {
            //先简单处理下超出边界的行为
            if (val > max && i == l - 1) {
              pos = me.axisLength;
            }

            if (val < min && i == 0) {
              pos = 0;
            }
          }
        };

        for (var i = 0, l = dsgLen; i < l; i++) {
          _loop2(i, l);
        }
      } else {
        if (cellCount == 1) {
          //如果只有一数据，那么就全部默认在正中间
          pos = this.axisLength / 2;
        } else {
          //TODO 这里在非proportion情况下，如果没有opt.ind 那么getIndexOfVal 其实是有风险的，
          //因为可能有多个数据的val一样
          var valInd = "ind" in opt ? opt.ind : this.getIndexOfVal(opt.val);

          if (valInd != -1) {
            if (this.layoutType == "rule") {
              //line 的xaxis就是 rule
              pos = valInd / (cellCount - 1) * this.axisLength;
            }

            if (this.layoutType == "peak") {
              //bar的xaxis就是 peak

              /*
              pos = (this.axisLength/cellCount) 
                    * (valInd+1) 
                    - (this.axisLength/cellCount)/2;
              */
              var _cellLength = this.getCellLength();

              pos = _cellLength * (valInd + 1) - _cellLength / 2;
            }
          }
        }
      }
      !pos && (pos = 0);
      pos = Number(pos.toFixed(1));
      return Math.abs(pos);
    }
  }, {
    key: "getValOfPos",
    value: function getValOfPos(pos) {
      //先检查下 _dataSectionLayout 中有没有对应的记录
      var _val = this._getLayoutDataOf({
        pos: pos
      }).val;

      if (_val != undefined) {
        return _val;
      }
      return this._getValOfInd(this.getIndexOfPos(pos));
    } //ds可选

  }, {
    key: "getValOfInd",
    value: function getValOfInd(ind) {
      //先检查下 _dataSectionLayout 中有没有对应的记录
      var _val = this._getLayoutDataOf({
        ind: ind
      }).val;

      if (_val != undefined) {
        return _val;
      }
      return this._getValOfInd(ind);
      /*
      if (this.layoutType == "proportion") {
      
      } else {
          //这里的index是直接的对应dataOrg的索引
          let org = ds ? ds : _.flatten(this.dataOrg);
          return org[ind];
      };
      */
    } //这里的ind

  }, {
    key: "_getValOfInd",
    value: function _getValOfInd(ind) {
      var me = this;

      var org = Canvax._.flatten(this.dataOrg);

      var val;

      if (this.layoutType == "proportion") {
        //let dsgLen = this._dataSectionGroup.length;
        //let groupLength = this.axisLength / dsgLen;
        Canvax._.each(this._dataSectionGroup, function (ds, i) {
          var groupLength = me.axisLength * me.middleWeightPos[i];
          var preGroupLenth = 0;

          Canvax._.each(me.middleWeightPos, function (mp, mi) {
            if (mi < i) {
              preGroupLenth += me.axisLength * mp;
            }
          });

          if (parseInt(ind / groupLength) == i || i == me._dataSectionGroup.length - 1) {
            var min = Canvax._.min(ds);

            var max = Canvax._.max(ds);

            val = min + (max - min) / groupLength * (ind - preGroupLenth);
            return false;
          }
        });
      } else {
        val = org[ind];
      }
      return val;
    }
  }, {
    key: "getIndexOfPos",
    value: function getIndexOfPos(pos) {
      //先检查下 _dataSectionLayout 中有没有对应的记录
      var _ind = this._getLayoutDataOf({
        pos: pos
      }).ind;

      if (_ind != undefined) {
        return _ind;
      }
      var ind = 0;
      var cellLength = this.getCellLengthOfPos(pos);

      var cellCount = this._getCellCount();

      if (this.layoutType == "proportion") {
        //proportion中的index以像素为单位 所以，传入的像素值就是index
        return pos;
      } else {
        if (this.layoutType == "peak") {
          ind = parseInt(pos / cellLength);

          if (ind == cellCount) {
            ind = cellCount - 1;
          }
        }

        if (this.layoutType == "rule") {
          ind = parseInt((pos + cellLength / 2) / cellLength);

          if (cellCount == 1) {
            //如果只有一个数据
            ind = 0;
          }
        }
      }
      return ind;
    }
  }, {
    key: "getIndexOfVal",
    value: function getIndexOfVal(val) {
      var valInd = -1;

      if (this.layoutType == "proportion") {
        //先检查下 _dataSectionLayout 中有没有对应的记录
        var _ind = this._getLayoutDataOf({
          val: val
        }).ind;

        if (_ind != undefined) {
          return _ind;
        }
        //所以这里要返回pos

        valInd = this.getPosOfVal(val);
      } else {
        Canvax._.each(this.dataOrg, function (arr) {
          Canvax._.each(arr, function (list) {
            var _ind = Canvax._.indexOf(list, val);

            if (_ind != -1) {
              valInd = _ind;
            }
          });
        });
      }

      return valInd;
    }
  }, {
    key: "getCellLength",
    value: function getCellLength() {
      if (this._cellLength !== null) {
        return this._cellLength;
      }

      var axisLength = this.axisLength;
      var cellLength = axisLength;

      var cellCount = this._getCellCount();

      if (cellCount) {
        if (this.layoutType == "proportion") {
          cellLength = 1;
        } else {
          //默认按照 peak 也就是柱状图的需要的布局方式
          cellLength = axisLength / cellCount;

          if (this.layoutType == "rule") {
            if (cellCount == 1) {
              cellLength = axisLength / 2;
            } else {
              cellLength = axisLength / (cellCount - 1);
            }
          }

          if (this.posParseToInt) {
            cellLength = parseInt(cellLength);
          }
        }
      }
      this._cellLength = cellLength;
      return cellLength;
    } //这个getCellLengthOfPos接口主要是给tips用，因为tips中只有x信息

  }, {
    key: "getCellLengthOfPos",
    value: function getCellLengthOfPos() {
      return this.getCellLength();
    } //pos目前没用到，给后续的高级功能预留接口

  }, {
    key: "getCellLengthOfInd",
    value: function getCellLengthOfInd() {
      return this.getCellLength();
    }
  }, {
    key: "_getCellCount",
    value: function _getCellCount() {
      if (this._cellCount !== null) {
        return this._cellCount;
      }

      var cellCount = 0;

      if (this.layoutType == "proportion") {
        cellCount = this.axisLength;
      } else {
        if (this.dataOrg.length && this.dataOrg[0].length && this.dataOrg[0][0].length) {
          cellCount = this.dataOrg[0][0].length;
        }
      }
      this._cellCount = cellCount;
      return cellCount;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        layoutType: {
          detail: '布局方式',
          "default": 'proportion'
        },
        axisLength: {
          detail: '轴长度',
          "default": 1
        },
        dataSection: {
          detail: '轴数据集',
          "default": []
        },
        sectionHandler: {
          detail: '自定义dataSection的计算公式',
          "default": null
        },
        verniers: {
          detail: '设定的游标，dataSection的区间一定会覆盖这些值',
          "default": []
        },
        middleWeight: {
          detail: '区间分隔线',
          "default": null,
          documentation: '如果middleweight有设置的话 _dataSectionGroup 为被middleweight分割出来的n个数组>..[ [0,50 , 100],[100,500,1000] ]'
        },
        middleWeightPos: {
          detail: '区间分隔线的物理位置，百分比,默认 0.5 ',
          "default": null
        },
        symmetric: {
          detail: '自动正负对称',
          "default": false,
          documentation: 'proportion下，是否需要设置数据为正负对称的数据，比如 [ 0,5,10 ] = > [ -10, 0 10 ]，象限坐标系的时候需要'
        },
        origin: {
          detail: '轴的起源值',
          "default": null,
          documentation: '\
                    1，如果数据中又正数和负数，则默认为0 <br />\
                    2，如果dataSection最小值小于0，则baseNumber为最小值<br />\
                    3，如果dataSection最大值大于0，则baseNumber为最大值<br />\
                    4，也可以由用户在第2、3种情况下强制配置为0，则section会补充满从0开始的刻度值\
                '
        },
        sort: {
          detail: '排序',
          "default": null
        },
        posParseToInt: {
          detail: '是否位置计算取整',
          "default": false,
          documentation: '比如在柱状图中，有得时候需要高精度的能间隔1px的柱子，那么x轴的计算也必须要都是整除的'
        }
      };
    }
  }]);
  return axis;
}();

var _default = axis;
exports["default"] = _default;
});

unwrapExports(axis_1);

var axis = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _axis = interopRequireDefault(axis_1);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Axis = /*#__PURE__*/function (_baseAxis) {
  (0, _inherits2["default"])(Axis, _baseAxis);

  var _super = _createSuper(Axis);

  function Axis(opt, dataOrg) {
    var _this;

    (0, _classCallCheck2["default"])(this, Axis);
    _this = _super.call(this, opt, dataOrg);

    Canvax._.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(Axis.defaultProps()));

    return _this;
  } //vals 参数可以是单个number 也可以是 多个


  (0, _createClass2["default"])(Axis, [{
    key: "addValToSection",
    value: function addValToSection(vals) {
      var _this2 = this;

      if (!Array.isArray(vals)) {
        vals = [vals];
      }

      if (this.layoutType == "proportion") {
        var allIn = true;
        vals.forEach(function (val) {
          if (!(val >= _this2._min && val <= _this2._max)) {
            allIn = false;
          }
        });

        if (allIn) {
          //都在dataSection的区间内，就不用管了
          return;
        }
      }

      this.dataSection = [];
      vals.forEach(function (val) {
        _this2._addValToSection(val);
      });

      this._initHandle();

      this.draw(); //然后要检测下依附于这个轴的所有graphs，都要重新绘制

      this._coord.resetGraphsOfAxis(this);
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: '轴字段配置',
          documentation: '目前x轴的field只支持单维度设置，也就是说只支持一条x轴',
          "default": []
        },
        layoutType: {
          detail: '布局方式',
          "default": 'rule'
        },
        width: {
          detail: '轴宽',
          "default": 0
        },
        height: {
          detail: '轴高',
          "default": 0
        },
        enabled: {
          detail: '是否显示轴',
          "default": true
        },
        animation: {
          detail: '是否开启动画',
          "default": true
        },
        title: {
          detail: '轴名称',
          propertys: {
            shapeType: "text",
            textAlign: {
              detail: '水平对齐方式',
              "default": 'center'
            },
            textBaseline: {
              detail: '基线对齐方式',
              "default": 'middle'
            },
            strokeStyle: {
              detail: '文本描边颜色',
              "default": null
            },
            lineHeight: {
              detail: '行高',
              "default": 0
            },
            text: {
              detail: '轴名称的内容',
              "default": ''
            },
            fontColor: {
              detail: '颜色',
              "default": '#999'
            },
            fontSize: {
              detail: '字体大小',
              "default": 12
            }
          }
        },
        tickLine: {
          detail: '刻度线',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": true
            },
            lineWidth: {
              detail: '刻度线宽',
              "default": 1
            },
            lineLength: {
              detail: '刻度线长度',
              "default": 4
            },
            distance: {
              detail: '和前面一个元素的距离',
              "default": 2
            },
            strokeStyle: {
              detail: '描边颜色',
              "default": '#e6e6e6'
            }
          }
        },
        axisLine: {
          detail: '轴线配置',
          propertys: {
            enabled: {
              detail: '是否有轴线',
              "default": true
            },
            position: {
              detail: '轴线的位置',
              documentation: 'default在align的位置（left，right），可选 "center" 和 具体的值',
              "default": 'default'
            },
            lineWidth: {
              detail: '轴线宽度',
              "default": 1
            },
            strokeStyle: {
              detail: '轴线的颜色',
              "default": '#e6e6e6'
            }
          }
        },
        label: {
          detail: '刻度文本',
          propertys: {
            enabled: {
              detail: '是否显示刻度文本',
              "default": true
            },
            fontColor: {
              detail: '文本颜色',
              "default": '#999'
            },
            fontSize: {
              detail: '字体大小',
              "default": 10
            },
            rotation: {
              detail: '旋转角度',
              "default": 0
            },
            format: {
              detail: 'label文本的格式化处理函数',
              "default": null
            },
            distance: {
              detail: '和轴线之间的间距',
              "default": 2
            },
            textAlign: {
              detail: '水平方向对齐方式',
              "default": 'center'
            },
            lineHeight: {
              detail: '文本的行高',
              "default": 1
            },
            evade: {
              detail: '是否开启逃避算法,目前的逃避只是隐藏',
              "default": true
            },
            alpha: {
              detail: '透明度',
              "default": 1
            }
          }
        },
        filter: {
          detail: '过滤函数',
          documentation: '可以用来过滤哪些yaxis 的 节点是否显示已经颜色之类的',
          "default": null
        },
        trimLayout: {
          detail: '自定义的显示规则函数',
          documentation: '如果用户有手动的 trimLayout ，那么就全部visible为true，然后调用用户自己的过滤程序',
          "default": null
        }
      };
    }
  }]);
  return Axis;
}(_axis["default"]);

exports["default"] = Axis;
});

unwrapExports(axis);

var xaxis = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _numeral = interopRequireDefault(numeral);

var _axis = interopRequireDefault(axis);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._;
var Line = _canvax["default"].Shapes.Line;

var xAxis = /*#__PURE__*/function (_Axis) {
  (0, _inherits2["default"])(xAxis, _Axis);

  var _super = _createSuper(xAxis);

  function xAxis(opt, data, _coord) {
    var _this;

    (0, _classCallCheck2["default"])(this, xAxis);
    _this = _super.call(this, opt, data.org);
    _this.type = "xAxis";
    _this._coord = _coord || {};
    _this._title = null; //this.title对应的文本对象

    _this._axisLine = null;
    _this._formatTextSection = []; //dataSection的值format后一一对应的值

    _this._textElements = []; //_formatTextSection中每个文本对应的canvax.shape.Text对象

    _this.pos = {
      x: 0,
      y: 0
    };
    _this.layoutData = []; //{x:100, value:'1000',visible:true}

    _this.sprite = null;
    _this.isH = false; //是否为横向转向的x轴

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(xAxis.defaultProps()), opt);

    _this.init(opt);

    return _this;
  }

  (0, _createClass2["default"])(xAxis, [{
    key: "init",
    value: function init(opt) {
      this._setField();

      this._initHandle(opt);

      this.sprite = new _canvax["default"].Display.Sprite({
        id: "xAxisSprite_" + new Date().getTime()
      });
      this.rulesSprite = new _canvax["default"].Display.Sprite({
        id: "xRulesSprite_" + new Date().getTime()
      });
      this.sprite.addChild(this.rulesSprite);
    }
  }, {
    key: "_initHandle",
    value: function _initHandle(opt) {
      var me = this;

      if (opt) {
        if (opt.isH && (!opt.label || opt.label.rotaion === undefined)) {
          //如果是横向直角坐标系图
          this.label.rotation = 90;
        }
      }
      this.setDataSection();
      me._formatTextSection = [];
      me._textElements = [];

      _.each(me.dataSection, function (val, i) {
        me._formatTextSection[i] = me._getFormatText(val, i); //从_formatTextSection中取出对应的格式化后的文本

        var txt = new _canvax["default"].Display.Text(me._formatTextSection[i], {
          context: {
            fontSize: me.label.fontSize
          }
        });
        me._textElements[i] = txt;
      });

      if (this.label.rotation != 0) {
        //如果是旋转的文本，那么以右边为旋转中心点
        this.label.textAlign = "right";
      }

      this._getTitle();

      this._setXAxisHeight();
    }
  }, {
    key: "_setField",
    value: function _setField(field) {
      if (field) {
        this.field = field;
      }

      this.field = _.flatten([this.field])[0];
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      //首次渲染从 直角坐标系组件中会传入 opt,包含了width，origin等， 所有这个时候才能计算layoutData
      opt && _.extend(true, this, opt);
      this.setAxisLength(this.width);

      this._trimXAxis();

      this._widget(opt);

      this.setX(this.pos.x);
      this.setY(this.pos.y);
    } //配置和数据变化

  }, {
    key: "resetData",
    value: function resetData(dataFrame, opt) {
      // if( _opt ){
      //     if( 'width' in _opt ){
      //         this.width = _opt.width;
      //     }
      //     if( 'pos' in _opt ){
      //         if( 'x' in _opt.pos ) this.setX( _opt.pos.x );
      //         if( 'y' in _opt.pos ) this.setY( _opt.pos.y );
      //     }
      // }
      opt && _.extend(true, this, opt);

      this._setField(dataFrame.field);

      this.resetDataOrg(dataFrame.org);

      this._initHandle();

      this.draw(opt);
    }
  }, {
    key: "setX",
    value: function setX($n) {
      this.sprite.context.x = $n;
      this.pos.x = $n;
    }
  }, {
    key: "setY",
    value: function setY($n) {
      this.sprite.context.y = $n;
      this.pos.y = $n;
    }
  }, {
    key: "_getTitle",
    value: function _getTitle() {
      if (this.title.text) {
        if (!this._title) {
          this._title = new _canvax["default"].Display.Text(this.title.text, {
            context: {
              fontSize: this.title.fontSize,
              textAlign: this.title.textAlign,
              //"center",//this.isH ? "center" : "left",
              textBaseline: this.title.textBaseline,
              //"middle", //this.isH ? "top" : "middle",
              fillStyle: this.title.fontColor,
              strokeStyle: this.title.strokeStyle,
              lineWidth: this.title.lineWidth,
              rotation: this.isH ? -180 : 0
            }
          });
        } else {
          this._title.resetText(this.title.text || '');
        }
      }
    }
  }, {
    key: "_setXAxisHeight",
    value: function _setXAxisHeight() {
      //检测下文字的高等
      var me = this;

      if (!me.enabled) {
        me.height = 0;
      } else {
        var _maxTextHeight = 0;

        if (this.label.enabled) {
          _.each(me.dataSection, function (val, i) {
            //从_formatTextSection中取出对应的格式化后的文本
            var txt = me._textElements[i];
            var textWidth = txt.getTextWidth();
            var textHeight = txt.getTextHeight(); //let width = textWidth; //文本在外接矩形width

            var height = textHeight; //文本在外接矩形height

            if (!!me.label.rotation) {
              //有设置旋转
              if (me.label.rotation == 90) {
                //width  = textHeight;
                height = textWidth;
              } else {
                var sinR = Math.sin(Math.abs(me.label.rotation) * Math.PI / 180); //let cosR = Math.cos(Math.abs(me.label.rotation) * Math.PI / 180);

                height = parseInt(sinR * textWidth); //width = parseInt( cosR * textWidth );
              }
            }
            _maxTextHeight = Math.max(_maxTextHeight, height);
          });
        }
        this.height = _maxTextHeight + this.tickLine.lineLength + this.tickLine.distance + this.label.distance;

        if (this._title) {
          this.height += this._title.getTextHeight();
        }
      }
    }
  }, {
    key: "getNodeInfoOfX",
    value: function getNodeInfoOfX(x) {
      var ind = this.getIndexOfPos(x);
      var val = this.getValOfInd(ind); //this.getValOfPos(x);//

      var pos = this.getPosOf({
        ind: ind,
        val: val
      });
      return this._getNodeInfo(ind, val, pos);
    }
  }, {
    key: "getNodeInfoOfVal",
    value: function getNodeInfoOfVal(val) {
      var ind = this.getIndexOfVal(val);
      var pos = this.getPosOf({
        ind: ind,
        val: val
      });
      return this._getNodeInfo(ind, val, pos);
    }
  }, {
    key: "_getNodeInfo",
    value: function _getNodeInfo(ind, val, pos) {
      var o = {
        ind: ind,
        value: val,
        text: this._getFormatText(val, ind),
        //text是 format 后的数据
        x: pos,
        //这里不能直接用鼠标的x
        field: this.field,
        layoutType: this.layoutType
      };
      return o;
    }
  }, {
    key: "_trimXAxis",
    value: function _trimXAxis() {
      var tmpData = [];
      var data = this.dataSection;

      for (var a = 0, al = data.length; a < al; a++) {
        var text = this._formatTextSection[a];
        var txt = this._textElements[a];
        var o = {
          ind: a,
          value: data[a],
          text: text,
          x: this.getPosOf({
            val: data[a],
            ind: a
          }),
          textWidth: txt.getTextWidth(),
          field: this.field,
          visible: null //trimgrapsh的时候才设置

        };
        tmpData.push(o);
      }
      this.layoutData = tmpData;

      this._trimLayoutData();

      return tmpData;
    }
  }, {
    key: "_getFormatText",
    value: function _getFormatText(value, i) {
      if (this.label.format) {
        //如果有单独给label配置format，就用label上面的配置
        if (_.isFunction(this.label.format)) {
          value = this.label.format.apply(this, arguments);
        }

        if (typeof this.label.format == 'string') {
          value = (0, _numeral["default"])(value).format(this.label.format);
        }
      } else {
        //否则用fieldConfig上面的
        var config = this._coord.fieldsConfig[this.field];

        if (config) {
          value = this._coord.getFormatValue(value, config, i);
        }
      }
      return value;
    }
  }, {
    key: "_widget",
    value: function _widget(opt) {
      var _this2 = this;

      var me = this;
      !opt && (opt = {});

      if (!me.enabled) {
        me.height = 0; //width不能为0

        return;
      }
      var arr = me.layoutData;
      var visibleInd = 0;

      var _loop = function _loop(a, al) {
        _.isFunction(me.filter) && me.filter({
          layoutData: arr,
          index: a
        });
        var o = arr[a];

        if (!o.visible) {
          return "continue";
        }
        var x = o.x,
            y = me.tickLine.lineLength + me.tickLine.distance + me.label.distance;

        var _node = me.rulesSprite.getChildAt(visibleInd);

        var _getProp = function _getProp(prop) {
          var _prop = prop;

          if (_.isFunction(prop)) {
            _prop = prop.apply(_this2, [o, arr, a]);
          }
          return _prop;
        }; //文字 


        var textContext = {
          x: o._text_x || o.x,
          y: y,
          fillStyle: _getProp(_this2.label.fontColor),
          fontSize: _getProp(_this2.label.fontSize),
          rotation: -Math.abs(_this2.label.rotation),
          textAlign: _getProp(_this2.label.textAlign),
          lineHeight: _getProp(_this2.label.lineHeight),
          textBaseline: !!_this2.label.rotation ? "middle" : "top",
          globalAlpha: _getProp(_this2.label.alpha)
        };

        if (!!_this2.label.rotation && _this2.label.rotation != 90) {
          textContext.x += 5;
          textContext.y += 3;
        }

        var tickLineContext = {
          x: x,
          y: _this2.tickLine.distance,
          end: {
            x: 0,
            y: _this2.tickLine.lineLength
          },
          lineWidth: _this2.tickLine.lineWidth,
          strokeStyle: _this2.tickLine.strokeStyle
        };
        var duration = 300;
        var delay = visibleInd * Math.min(1000 / arr.length, 25);

        if (!me.animation || opt.resize) {
          duration = 0;
          delay = 0;
        }

        if (_node) {
          if (_node._tickLine && me.tickLine.enabled) {
            _node._tickLine.animate(tickLineContext, {
              duration: duration,
              id: _node._tickLine.id
            });
          }

          if (_node._txt && me.label.enabled) {
            _node._txt.animate(textContext, {
              duration: duration,
              id: _node._txt.id
            });

            _node._txt.resetText(o.text || '');
          }
        } else {
          _node = new _canvax["default"].Display.Sprite({
            id: "xNode" + visibleInd
          }); //新建line

          if (me.tickLine.enabled) {
            _node._tickLine = new Line({
              id: "xAxis_tickline_" + visibleInd,
              context: tickLineContext
            });

            _node.addChild(_node._tickLine);
          }

          if (me.label.enabled) {
            _node._txt = new _canvax["default"].Display.Text(o.text, {
              id: "xAxis_txt_" + visibleInd,
              context: textContext
            });

            _node.addChild(_node._txt); // TODO 后续x轴的动画要换成真实的动画效果，从画布外面移进来
            // if (me.animation && !opt.resize) {
            //     _node._txt.context.y += 20;
            //     _node._txt.context.globalAlpha = 0;
            //     _node._txt.animate( {
            //         y: textContext.y,
            //         globalAlpha: 1
            //     }, {
            //         duration: 500,
            //         delay: delay,
            //         id: _node._txt.id
            //     });
            // };

          }

          me.rulesSprite.addChild(_node);
        }
        visibleInd++;
      };

      for (var a = 0, al = arr.length; a < al; a++) {
        var _ret = _loop(a);

        if (_ret === "continue") continue;
      }

      if (this.rulesSprite.children.length >= visibleInd) {
        for (var _al = visibleInd, pl = this.rulesSprite.children.length; _al < pl; _al++) {
          this.rulesSprite.getChildAt(_al).remove();
          _al--, pl--;
        }
      }

      if (this.axisLine.enabled) {
        var _axisLineCtx = {
          start: {
            x: 0,
            y: 0
          },
          end: {
            x: this.width,
            y: 0
          },
          lineWidth: this.axisLine.lineWidth,
          strokeStyle: this.axisLine.strokeStyle
        };

        if (!this._axisLine) {
          var _axisLine = new Line({
            context: _axisLineCtx
          });

          this.sprite.addChild(_axisLine);
          this._axisLine = _axisLine;
        } else {
          this._axisLine.animate(_axisLineCtx);
        }
      }

      if (this._title) {
        this._title.context.y = this.height - this._title.getTextHeight() / 2;
        this._title.context.x = this.width / 2;
        this.sprite.addChild(this._title);
      }
    }
  }, {
    key: "_trimLayoutData",
    value: function _trimLayoutData() {
      var me = this;
      var arr = this.layoutData;
      var l = arr.length;
      if (!this.enabled || !l) return; // rule , peak, proportion

      if (me.layoutType == "proportion") {
        this._checkOver();
      }

      if (me.layoutType == "peak") {
        //TODO: peak暂时沿用 _checkOver ，这是保险的万无一失的。
        this._checkOver();
      }

      if (me.layoutType == "rule") {
        this._checkOver();
      }
    }
  }, {
    key: "_getRootPR",
    value: function _getRootPR() {
      //找到paddingRight,在最后一个文本右移的时候需要用到
      var rootPaddingRight = 0;

      if (this._coord.app) {
        rootPaddingRight = this._coord.app.padding.right;
      }
      return rootPaddingRight;
    }
  }, {
    key: "_checkOver",
    value: function _checkOver() {
      var me = this;
      var arr = me.layoutData;
      var l = arr.length;
      var textAlign = me.label.textAlign; //如果用户设置不想要做重叠检测

      if (!this.label.evade || me.trimLayout) {
        _.each(arr, function (layoutItem) {
          layoutItem.visible = true;
        });

        if (me.trimLayout) {
          //如果用户有手动的 trimLayout ，那么就全部visible为true，然后调用用户自己的过滤程序
          //trimLayout就事把arr种的每个元素的visible设置为true和false的过程
          me.trimLayout(arr);
        }
        //首先找到最后一个visible的label

        var lastNode;

        for (var i = l - 1; i >= 0; i--) {
          if (lastNode) break;
          if (arr[i].visible) lastNode = arr[i];
        }

        if (lastNode) {
          if (textAlign == "center" && lastNode.x + lastNode.textWidth / 2 > me.width) {
            lastNode._text_x = me.width - lastNode.textWidth / 2 + me._getRootPR();
          }

          if (textAlign == "left" && lastNode.x + lastNode.textWidth > me.width) {
            lastNode._text_x = me.width - lastNode.textWidth;
          }
        }
        return;
      }

      function checkOver(i) {
        var curr = arr[i];

        if (curr === undefined) {
          return;
        }
        curr.visible = true;

        for (var ii = i; ii < l - 1; ii++) {
          var next = arr[ii + 1];
          var nextWidth = next.textWidth;
          var currWidth = curr.textWidth; //如果有设置rotation，那么就固定一个最佳可视单位width为35  暂定

          if (!!me.label.rotation) {
            nextWidth = Math.min(nextWidth, 22);
            currWidth = Math.min(currWidth, 22);
          }

          var next_left_x = next.x; //下个节点的起始

          var curr_right_x = curr.x + currWidth; //当前节点的终点

          if (textAlign == "center") {
            next_left_x = next.x - nextWidth / 2;
            curr_right_x = curr.x + currWidth / 2;
          }

          if (textAlign == "right") {
            next_left_x = next.x - nextWidth;
            curr_right_x = curr.x;
          }

          if (ii == l - 2) {
            if (next_left_x + nextWidth > me.width + me._getRootPR()) {
              //只有最后一个溢出了，才需要检测
              //next是最后一个
              if (textAlign == "center" && next.x + nextWidth / 2 > me.width) {
                next_left_x = me.width - nextWidth;
                next._text_x = me.width - nextWidth / 2 + me._getRootPR();
              }

              if (textAlign == "left" && next.x + nextWidth > me.width) {
                next_left_x = me.width - nextWidth;
                next._text_x = me.width - nextWidth;
              }
            }
          }

          if (next_left_x - curr_right_x < 1) {
            if (ii == l - 2) {
              //最后一个的话，反把前面的给hide
              next.visible = true;
              curr.visible = false;
              return;
            } else {
              next.visible = false;
            }
          } else {
            checkOver(ii + 1);
            break;
          }
        }
      }
      checkOver(0);
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {};
    }
  }]);
  return xAxis;
}(_axis["default"]);

exports["default"] = xAxis;
});

unwrapExports(xaxis);

var yaxis = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);



var _axis = interopRequireDefault(axis);

var _numeral = interopRequireDefault(numeral);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._;
var Line = _canvax["default"].Shapes.Line;

var yAxis = /*#__PURE__*/function (_Axis) {
  (0, _inherits2["default"])(yAxis, _Axis);

  var _super = _createSuper(yAxis);

  function yAxis(opt, data, _coord) {
    var _this;

    (0, _classCallCheck2["default"])(this, yAxis);
    _this = _super.call(this, opt, data.org);
    _this.type = "yAxis";
    _this._coord = _coord || {};
    _this._title = null; //this.label对应的文本对象

    _this._axisLine = null;
    _this.maxW = 0; //最大文本的 width

    _this.pos = {
      x: 0,
      y: 0
    };
    _this.yMaxHeight = 0; //y轴最大高

    _this.layoutData = []; //dataSection 对应的layout数据{y:-100, value:'1000'}

    _this.sprite = null;
    _this.isH = false; //是否横向

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(yAxis.defaultProps()), opt);

    _this.init(opt);

    return _this;
  }

  (0, _createClass2["default"])(yAxis, [{
    key: "init",
    value: function init(opt) {
      this._setField();

      this._initHandle(opt);

      this.sprite = new _canvax["default"].Display.Sprite({
        id: "yAxisSprite_" + new Date().getTime()
      });
      this.rulesSprite = new _canvax["default"].Display.Sprite({
        id: "yRulesSprite_" + new Date().getTime()
      });
      this.sprite.addChild(this.rulesSprite);
    }
  }, {
    key: "_initHandle",
    value: function _initHandle(opt) {
      if (opt) {
        if (opt.isH && (!opt.label || opt.label.rotaion === undefined)) {
          //如果是横向直角坐标系图
          this.label.rotation = 90;
        }
        //除非用户强制设置textAlign，否则就要根据this.align做一次二次处理

        if (!opt.label || !opt.label.textAlign) {
          this.label.textAlign = this.align == "left" ? "right" : "left";
        }
      }
      this.setDataSection();

      this._getTitle();

      this._setYaxisWidth();
    }
  }, {
    key: "_setField",
    value: function _setField(field) {
      if (field) {
        this.field = field;
      }
      //先要矫正子啊field确保一定是个array

      if (!_.isArray(this.field)) {
        this.field = [this.field];
      }
    }
    /**
     * 
     * opt  pos,yMaxHeight,resize
     */

  }, {
    key: "draw",
    value: function draw(opt) {
      _.extend(true, this, opt || {});

      this.height = parseInt(this.yMaxHeight - this._getYAxisDisLine());
      this.setAxisLength(this.height);
      this.sprite.cleanAnimates();

      this._trimYAxis();

      this._widget(opt);

      this.setX(this.pos.x);
      this.setY(this.pos.y);
    } //配置和数据变化

  }, {
    key: "resetData",
    value: function resetData(dataFrame) {
      //如果用户没有指定width，那么resetData的时候需要清空一下width，用新的数据重新设置
      if (!('width' in this._opt)) {
        this.width = 0;
      }

      this._setField(dataFrame.field);

      this.resetDataOrg(dataFrame.org);

      this._initHandle();

      this.draw();
    }
  }, {
    key: "setX",
    value: function setX($n) {
      this.sprite.context.x = $n;
      this.pos.x = $n;
    }
  }, {
    key: "setY",
    value: function setY($n) {
      this.sprite.context.y = $n;
      this.pos.y = $n;
    } //目前和xAxis一样

  }, {
    key: "_getTitle",
    value: function _getTitle() {
      if (this.title.text) {
        if (!this._title) {
          var rotation = 0;

          if (this.align == "left") {
            rotation = -90;
          } else {
            rotation = 90;

            if (this.isH) {
              rotation = 270;
            }
          }
          this._title = new _canvax["default"].Display.Text(this.title.text, {
            context: {
              fontSize: this.title.fontSize,
              textAlign: this.title.textAlign,
              //"center",//this.isH ? "center" : "left",
              textBaseline: this.title.textBaseline,
              //"middle", //this.isH ? "top" : "middle",
              fillStyle: this.title.fontColor,
              strokeStyle: this.title.strokeStyle,
              lineWidth: this.title.lineWidth,
              rotation: rotation
            }
          });
        } else {
          this._title.resetText(this.title.text);
        }
      }
    }
  }, {
    key: "_setYaxisWidth",
    value: function _setYaxisWidth() {//待实现
    }
  }, {
    key: "_trimYAxis",
    value: function _trimYAxis() {
      var me = this;
      var tmpData = [];

      for (var i = 0, l = this.dataSection.length; i < l; i++) {
        var layoutData = {
          value: this.dataSection[i],
          y: -Math.abs(this.getPosOf({
            val: this.dataSection[i],
            ind: i
          })),
          visible: true,
          text: ""
        }; //把format提前

        layoutData.text = me._getFormatText(layoutData.value, i);
        tmpData.push(layoutData);
      }

      var _preShowInd = 0;

      for (var a = 0, al = tmpData.length; a < al; a++) {
        if (a == 0) continue;

        if (_preShowInd == 0) {
          if (tmpData[a].text == tmpData[_preShowInd].text) {
            //如果后面的format后的数据和前面的节点的format后数据相同
            tmpData[a].visible = false;
          } else {
            _preShowInd = a;
          }
        } else {
          if (tmpData[a].text == tmpData[_preShowInd].text) {
            tmpData[_preShowInd].visible = false;
          }

          _preShowInd = a;
        }
      }

      this.layoutData = tmpData;

      if (this.trimLayout) {
        //如果用户有手动的 trimLayout ，那么就全部visible为true，然后调用用户自己的过滤程序
        //trimLayout就事把arr种的每个元素的visible设置为true和false的过程
        this.trimLayout(tmpData);
      }
    }
  }, {
    key: "_getFormatText",
    value: function _getFormatText(value, i) {
      if (this.label.format) {
        //如果有单独给label配置format，就用label上面的配置
        if (_.isFunction(this.label.format)) {
          value = this.label.format.apply(this, arguments);
        }

        if (typeof this.label.format == 'string') {
          value = (0, _numeral["default"])(value).format(this.label.format);
        }
      } else {
        //否则用fieldConfig上面的, 因为y轴上面可能会汇集了多个field，那么只取在fieldsConfig上面配置过的第一个field即可
        var config;

        var _fields = _.flatten([this.field]);

        for (var _i = 0, l = _fields.length; _i < l; _i++) {
          config = this._coord.fieldsConfig[_fields[_i]];
          if (config) break;
        }

        if (config) {
          value = this._coord.getFormatValue(value, config, i);
        }
      }
      return value;
    }
  }, {
    key: "_getYAxisDisLine",
    value: function _getYAxisDisLine() {
      //获取y轴顶高到第一条线之间的距离         
      var disMin = 0;
      var disMax = 2 * disMin;
      var dis = disMin;
      dis = disMin + this.yMaxHeight % this.dataSection.length;
      dis = dis > disMax ? disMax : dis;
      return dis;
    }
  }, {
    key: "resetWidth",
    value: function resetWidth(width) {
      var me = this;
      me.width = width;

      if (me.align == "left") {
        me.rulesSprite.context.x = me.width;
      }
    }
  }, {
    key: "_widget",
    value: function _widget(opt) {
      var me = this;
      !opt && (opt = {});

      if (!me.enabled) {
        me.width = 0;
        return;
      }
      var arr = this.layoutData;
      var visibleInd = 0;
      me.maxW = 0;

      for (var a = 0, al = arr.length; a < al; a++) {
        _.isFunction(me.filter) && me.filter({
          layoutData: arr,
          index: a
        });
        var o = arr[a];

        if (!o.visible) {
          continue;
        }
        var y = o.y;
        var textAlign = me.label.textAlign;
        var posy = y + (a == 0 ? -3 : 0) + (a == arr.length - 1 ? 3 : 0); //为横向图表把y轴反转后的 逻辑

        if (me.label.rotation == 90 || me.label.rotation == -90) {
          textAlign = "center";

          if (a == arr.length - 1) {
            posy = y - 2;
            textAlign = "right";
          }

          if (a == 0) {
            posy = y;
          }
        }
        var aniFrom = 16;

        if (o.value == me.origin) {
          aniFrom = 0;
        }

        if (o.value < me.origin) {
          aniFrom = -16;
        }
        var lineX = 0;
        var tickLineContext = void 0;

        if (me.tickLine.enabled) {
          //线条
          lineX = me.align == "left" ? -me.tickLine.lineLength - me.tickLine.distance : me.tickLine.distance;
          tickLineContext = {
            x: lineX,
            y: y,
            end: {
              x: me.tickLine.lineLength,
              y: 0
            },
            lineWidth: me.tickLine.lineWidth,
            strokeStyle: me._getStyle(me.tickLine.strokeStyle)
          };
        }

        var textContext = void 0;

        if (me.label.enabled) {
          var txtX = me.align == "left" ? lineX - me.label.distance : lineX + me.tickLine.lineLength + me.label.distance;

          if (this.isH) {
            txtX = txtX + (me.align == "left" ? -1 : 1) * 4;
          }
          textContext = {
            x: txtX,
            y: posy,
            fillStyle: me._getStyle(me.label.fontColor),
            fontSize: me.label.fontSize,
            rotation: -Math.abs(me.label.rotation),
            textAlign: textAlign,
            textBaseline: "middle",
            lineHeight: me.label.lineHeight,
            globalAlpha: 1
          };
        }
        var duration = 300;

        if (!me.animation || opt.resize) {
          duration = 0;
        }

        var _node = this.rulesSprite.getChildAt(visibleInd);

        if (_node) {
          if (_node._tickLine && me.tickLine.enabled) {
            _node._tickLine.animate(tickLineContext, {
              duration: duration,
              id: _node._tickLine.id
            });
          }

          if (_node._txt && me.label.enabled) {
            _node._txt.animate(textContext, {
              duration: duration,
              id: _node._txt.id
            });

            _node._txt.resetText(o.text);
          }
        } else {
          _node = new _canvax["default"].Display.Sprite({
            id: "_node" + visibleInd
          }); //新建line

          if (me.tickLine.enabled) {
            _node._tickLine = new Line({
              id: "yAxis_tickline_" + visibleInd,
              context: tickLineContext
            });

            _node.addChild(_node._tickLine);
          }

          if (me.label.enabled) {
            _node._txt = new _canvax["default"].Display.Text(o.text, {
              id: "yAxis_txt_" + visibleInd,
              context: textContext
            });

            _node.addChild(_node._txt);

            if (me.animation && !opt.resize) {
              _node._txt.context.y = y + aniFrom;
              _node._txt.context.globalAlpha = 0;

              _node._txt.animate({
                y: textContext.y,
                globalAlpha: 1
              }, {
                duration: 300,
                id: _node._txt.id
              });
            }
          }
          me.rulesSprite.addChild(_node);
        }

        if (me.label.enabled) {
          if (me.label.rotation == 90 || me.label.rotation == -90) {
            me.maxW = Math.max(me.maxW, _node._txt.getTextHeight());
          } else {
            me.maxW = Math.max(me.maxW, _node._txt.getTextWidth());
          }
        }
        visibleInd++;
      }

      if (me.rulesSprite.children.length >= visibleInd) {
        for (var _al = visibleInd, pl = me.rulesSprite.children.length; _al < pl; _al++) {
          me.rulesSprite.getChildAt(_al).remove();
          _al--, pl--;
        }
      }

      if (!('width' in me._opt)) {
        var _preWidth = me.width;
        me.width = parseInt(me.maxW + me.label.distance);

        if (me.tickLine.enabled) {
          me.width += parseInt(me.tickLine.lineLength + me.tickLine.distance);
        }

        if (me._title) {
          me.width += me._title.getTextHeight();
        }

        if (me.width != _preWidth) ;
      }
      var _originX = 0;

      if (me.align == "left") {
        me.rulesSprite.context.x = me.width;
        _originX = me.width;
      }

      if (me.axisLine.enabled) {
        var _axisLineCtx = {
          start: {
            x: _originX,
            y: 0
          },
          end: {
            x: _originX,
            y: -me.height
          },
          lineWidth: me.axisLine.lineWidth,
          strokeStyle: me._getStyle(me.axisLine.strokeStyle)
        };

        if (!this._axisLine) {
          var _axisLine = new Line({
            context: _axisLineCtx
          });

          this.sprite.addChild(_axisLine);
          this._axisLine = _axisLine;
        } else {
          this._axisLine.animate(_axisLineCtx);
        }
      }

      if (this._title) {
        this._title.context.y = -this.height / 2;
        this._title.context.x = this._title.getTextHeight() / 2;

        if (this.align == "right") {
          this._title.context.x = this.width - this._title.getTextHeight() / 2;
        }
        this.sprite.addChild(this._title);
      }
    }
  }, {
    key: "_getStyle",
    value: function _getStyle(s) {
      var res = s;

      if (_.isFunction(s)) {
        res = s.call(this, this);
      }

      if (!s) {
        res = "#999";
      }
      return res;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        align: {
          detail: '左右轴设置',
          "default": 'left'
        },
        layoutType: {
          detail: '布局方式',
          "default": 'proportion'
        }
      };
    }
  }]);
  return yAxis;
}(_axis["default"]);

exports["default"] = yAxis;
});

unwrapExports(yaxis);

var grid = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Line = _canvax["default"].Shapes.Line;
var Rect = _canvax["default"].Shapes.Rect;

var rectGrid = /*#__PURE__*/function (_event$Dispatcher) {
  (0, _inherits2["default"])(rectGrid, _event$Dispatcher);

  var _super = _createSuper(rectGrid);

  function rectGrid(opt, _coord) {
    var _this;

    (0, _classCallCheck2["default"])(this, rectGrid);
    _this = _super.call(this, opt, _coord);

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(rectGrid.defaultProps()));

    _this.width = 0;
    _this.height = 0;
    _this._coord = _coord; //该组件被添加到的目标图表项目，

    _this.pos = {
      x: 0,
      y: 0
    };
    _this.sprite = null; //总的sprite

    _this.xAxisSp = null; //x轴上的线集合

    _this.yAxisSp = null; //y轴上的线集合

    _this.init(opt);

    return _this;
  }

  (0, _createClass2["default"])(rectGrid, [{
    key: "init",
    value: function init(opt) {
      _.extend(true, this, opt);

      this.sprite = new _canvax["default"].Display.Sprite();
    }
  }, {
    key: "setX",
    value: function setX($n) {
      this.sprite.context.x = $n;
    }
  }, {
    key: "setY",
    value: function setY($n) {
      this.sprite.context.y = $n;
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      _.extend(true, this, opt); //this._configData(opt);


      this._widget();

      this.setX(this.pos.x);
      this.setY(this.pos.y);
    }
  }, {
    key: "clean",
    value: function clean() {
      this.sprite.removeAllChildren();
    }
  }, {
    key: "reset",
    value: function reset(opt) {
      this.sprite.removeAllChildren();
      this.draw(opt);
    }
  }, {
    key: "_widget",
    value: function _widget() {
      var self = this;

      if (!this.enabled) {
        return;
      }
      var _yAxis = self._coord._yAxis[0];
      var _xAxis = self._coord._xAxis;
      this.fillSp = new _canvax["default"].Display.Sprite();
      this.sprite.addChild(this.fillSp);

      _.each([self.fill.xDimension, self.fill.yDimension], function (fill, ind) {
        var _axis = ind ? _yAxis : _xAxis;

        var splitVals = [];

        if (fill.enabled) {
          if (!fill.splitVals) {
            splitVals = _axis.dataSection;
          } else {
            splitVals = _.flatten([fill.splitVals]); // splitVals = [_axis.dataSection[0]].concat(_.flatten([fill.splitVals]));
            // let lastSectionVal = _axis.dataSection.slice(-1)[0];
            // if( splitVals.indexOf( lastSectionVal ) == -1 ){
            //   splitVals.push( lastSectionVal );
            // }
          }
          var fillRanges = [];

          if (splitVals.length) {
            //splitVals去重
            splitVals = _.uniq(splitVals);
            var range = [0];

            var _loop = function _loop(i, l) {
              var val = splitVals[i];

              var pos = _axis.getPosOf({
                val: val
              });

              if (range.length == 1) {
                //TODO: 目前轴的计算有bug， 超过的部分返回也是0
                // if( (
                //         splitVals.length == 1 || 
                //         (
                //             splitVals.length > 1 && 
                //             ( 
                //                 fillRanges.length && (fillRanges.slice(-1)[0][0] || fillRanges.slice(-1)[0][1] )
                //             ) 
                //         )
                //     ) && pos == 0 ){
                //     pos = self.width;
                // };
                if (!pos && _axis.type == 'xAxis' && _axis.layoutType == 'rule') {
                  var dataFrame = self._coord.app.dataFrame;

                  var orgData = _.find(dataFrame.jsonOrg, function (item) {
                    return item[_axis.field] == val;
                  });

                  if (orgData) {
                    var orgIndex = orgData.__index__;

                    if (orgIndex <= dataFrame.range.start) {
                      pos = 0;
                    }

                    if (orgIndex >= dataFrame.range.end) {
                      pos = self.width;
                    }
                  }
                }
                range.push(pos);
                fillRanges.push(range);
                var nextBegin = range[1];
                range = [nextBegin];
              }
            };

            for (var i = 0, l = splitVals.length; i < l; i++) {
              _loop(i, l);
            }

            _.each(fillRanges, function (range, rInd) {
              if (!range || range && range.length && range[1] == range[0]) return;
              var rectCtx = {
                fillStyle: self.getProp(fill.fillStyle, rInd, "#000"),
                fillAlpha: self.getProp(fill.alpha, rInd, 0.02 * (rInd % 2))
              };

              if (!ind) {
                //x轴上面排列的fill
                rectCtx.x = range[0];
                rectCtx.y = 0;
                rectCtx.width = range[1] - range[0];
                rectCtx.height = -self.height;
              } else {
                //y轴上面排列的fill
                rectCtx.x = 0;
                rectCtx.y = -range[0];
                rectCtx.width = self.width;
                rectCtx.height = -(range[1] - range[0]);
              }

              var fillRect = new Rect({
                context: rectCtx
              });
              self.fillSp.addChild(fillRect);

              var _text = self.getProp(fill.splitLabels, rInd, "");

              if (_text) {
                var fontColor = self.getProp(fill.fontColor, rInd, "#666");
                var fontSize = self.getProp(fill.fontSize, rInd, 12);
                var textAlign = 'center';
                var textBaseline = 'top';
                var x = rectCtx.x + rectCtx.width / 2;
                var y = rectCtx.height + 8;

                if (ind) {
                  //y轴上面排列的fill
                  textAlign = 'left';
                  textBaseline = 'middle';
                  x = rectCtx.x + 8;
                  y = rectCtx.y + rectCtx.height / 2;
                }

                var txt = new _canvax["default"].Display.Text(_text, {
                  context: {
                    fontSize: fontSize,
                    fillStyle: fontColor,
                    x: x,
                    y: y,
                    textAlign: textAlign,
                    //"center",//this.isH ? "center" : "left",
                    textBaseline: textBaseline //"middle", //this.isH ? "top" : "middle",

                  }
                });
                self.fillSp.addChild(txt);
              }
            });
          }
        }
      });

      self.xAxisSp = new _canvax["default"].Display.Sprite(), self.sprite.addChild(self.xAxisSp);
      self.yAxisSp = new _canvax["default"].Display.Sprite(), self.sprite.addChild(self.yAxisSp);
      var arr = _yAxis ? _yAxis.layoutData : [];

      for (var a = 0, al = arr.length; a < al; a++) {
        var o = arr[a];
        if (!o.visible) continue;
        var line = new Line({
          id: "back_line_" + a,
          context: {
            y: o.y,
            lineType: self.getProp(self.line.xDimension.lineType, a, 'solid'),
            lineWidth: self.getProp(self.line.xDimension.lineWidth, a, 1),
            strokeStyle: self.getProp(self.line.xDimension.strokeStyle, a, '#f0f0f0'),
            visible: true
          }
        });

        if (self.line.xDimension.enabled) {
          self.xAxisSp.addChild(line);
          line.context.start.x = 0;
          line.context.end.x = self.width;
        }
      }

      arr = _xAxis.layoutData;

      for (var _a = 0, _al = arr.length; _a < _al; _a++) {
        var _o = arr[_a];

        var _line = new Line({
          context: {
            x: _o.x,
            start: {
              x: 0,
              y: 0
            },
            end: {
              x: 0,
              y: -self.height
            },
            lineType: self.getProp(self.line.yDimension.lineType, _a, 'solid'),
            lineWidth: self.getProp(self.line.yDimension.lineWidth, _a, 1),
            strokeStyle: self.getProp(self.line.yDimension.strokeStyle, _a, '#f0f0f0'),
            visible: true
          }
        });

        if (self.line.yDimension.enabled) {
          self.yAxisSp.addChild(_line);
        }
      }
    }
  }, {
    key: "getProp",
    value: function getProp(prop, i, def) {
      var res = def;

      if (prop != null && prop != undefined) {
        if (_.isString(prop) || _.isNumber(prop)) {
          res = prop;
        }

        if (_.isFunction(prop)) {
          res = prop.apply(this, [i, def]);
        }

        if (_.isArray(prop)) {
          res = prop[i];
        }
      }
      return res;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        enabled: {
          detail: '是否开启grid绘制',
          "default": true
        },
        line: {
          detail: '网格线条配置',
          propertys: {
            xDimension: {
              detail: '一维方向的网格线',
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": true
                },
                data: [],
                lineType: {
                  detail: '线的样式，虚线或者实现',
                  "default": 'solid'
                },
                lineWidth: {
                  detail: '线宽',
                  "default": 1
                },
                strokeStyle: {
                  detail: '线颜色',
                  "default": '#e6e6e6'
                }
              }
            },
            yDimension: {
              detail: '二维方向的网格线',
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": false
                },
                data: [],
                lineType: {
                  detail: '线的样式，虚线或者实现',
                  "default": 'solid'
                },
                lineWidth: {
                  detail: '线宽',
                  "default": 1
                },
                strokeStyle: {
                  detail: '线颜色',
                  "default": '#f0f0f0'
                }
              }
            }
          }
        },
        fill: {
          detail: '背景色配置',
          propertys: {
            xDimension: {
              detail: '以为方向的背景色块，x方向',
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": false
                },
                splitVals: {
                  detail: "从x轴上面用来分割区块的vals",
                  "default": null //默认等于xaxis的dataSection

                },
                splitLabels: {
                  detail: "对应splitVals的文本",
                  "default": null
                },
                fontColor: {
                  detail: "对应splitLabels的文本颜色",
                  "default": null
                },
                fontSize: {
                  detail: "对应splitLabels的文本字体大小",
                  "default": null
                },
                fillStyle: {
                  detail: '背景颜色',
                  "default": null
                },
                alpha: {
                  detail: '背景透明度',
                  "default": null
                }
              }
            },
            yDimension: {
              detail: '以为方向的背景色块，y方向',
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": false
                },
                splitVals: {
                  detail: "从x轴上面用来分割区块的vals",
                  "default": null
                },
                splitLabels: {
                  detail: "对应splitVals的文本",
                  "default": null
                },
                fontColor: {
                  detail: "对应splitLabels的文本颜色",
                  "default": null
                },
                fontSize: {
                  detail: "对应splitLabels的文本字体大小",
                  "default": null
                },
                fillStyle: {
                  detail: '背景颜色',
                  "default": null
                },
                alpha: {
                  detail: '背景透明度',
                  "default": null
                }
              }
            }
          }
        }
      };
    }
  }]);
  return rectGrid;
}(event.Dispatcher);

exports["default"] = rectGrid;
});

unwrapExports(grid);

var trigger = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _createClass2 = interopRequireDefault(createClass$1);

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

/**
 * 每个组件中对外影响的时候，要抛出一个trigger对象
 * 上面的comp属性就是触发这个trigger的组件本身
 * params属性则是这次trigger的一些动作参数
 * 目前legend和datazoom组件都有用到
 */
var Trigger = /*#__PURE__*/(0, _createClass2["default"])(function Trigger(comp) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _classCallCheck2["default"])(this, Trigger);
  this.comp = comp;
  this.params = params;
});
exports["default"] = Trigger;
});

unwrapExports(trigger);

var rect = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _index = interopRequireDefault(coord);

var _canvax = interopRequireDefault(Canvax);

var _xaxis = interopRequireDefault(xaxis);

var _yaxis = interopRequireDefault(yaxis);

var _grid = interopRequireDefault(grid);



var _trigger = interopRequireDefault(trigger);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;

var Rect = /*#__PURE__*/function (_coordBase) {
  (0, _inherits2["default"])(Rect, _coordBase);

  var _super = _createSuper(Rect);

  function Rect(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, Rect);
    _this = _super.call(this, opt, app);

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(Rect.defaultProps()), _this.setDefaultOpt(opt, app));

    _this.type = "rect";
    _this._xAxis = null;
    _this._yAxis = [];
    _this._yAxisLeft = null;
    _this._yAxisRight = null;
    _this._grid = null;

    _this.init(opt);

    return _this;
  }

  (0, _createClass2["default"])(Rect, [{
    key: "setDefaultOpt",
    value: function setDefaultOpt(coordOpt, app) {
      var coord = {
        field: this.dataFrame.fields[0],
        xAxis: {
          //波峰波谷布局模型，默认是柱状图的，折线图种需要做覆盖
          layoutType: "rule",
          //"peak",  
          //默认为false，x轴的计量是否需要取整， 这样 比如某些情况下得柱状图的柱子间隔才均匀。
          //比如一像素间隔的柱状图，如果需要精确的绘制出来每个柱子的间距是1px， 就必须要把这里设置为true
          posParseToInt: false
        },
        grid: {}
      };

      _.extend(true, coord, coordOpt);

      if (coord.yAxis) {
        var _nyarr = []; //TODO: 因为我们的deep extend 对于数组是整个对象引用过去，所以，这里需要
        //把每个子元素单独clone一遍，恩恩恩， 在canvax中优化extend对于array的处理

        _.each(_.flatten([coord.yAxis]), function (yopt) {
          _nyarr.push(_.clone(yopt));
        });

        coord.yAxis = _nyarr;
      } else {
        coord.yAxis = [];
      }

      var graphsArr = app._opt.graphs ? _.flatten([app._opt.graphs]) : []; //有graphs的就要用找到这个graphs.field来设置coord.yAxis

      for (var i = 0; i < graphsArr.length; i++) {
        var graphs = graphsArr[i];

        if (graphs.type == "bar") {
          //如果graphs里面有柱状图，那么就整个xAxis都强制使用 peak 的layoutType
          coord.xAxis.layoutType = "peak";
        }

        if (graphs.field) {
          (function () {
            //没有配置field的话就不绘制这个 graphs了
            var align = "left"; //默认left

            if (graphs.yAxisAlign == "right") {
              align = "right";
            }
            var optsYaxisObj = null;
            optsYaxisObj = _.find(coord.yAxis, function (obj, i) {
              return obj.align == align || !obj.align && i == (align == "left" ? 0 : 1);
            });

            if (!optsYaxisObj) {
              optsYaxisObj = {
                align: align,
                field: []
              };
              coord.yAxis.push(optsYaxisObj);
            } else {
              if (!optsYaxisObj.align) {
                optsYaxisObj.align = align;
              }
            }

            if (!optsYaxisObj.field) {
              optsYaxisObj.field = [];
            } else {
              if (!_.isArray(optsYaxisObj.field)) {
                optsYaxisObj.field = [optsYaxisObj.field];
              }
            }

            if (_.isArray(graphs.field)) {
              optsYaxisObj.field = optsYaxisObj.field.concat(graphs.field);
            } else {
              optsYaxisObj.field.push(graphs.field);
            }
          })();
        }
      }
      //要手动把yAxis 按照 left , right的顺序做次排序

      var _lys = [],
          _rys = [];

      _.each(coord.yAxis, function (yAxis, i) {
        if (!yAxis.align) {
          yAxis.align = i ? "right" : "left";
        }

        if (yAxis.align == "left") {
          _lys.push(yAxis);
        } else {
          _rys.push(yAxis);
        }
      });

      coord.yAxis = _lys.concat(_rys);

      if (coord.horizontal) {
        coord.xAxis.isH = true;

        _.each(coord.yAxis, function (yAxis) {
          yAxis.isH = true;
        });
      }

      if ("enabled" in coord) {
        //如果有给直角坐标系做配置display，就直接通知到xAxis，yAxis，grid三个子组件
        _.extend(true, coord.xAxis, {
          enabled: coord.enabled
        });

        _.each(coord.yAxis, function (yAxis) {
          _.extend(true, yAxis, {
            enabled: coord.enabled
          });
        });

        coord.grid.enabled = coord.enabled;
      }

      if ("animation" in coord) {
        //如果有给直角坐标系做配置animation，就直接通知到xAxis，yAxis，grid三个子组件
        _.extend(true, coord.xAxis, {
          animation: coord.animation
        });

        _.each(coord.yAxis, function (yAxis) {
          _.extend(true, yAxis, {
            animation: coord.animation
          });
        });

        coord.grid.animation = coord.animation;
      }
      return coord;
    }
  }, {
    key: "init",
    value: function init() {
      this._initModules(); //创建好了坐标系统后，设置 _fieldsDisplayMap 的值，
      // _fieldsDisplayMap 的结构里包含每个字段是否在显示状态的enabled 和 这个字段属于哪个yAxis


      this.graphsFieldsMap = this.setGraphsFieldsMap({
        type: "yAxis"
      });
    }
  }, {
    key: "resetData",
    value: function resetData(dataFrame) {
      var me = this;
      var _padding = this.app.padding;
      var w = this._opt.width || this.app.width;
      this.dataFrame = dataFrame; // let _xAxisDataFrame = this.getAxisDataFrame(this.xAxis.field);
      // this._xAxis.resetData( _xAxisDataFrame );

      var _yAxisWAll = 0;
      var _leftYAxisW = 0;

      _.each(this._yAxis, function (_yAxis) {
        //这个_yAxis是具体的y轴实例
        var yAxisDataFrame = me.getAxisDataFrame(_yAxis.field);

        _yAxis.resetData(yAxisDataFrame);

        _yAxisWAll += _yAxis.width;

        if (_yAxis.align == 'left') {
          _leftYAxisW = _yAxis.width;
        }
      });

      var xAxisWidth = w - _yAxisWAll - _padding.left - _padding.right;
      this.width = xAxisWidth;

      var _xAxisDataFrame = this.getAxisDataFrame(this.xAxis.field);

      this._xAxis.resetData(_xAxisDataFrame, {
        width: xAxisWidth,
        pos: {
          x: _padding.left + _leftYAxisW //y : y

        }
      });

      this.origin.x = _leftYAxisW + _padding.left; //this.origin.y = y;

      this._resetXY_axisLine_pos();

      this._grid.reset({
        animation: false
      });
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      //在绘制的时候，要先拿到xAxis的高
      !opt && (opt = {});
      var _padding = this.app.padding;
      var h = opt.height || this.app.height;
      var w = opt.width || this.app.width;

      if (this.horizontal) {
        //如果是横向的坐标系统，也就是xy对调，那么高宽也要对调
        var _num = w;
        w = h;
        h = _num;
      }
      var y = h - this._xAxis.height - _padding.bottom;
      var _yAxisW = 0;
      var _yAxisRW = 0; //绘制yAxis

      if (this._yAxisLeft) {
        this._yAxisLeft.draw({
          pos: {
            x: _padding.left,
            y: y
          },
          yMaxHeight: y - _padding.top,
          resize: opt.resize
        });

        _yAxisW = this._yAxisLeft.width;
      } //如果有双轴


      if (this._yAxisRight) {
        this._yAxisRight.draw({
          pos: {
            x: 0,
            y: y
          },
          yMaxHeight: y - _padding.top,
          resize: opt.resize
        });

        _yAxisRW = this._yAxisRight.width;
      }

      this._xAxis.draw({
        pos: {
          x: _padding.left + _yAxisW,
          y: y
        },
        width: w - _yAxisW - _padding.left - _yAxisRW - _padding.right,
        resize: opt.resize
      });

      this._yAxisRight && this._yAxisRight.setX(_yAxisW + _padding.left + this._xAxis.width);
      this.width = this._xAxis.width;
      this.height = this._yAxis.length ? this._yAxis[0].height : 0;
      this.origin.x = _yAxisW + _padding.left;
      this.origin.y = y; //绘制背景网格

      this._grid.draw({
        width: this.width,
        height: this.height,
        pos: this.origin,
        resize: opt.resize
      });

      this._initInduce();

      this._resetXY_axisLine_pos();

      if (this.horizontal) {
        this._horizontal({
          w: w,
          h: h
        });
        /*
        let _padding = this.app.padding;
        this.width = this._yAxis[0].height;
        this.height = this._xAxis.width;
        this.origin.x = this._xAxis.height + _padding.left;
        this.origin.y = this._yAxis[0].height + _padding.top;
        */

      }
    }
  }, {
    key: "_resetXY_axisLine_pos",
    value: function _resetXY_axisLine_pos() {
      var me = this; //设置下x y 轴的 _axisLine轴线的位置，默认 axisLine.position==default

      var xAxisPosY;

      if (this._xAxis.enabled) {
        if (this._xAxis.axisLine.position == 'center') {
          xAxisPosY = -this._yAxis[0].height / 2;
        }

        if (this._xAxis.axisLine.position == 'center') {
          xAxisPosY = -this._yAxis[0].height / 2;
        }

        if (_.isNumber(this._xAxis.axisLine.position)) {
          xAxisPosY = -this._yAxis[0].getPosOfVal(this._xAxis.axisLine.position);
        }

        if (xAxisPosY !== undefined) {
          this._xAxis._axisLine.context.y = xAxisPosY;
        }
      }

      _.each(this._yAxis, function (_yAxis) {
        //这个_yAxis是具体的y轴实例
        var yAxisPosX;

        if (_yAxis.enabled) {
          if (_yAxis.axisLine.position == 'center') {
            yAxisPosX = me._xAxis.width / 2;
          }

          if (_.isNumber(_yAxis.axisLine.position)) {
            yAxisPosX = me._xAxis.getPosOfVal(_yAxis.axisLine.position);
          }

          if (yAxisPosX !== undefined) {
            _yAxis._axisLine.context.x = yAxisPosX;
          }
        }
      });
    }
  }, {
    key: "getSizeAndOrigin",
    value: function getSizeAndOrigin() {
      var obj = {
        width: this.width,
        height: this.height,
        origin: this.origin
      };

      if (this.horizontal) {
        var _padding = this.app.padding; //因为在drawBeginHorizontal中
        //横向了之后， 要把4个padding值轮换换过了
        //top,right 对调 ， bottom,left 对调
        //所以，这里要对调换回来给到origin

        var left = _padding.bottom;
        var top = _padding.right;
        obj = {
          width: this._yAxis[0].height,
          height: this._xAxis.width,
          origin: {
            x: this._xAxis.height + left,
            y: this._yAxis[0].height + top
          }
        };
      }
      return obj;
    }
  }, {
    key: "_initModules",
    value: function _initModules() {
      this._grid = new _grid["default"](this.grid, this);
      this.sprite.addChild(this._grid.sprite);

      var _xAxisDataFrame = this.getAxisDataFrame(this.xAxis.field);

      this._xAxis = new _xaxis["default"](this.xAxis, _xAxisDataFrame, this);

      this._axiss.push(this._xAxis);

      this.sprite.addChild(this._xAxis.sprite); //这里定义的是配置

      var yAxis = this.yAxis;
      var yAxisLeft, yAxisRight;
      var yAxisLeftDataFrame, yAxisRightDataFrame; // yAxis 肯定是个数组

      if (!_.isArray(yAxis)) {
        yAxis = [yAxis];
      }

      yAxisLeft = _.find(yAxis, function (ya) {
        return ya.align == "left";
      });

      if (yAxisLeft) {
        yAxisLeftDataFrame = this.getAxisDataFrame(yAxisLeft.field);
        this._yAxisLeft = new _yaxis["default"](yAxisLeft, yAxisLeftDataFrame, this);
        this._yAxisLeft.axis = yAxisLeft;
        this.sprite.addChild(this._yAxisLeft.sprite);

        this._yAxis.push(this._yAxisLeft);

        this._axiss.push(this._yAxisLeft);
      }

      yAxisRight = _.find(yAxis, function (ya) {
        return ya.align == "right";
      });

      if (yAxisRight) {
        yAxisRightDataFrame = this.getAxisDataFrame(yAxisRight.field);
        this._yAxisRight = new _yaxis["default"](yAxisRight, yAxisRightDataFrame, this);
        this._yAxisRight.axis = yAxisRight;
        this.sprite.addChild(this._yAxisRight.sprite);

        this._yAxis.push(this._yAxisRight);

        this._axiss.push(this._yAxisRight);
      }
    }
    /**
     * 
     * @param {x,y} size 
     */

  }, {
    key: "_horizontal",
    value: function _horizontal(opt) {
      var me = this;
      var w = opt.h;
      var h = opt.w;

      _.each([me.sprite.context], function (ctx) {
        ctx.x += (w - h) / 2;
        ctx.y += (h - w) / 2;
        var origin = {
          x: h / 2,
          y: w / 2
        };
        ctx.rotation = 90;
        ctx.rotateOrigin = origin;
      });
    } //由coor_base中得addField removeField来调用

  }, {
    key: "changeFieldEnabled",
    value: function changeFieldEnabled(field) {
      this.setFieldEnabled(field);
      var fieldConfig = this.getFieldConfig(field);

      var _axis = fieldConfig.yAxis || fieldConfig.rAxis;

      var enabledFields = this.getEnabledFieldsOf(_axis); //[ fieldConfig.yAxis.align ];

      _axis.resetData(this.getAxisDataFrame(enabledFields));

      this._resetXY_axisLine_pos(); //然后yAxis更新后，对应的背景也要更新


      this._grid.reset({
        animation: false
      });
    }
  }, {
    key: "_initInduce",
    value: function _initInduce() {
      var me = this;
      me.induce = new _canvax["default"].Shapes.Rect({
        id: "induce",
        context: {
          x: me.origin.x,
          y: me.origin.y - me.height,
          width: me.width,
          height: me.height,
          fillStyle: '#000000',
          globalAlpha: 0,
          cursor: 'pointer'
        }
      });

      if (!me.sprite.getChildById("induce")) {
        me.sprite.addChild(me.induce);
      }
      me.induce.on(event.types.get(), function (e) {
        //e.eventInfo = me._getInfoHandler(e);
        me.fire(e.type, e); //图表触发，用来处理Tips

        me.app.fire(e.type, e);
      });
    }
  }, {
    key: "getTipsInfoHandler",
    value: function getTipsInfoHandler(e) {
      //这里只获取xAxis的刻度信息;
      var induceX = e.point.x;

      if (e.target !== this.induce) {
        induceX = this.induce.globalToLocal(e.target.localToGlobal(e.point)).x;
      }

      var xNode = this._xAxis.getNodeInfoOfX(induceX);

      var obj = {
        xAxis: xNode,
        dimension_1: xNode,
        //和xAxis一致，， 极坐标也会有dimension_1
        title: xNode.text,
        //下面两个属性是所有坐标系统一的
        iNode: xNode.ind,
        nodes: [//遍历_graphs 去拿东西
        ]
      };

      if (e.eventInfo) {
        _.extend(true, obj, e.eventInfo); //把xNode信息写到eventInfo上面


        if (obj.xAxis) {
          e.eventInfo.xAxis = xNode;
        }
      }
      return obj;
    } //下面的方法是所有坐标系都要提供的方法，用来计算位置的， graphs里面会调用
    //return {pos {x,y}, value :{x,y}}

  }, {
    key: "getPoint",
    value: function getPoint(opt) {
      var point = {
        x: 0,
        y: undefined
      };
      var xaxisExp = {
        type: "xAxis"
      };
      var yaxisExp = {
        type: "yAxis",
        field: opt.field
      };

      var _xAxis = this.getAxis(xaxisExp);

      var _yAxis = this.getAxis(yaxisExp);

      var _iNode = opt.iNode || 0;

      var _value = opt.value; //x y 一般至少会带 yval过来

      if (!("x" in _value)) {
        //如果没有传xval过来，要用iNode去xAxis的org去取
        _value.x = _.flatten(_xAxis.dataOrg)[_iNode];
      }
      point.x = _xAxis.getPosOf({
        ind: _iNode,
        val: _value.x
      });
      var y = _value.y;

      if (!isNaN(y) && y !== null && y !== undefined && y !== "") {
        if (!!opt.vIndex) {
          //说明是堆叠的
          //要获取到对应Y轴的最小值， 如果最小值是大于0的，那么val要加上这个最小值
          if (_yAxis._min > 0) {
            y += _yAxis._min;
          }
        }

        point.y = -_yAxis.getPosOfVal(y);
      } else {
        point.y = undefined;
      }
      return {
        pos: point,
        value: _value
      };
    }
  }, {
    key: "getAxisOriginPoint",
    value: function getAxisOriginPoint(exp) {
      var _yAxis = this.getAxis(exp);

      return {
        pos: -_yAxis.originPos,
        value: _yAxis.origin
      };
    }
  }, {
    key: "getOriginPos",
    value: function getOriginPos(exp) {
      var xaxisExp = {
        type: "xAxis"
      };
      var yaxisExp = {
        type: "yAxis",
        field: exp.field
      };

      var _xAxis = this.getAxis(xaxisExp);

      var _yAxis = this.getAxis(yaxisExp);

      return {
        x: _xAxis.originPos,
        y: -_yAxis.originPos
      };
    } //某axis变化了后，对应的依附于该axis的graphs都要重新reset

  }, {
    key: "resetGraphsOfAxis",
    value: function resetGraphsOfAxis(axis) {
      var _this2 = this;

      var graphs = this.app.getGraphs();

      if (axis.type == 'yAxis') {
        graphs.forEach(function (graph) {
          if (graph.yAxisAlign == axis.align) {
            graph.resetData(null, new _trigger["default"](_this2));
          }
        });
      }
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        horizontal: {
          detail: '横向翻转坐标系',
          documentation: "横向翻转坐标系",
          insertText: "horizontal: ",
          "default": false,
          values: [true, false]
        },
        _props: {
          xAxis: _xaxis["default"],
          yAxis: _yaxis["default"],
          grid: _grid["default"]
        }
      };
    }
  }]);
  return Rect;
}(_index["default"]);

_index["default"].registerComponent(Rect, 'coord', 'rect');

var _default = Rect;
exports["default"] = _default;
});

unwrapExports(rect);

var grid$1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Line = _canvax["default"].Shapes.Line;
var Circle = _canvax["default"].Shapes.Circle;
var Polygon = _canvax["default"].Shapes.Polygon;

var polarGrid = /*#__PURE__*/function (_event$Dispatcher) {
  (0, _inherits2["default"])(polarGrid, _event$Dispatcher);

  var _super = _createSuper(polarGrid);

  function polarGrid(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, polarGrid);
    _this = _super.call(this, opt, app);
    _this.width = 0;
    _this.height = 0;
    _this.app = app; //该组件被添加到的目标图表项目，

    _this.pos = {
      x: 0,
      y: 0
    };
    _this.dataSection = [];
    _this.sprite = null; //总的sprite

    _this.induce = null; //最外层的那个网，用来触发事件

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(polarGrid.defaultProps()), opt);

    _this.init(opt);

    return _this;
  }

  (0, _createClass2["default"])(polarGrid, [{
    key: "init",
    value: function init() {
      this.sprite = new _canvax["default"].Display.Sprite();
    }
  }, {
    key: "setX",
    value: function setX($n) {
      this.sprite.context.x = $n;
    }
  }, {
    key: "setY",
    value: function setY($n) {
      this.sprite.context.y = $n;
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      _.extend(true, this, opt);

      this._widget();

      this.setX(this.pos.x);
      this.setY(this.pos.y);
    }
  }, {
    key: "clean",
    value: function clean() {
      this.sprite.removeAllChildren();
    }
  }, {
    key: "reset",
    value: function reset(opt) {
      /*
      this.sprite.removeAllChildren();
      this.draw( opt );
      */
    }
  }, {
    key: "_widget",
    value: function _widget() {
      var me = this;

      _.each(this.dataSection, function (num, i) {
        if (num) {
          var r = me.app.getROfNum(num);
          var points = me.app.getPointsOfR(r);
          var ctx = {
            //lineType : me.ring.lineType,
            lineWidth: me.ring.lineWidth,
            strokeStyle: me._getStyle(me.ring.strokeStyle, i - 1),
            //me.ring.strokeStyle,
            fillStyle: me._getStyle(me.ring.fillStyle, i - 1),
            fillAlpha: me.ring.fillAlpha
          };

          var _ring;

          var ringType = Circle;

          if (me.ring.shapeType == "circle") {
            ctx.r = r;
            _ring = new ringType({
              context: ctx
            });
          } else {
            ctx.pointList = [];

            _.each(points, function (point, i) {
              if (i < points.length) {
                ctx.pointList.push([point.x, point.y]);
              }
            });

            ringType = Polygon;
            _ring = new ringType({
              context: ctx
            });
          }
          me.sprite.addChildAt(_ring, 0);

          if (i == me.dataSection.length - 1) {
            ctx.fillAlpha = 0;
            ctx.fillStyle = "#ffffff";
            me.induce = new ringType({
              context: ctx
            });
            me.sprite.addChild(me.induce);
          }

          _.each(points, function (point) {
            var _line = new Line({
              context: {
                end: point,
                lineWidth: me.ring.lineWidth,
                strokeStyle: me.ring.strokeStyle
              }
            });

            me.sprite.addChild(_line);
          });
        }
      });
    }
  }, {
    key: "_getStyle",
    value: function _getStyle(color, i) {
      if (_.isArray(color)) {
        return color[i % color.length];
      }

      return color;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        enabled: {
          detail: '是否开启grid',
          "default": false
        },
        ring: {
          detail: '环背景线',
          propertys: {
            shapeType: {
              detail: '线的图形样式，默认poly，可选circle',
              "default": 'poly'
            },
            lineType: {
              detail: '线条样式，sold实线，dashed虚线',
              "default": 'sold'
            },
            lineWidth: {
              detail: '线宽',
              "default": 1
            },
            strokeStyle: {
              detail: '线颜色',
              "default": '#e5e5e5'
            },
            fillStyle: {
              detail: '环填充色,支持函数配置',
              "default": null
            },
            fillAlpha: {
              detail: '环填充的透明度',
              "default": 0.5
            }
          }
        },
        ray: {
          detail: '射线',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": true
            },
            lineWidth: {
              detail: '线宽',
              "default": 1
            },
            strokeStyle: {
              detail: '线颜色',
              "default": '#e5e5e5'
            }
          }
        }
      };
    }
  }]);
  return polarGrid;
}(event.Dispatcher);

exports["default"] = polarGrid;
});

unwrapExports(grid$1);

var polar = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _index = interopRequireDefault(coord);

var _canvax = interopRequireDefault(Canvax);

var _grid = interopRequireDefault(grid$1);

var _dataSection = interopRequireDefault(dataSection_1);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;

var Polar = /*#__PURE__*/function (_coordBase) {
  (0, _inherits2["default"])(Polar, _coordBase);

  var _super = _createSuper(Polar);

  function Polar(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, Polar);
    _this = _super.call(this, opt, app);
    _this.type = "polar";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(Polar.defaultProps()), _this.setDefaultOpt(opt, app));

    _this.init(opt);

    return _this;
  }

  (0, _createClass2["default"])(Polar, [{
    key: "setDefaultOpt",
    value: function setDefaultOpt(coordOpt, app) {
      var coord = {
        rAxis: {
          field: []
        },
        aAxis: {},
        grid: {}
      };

      _.extend(true, coord, coordOpt); //根据graphs.field 来 配置 coord.rAxis.field -------------------


      if (!_.isArray(coord.rAxis.field)) {
        coord.rAxis.field = [coord.rAxis.field];
      }

      var graphsArr = _.flatten([app._opt.graphs]); //有graphs的就要用找到这个graphs.field来设置coord.rAxis


      var arrs = [];

      _.each(graphsArr, function (graphs) {
        if (graphs.field) {
          //没有配置field的话就不绘制这个 graphs了
          var _fs = graphs.field;

          if (!_.isArray(_fs)) {
            _fs = [_fs];
          }
          arrs = arrs.concat(_fs);
        }
      });

      coord.rAxis.field = coord.rAxis.field.concat(arrs);

      if (coordOpt.aAxis && coordOpt.aAxis.field) {
        coord.aAxis.enabled = true;
      } else {
        //如果aAxis.field都没有的话，是没法绘制grid的，所以grid的enabled就是false
        coord.grid.enabled = false;
      }
      return coord;
    }
  }, {
    key: "init",
    value: function init() {
      this._initModules(); //创建好了坐标系统后，设置 _fieldsDisplayMap 的值，
      // _fieldsDisplayMap 的结构里包含每个字段是否在显示状态的enabled 和 这个字段属于哪个yAxis


      this.graphsFieldsMap = this.setGraphsFieldsMap({
        type: "rAxis"
      });
    }
  }, {
    key: "_initModules",
    value: function _initModules() {
      if (this.grid.enabled) {
        this._grid = new _grid["default"](this.grid, this);
        this.sprite.addChild(this._grid.sprite);
      }

      if (this.aAxis.enabled && this.grid.enabled) {
        this._aAxisScaleSp = new _canvax["default"].Display.Sprite({
          id: "aAxisScaleSp"
        });
        this.sprite.addChild(this._aAxisScaleSp);
      }

      this._axiss.push({
        type: "rAxis",
        field: this.rAxis.field
      });
    }
  }, {
    key: "draw",
    value: function draw(opt) {

      this._computeAttr();

      this.rAxis.dataSection = this._getRDataSection();
      this.aAxis.data = this.app.dataFrame.getFieldData(this.aAxis.field);

      this._setAAxisAngleList();

      if (this.grid.enabled) {
        this._grid.draw({
          pos: this.origin,
          width: this.width,
          height: this.height,
          dataSection: this.rAxis.dataSection
        }, this);

        if (this.aAxis.enabled) {
          this._drawAAxis();
        }

        this._initInduce();
      }
    }
  }, {
    key: "resetData",
    value: function resetData() {}
  }, {
    key: "changeFieldEnabled",
    value: function changeFieldEnabled(field) {
      this.setFieldEnabled(field);
      this.rAxis.dataSection = this._getRDataSection();
      this.aAxis.data = this.app.dataFrame.getFieldData(this.aAxis.field);

      if (this.grid.enabled) {
        this._grid.reset({
          dataSection: this.rAxis.dataSection
        }, this);
      }
    }
  }, {
    key: "_getRDataSection",
    value: function _getRDataSection() {
      var me = this; //如果用户有主动配置了dataSection,是不需要计算dataSection的
      //目前没有做堆叠的dataSection，后面有需要直接从yAxis的模块中拿

      if (this._opt.rAxis && this._opt.rAxis.dataSection) {
        return this._opt.rAxis.dataSection;
      }
      var arr = [];

      _.each(_.flatten([me.rAxis.field]), function (field) {
        arr = arr.concat(me.app.dataFrame.getFieldData(field));
      });

      arr.push(0);
      return _dataSection["default"].section(arr, 3);
    }
  }, {
    key: "_computeAttr",
    value: function _computeAttr() {
      var _r;

      var scaleXY = 1; //width/height 宽高比

      var _padding = this.app.padding;
      var rootWidth = this.app.width;
      var rootHeight = this.app.height;

      if (!("width" in this._opt)) {
        this.width = rootWidth - _padding.left - _padding.right;
      }

      if (!("height" in this._opt)) {
        this.height = rootHeight - _padding.top - _padding.bottom;
      }
      var vw = this.width;
      var vh = this.height; //然后根据allAngle startAngle来实现计算出这个polar的和模型 高宽比例
      //if( this.allAngle % 360 != 0 ){
      //360的polar高宽比例肯定是1：1的

      var sinTop = 0,
          sinBottom = 0,
          cosLeft = 0,
          cosRight = 0; //如果该坐标系并非一个整圆,那么圆心位置 需要对应的调整，才能铺满整个画布

      var angles = [this.startAngle];

      for (var i = 0, l = parseInt((this.startAngle + this.allAngle) / 90) - parseInt(this.startAngle / 90); i <= l; i++) {
        var angle = parseInt(this.startAngle / 90) * 90 + i * 90;

        if (_.indexOf(angles, angle) == -1 && angle > angles.slice(-1)[0]) {
          angles.push(angle);
        }
      }
      var lastAngle = this.startAngle + this.allAngle;

      if (_.indexOf(angles, lastAngle) == -1) {
        angles.push(lastAngle);
      }

      _.each(angles, function (angle) {
        angle = angle % 360;

        var _sin = Math.sin(angle * Math.PI / 180);

        if (angle == 180) {
          _sin = 0;
        }

        var _cos = Math.cos(angle * Math.PI / 180);

        if (angle == 270 || angle == 90) {
          _cos = 0;
        }
        sinTop = Math.min(sinTop, _sin);
        sinBottom = Math.max(sinBottom, _sin);
        cosLeft = Math.min(cosLeft, _cos);
        cosRight = Math.max(cosRight, _cos);
      });

      scaleXY = (Math.abs(cosLeft) + Math.abs(cosRight)) / (Math.abs(sinTop) + Math.abs(sinBottom));

      var _num = Math.min(vw, vh);

      if (scaleXY == 1) {
        vw = vh = _num;
      } else {
        var _w = vh * scaleXY;

        var _h = vw / scaleXY;

        if (_w > vw) {
          //如果超出了， 那么缩放height
          vh = _h;
        } else {
          vw = _w;
        }
      }
      var x = _padding.left + (this.width - vw) / 2;
      var y = _padding.top + (this.height - vh) / 2;
      this.origin = {
        x: x + vw * (cosLeft / (cosLeft - cosRight)),
        y: y + vh * (sinTop / (sinTop - sinBottom))
      };
      var distanceToLine = {
        top: this.origin.y - y,
        right: x + vw - this.origin.x,
        bottom: y + vh - this.origin.y,
        left: this.origin.x - x
      };
      var anglesRadius = []; //每个角度上面的和边线相交点到origin的距离，可以作为半径

      var quadrantLines = [["right", "bottom"], ["bottom", "left"], ["left", "top"], ["top", "right"]];

      _.each(angles, function (angle) {
        //判断这个angle在会和哪根边线相交
        angle = angle % 360;
        var quadrant = parseInt(angle / 90); //当前angle在第几象限，每个象限可能相交的边线不同

        var lines = quadrantLines[quadrant];

        if (angle % 90 == 0) {
          //说明在4个正方向，只会和一条边线有可能相交，而且垂直
          lines = [["right", "bottom", "left", "top"][quadrant]];
        }

        var _sin = Math.sin(angle * Math.PI / 180);

        if (angle == 180) {
          _sin = 0;
        }

        var _cos = Math.cos(angle * Math.PI / 180);

        if (angle == 270 || angle == 90) {
          _cos = 0;
        }

        _.each(lines, function (line) {
          var _r;

          if (line == "top" || line == "bottom") {
            //和上下边线的相交
            if (_sin) {
              // !_sin的话，不可能和上下边线相交的，平行
              _r = Math.abs(distanceToLine[line] / _sin);
            }
          }

          if (line == "right" || line == "left") {
            //和左右线的相交
            if (_cos) {
              // !_sin的话，不可能和左右边线相交的，平行
              _r = Math.abs(distanceToLine[line] / _cos);
            }
          }
          anglesRadius.push(_r);
        });
      });

      _r = _.min(anglesRadius); //};
      //如果有label，比如雷达图的label，要预留至少20，这个20现在是拍脑袋想的

      if (this.aAxis.label.enabled) {
        _r -= 20;
      }
      this.radius = _r;
    }
  }, {
    key: "getMaxDisToViewOfOrigin",
    value: function getMaxDisToViewOfOrigin() {
      var origin = this.origin;
      var _r = 0;
      var _padding = this.app.padding;
      var rootWidth = this.app.width;
      var rootHeight = this.app.height;
      var vw = rootWidth - _padding.left - _padding.right;
      var vh = rootHeight - _padding.top - _padding.bottom;
      var _distances = [origin.x - _padding.left, //原点到left的距离
      vw + _padding.left - origin.x, //原点到右边的距离
      origin.y - _padding.top, vh + _padding.top - origin.y];
      _r = _.max(_distances);
      return _r;
    } //获取极坐标系内任意半径上的弧度集合
    //[ [{point , radian} , {point , radian}] ... ]

  }, {
    key: "getRadiansAtR",
    value: function getRadiansAtR(r, width, height) {
      var me = this;

      if (width == undefined) {
        width = this.width;
      }

      if (height == undefined) {
        height = this.height;
      }
      var _rs = []; //if( r > maxRadius ){
      //    return [];
      //} else {
      //下面的坐标点都是已经origin为原点的坐标系统里
      //矩形的4边框线段

      var _padding = this.app.padding; //这个origin 是相对在width，height矩形范围内的圆心，
      //而this.origin 是在整个画布的位置

      var origin = {
        x: this.origin.x - _padding.left - (this.width - width) / 2,
        y: this.origin.y - _padding.top - (this.height - height) / 2
      };
      var x, y; //于上边界的相交点
      //最多有两个交点

      var distanceT = origin.y;

      if (distanceT < r) {
        x = Math.sqrt(Math.pow(r, 2) - Math.pow(distanceT, 2));
        _rs = _rs.concat(this._filterPointsInRect([{
          x: -x,
          y: -distanceT
        }, {
          x: x,
          y: -distanceT
        }], origin, width, height));
      }
      //最多有两个交点

      var distanceR = width - origin.x;

      if (distanceR < r) {
        y = Math.sqrt(Math.pow(r, 2) - Math.pow(distanceR, 2));
        _rs = _rs.concat(this._filterPointsInRect([{
          x: distanceR,
          y: -y
        }, {
          x: distanceR,
          y: y
        }], origin, width, height));
      }
      //最多有两个交点

      var distanceB = height - origin.y;

      if (distanceB < r) {
        x = Math.sqrt(Math.pow(r, 2) - Math.pow(distanceB, 2));
        _rs = _rs.concat(this._filterPointsInRect([{
          x: x,
          y: distanceB
        }, {
          x: -x,
          y: distanceB
        }], origin, width, height));
      }
      //最多有两个交点

      var distanceL = origin.x;

      if (distanceL < r) {
        y = Math.sqrt(Math.pow(r, 2) - Math.pow(distanceL, 2));
        _rs = _rs.concat(this._filterPointsInRect([{
          x: -distanceL,
          y: y
        }, {
          x: -distanceL,
          y: -y
        }], origin, width, height));
      }
      var arcs = []; //[ [{point , radian} , {point , radian}] ... ]
      //根据相交点的集合，分割弧段

      if (_rs.length == 0) {
        //说明整圆都在画布内
        //[ [0 , 2*Math.PI] ];
        arcs.push([{
          point: {
            x: r,
            y: 0
          },
          radian: 0
        }, {
          point: {
            x: r,
            y: 0
          },
          radian: Math.PI * 2
        }]);
      } else {
        //分割多段
        _.each(_rs, function (point, i) {
          var nextInd = i == _rs.length - 1 ? 0 : i + 1;

          var nextPoint = _rs.slice(nextInd, nextInd + 1)[0];

          arcs.push([{
            point: point,
            radian: me.getRadianInPoint(point)
          }, {
            point: nextPoint,
            radian: me.getRadianInPoint(nextPoint)
          }]);
        });
      }

      for (var i = 0, l = arcs.length; i < l; i++) {
        if (!this._checkArcInRect(arcs[i], r, origin, width, height)) {
          arcs.splice(i, 1);
          i--, l--;
        }
      }
      return arcs; //}
    }
  }, {
    key: "_filterPointsInRect",
    value: function _filterPointsInRect(points, origin, width, height) {
      for (var i = 0, l = points.length; i < l; i++) {
        if (!this._checkPointInRect(points[i], origin, width, height)) {
          //该点不在root rect范围内，去掉
          points.splice(i, 1);
          i--, l--;
        }
      }
      return points;
    }
  }, {
    key: "_checkPointInRect",
    value: function _checkPointInRect(p, origin, width, height) {
      var _tansRoot = {
        x: p.x + origin.x,
        y: p.y + origin.y
      };
      return !(_tansRoot.x < 0 || _tansRoot.x > width || _tansRoot.y < 0 || _tansRoot.y > height);
    } //检查由n个相交点分割出来的圆弧是否在rect内

  }, {
    key: "_checkArcInRect",
    value: function _checkArcInRect(arc, r, origin, width, height) {
      var start = arc[0];
      var to = arc[1];
      var differenceR = to.radian - start.radian;

      if (to.radian < start.radian) {
        differenceR = Math.PI * 2 + to.radian - start.radian;
      }
      var middleR = (start.radian + differenceR / 2) % (Math.PI * 2);
      return this._checkPointInRect(this.getPointInRadianOfR(middleR, r), origin, width, height);
    } //获取某个点相对圆心的弧度值

  }, {
    key: "getRadianInPoint",
    value: function getRadianInPoint(point) {
      var pi2 = Math.PI * 2;
      return (Math.atan2(point.y, point.x) + pi2) % pi2;
    } //获取某个弧度方向，半径为r的时候的point坐标点位置

  }, {
    key: "getPointInRadianOfR",
    value: function getPointInRadianOfR(radian, r) {
      var pi = Math.PI;
      var x = Math.cos(radian) * r;

      if (radian == pi / 2 || radian == pi * 3 / 2) {
        //90度或者270度的时候
        x = 0;
      }
      var y = Math.sin(radian) * r;

      if (radian % pi == 0) {
        y = 0;
      }
      return {
        x: x,
        y: y
      };
    } //获取这个num在dataSectio中对应的半径

  }, {
    key: "getROfNum",
    value: function getROfNum(num) {
      var r = 0;

      var maxNum = _.max(this.rAxis.dataSection);

      var minNum = 0; //let _r = parseInt( Math.min( this.width, this.height ) / 2 );

      var _r = this.radius;
      r = _r * ((num - minNum) / (maxNum - minNum));
      return r;
    } //获取在r的半径上面，沿aAxis的points

  }, {
    key: "getPointsOfR",
    value: function getPointsOfR(r) {
      var me = this;
      var points = [];

      _.each(me.aAxis.angleList, function (_a) {
        //弧度
        var _r = Math.PI * _a / 180;

        var point = me.getPointInRadianOfR(_r, r);
        points.push(point);
      });

      return points;
    }
  }, {
    key: "_setAAxisAngleList",
    value: function _setAAxisAngleList() {
      var me = this;
      me.aAxis.angleList = [];
      var aAxisArr = this.aAxis.data;

      if (this.aAxis.layoutType == "proportion") {
        aAxisArr = [];

        for (var i = 0, l = this.aAxis.data.length; i < l; i++) {
          aAxisArr.push(i);
        }
      }
      var allAngle = this.allAngle;
      var min = 0;

      var max = _.max(aAxisArr);

      if (this.aAxis.layoutType == "proportion") {
        max++;
      }

      _.each(aAxisArr, function (p) {
        //角度
        var _a = (allAngle * ((p - min) / (max - min)) + me.aAxis.beginAngle + allAngle) % allAngle;

        me.aAxis.angleList.push(_a);
      });
    }
  }, {
    key: "_drawAAxis",
    value: function _drawAAxis() {
      //绘制aAxis刻度尺
      var me = this;
      var r = me.getROfNum(_.max(this.rAxis.dataSection));
      var points = me.getPointsOfR(r + 3);
      me._aAxisScaleSp.context.x = this.origin.x;
      me._aAxisScaleSp.context.y = this.origin.y;

      _.each(this.aAxis.data, function (value, i) {
        var point = points[i];
        var text = _.isFunction(me.aAxis.label.format) ? me.aAxis.label.format(value) : value;
        var nodeData = {
          value: value,
          text: text,
          iNode: i,
          field: me.aAxis.field
        };

        var _enabled = me._getProp(me.aAxis.label.enabled, nodeData);

        if (!_enabled) return;
        var c = {
          x: point.x,
          y: point.y,
          fillStyle: me._getProp(me.aAxis.label.fontColor, nodeData)
        };

        _.extend(c, me._getTextAlignForPoint(Math.atan2(point.y, point.x)));

        me._aAxisScaleSp.addChild(new _canvax["default"].Display.Text(text, {
          context: c
        }));

        me.aAxis.layoutData.push(text);
      });
    }
    /**
     *把弧度分为4大块区域-90 --> 0 , 0-->90 , 90-->180, -180-->-90
     **/

  }, {
    key: "_getTextAlignForPoint",
    value: function _getTextAlignForPoint(r) {
      var textAlign = "center";
      var textBaseline = "bottom";
      /* 默认的就不用判断了
      if(r==-Math.PI/2){
          return {
              textAlign    : "center",
              textBaseline : "bottom"
          }
      }
      */

      if (r > -Math.PI / 2 && r < 0) {
        textAlign = "left";
        textBaseline = "bottom";
      }

      if (r == 0) {
        textAlign = "left";
        textBaseline = "middle";
      }

      if (r > 0 && r < Math.PI / 2) {
        textAlign = "left";
        textBaseline = "top";
      }

      if (r == Math.PI / 2) {
        textAlign = "center";
        textBaseline = "top";
      }

      if (r > Math.PI / 2 && r < Math.PI) {
        textAlign = "right";
        textBaseline = "top";
      }

      if (r == Math.PI || r == -Math.PI) {
        textAlign = "right";
        textBaseline = "middle";
      }

      if (r > -Math.PI && r < -Math.PI / 2) {
        textAlign = "right";
        textBaseline = "bottom";
      }

      return {
        textAlign: textAlign,
        textBaseline: textBaseline
      };
    }
  }, {
    key: "getAxisNodeOf",
    value: function getAxisNodeOf(e) {
      var me = this;
      var aAxisInd = me.getAAxisIndOf(e);

      if (aAxisInd === undefined) {
        return;
      }

      var node = {
        ind: aAxisInd,
        value: me.aAxis.data[aAxisInd],
        text: me.aAxis.layoutData[aAxisInd],
        angle: me.aAxis.angleList[aAxisInd]
      };
      return node;
    } //从event中计算出来这个e.point对应origin的index分段索引值

  }, {
    key: "getAAxisIndOf",
    value: function getAAxisIndOf(e) {
      var me = this;

      if (e.aAxisInd !== undefined) {
        return e.aAxisInd;
      }

      if (!me.aAxis.angleList.length) {
        return;
      }
      var point = e.point; //angle全部都换算到0-360范围内

      var angle = (me.getRadianInPoint(point) * 180 / Math.PI - me.aAxis.beginAngle) % me.allAngle; //let r = Math.sqrt( Math.pow( point.x, 2 ) + Math.pow( point.y, 2 ) );

      var aAxisInd = 0;
      var aLen = me.aAxis.angleList.length;

      _.each(me.aAxis.angleList, function (_a, i) {
        _a = (_a - me.aAxis.beginAngle) % me.allAngle;
        var nextInd = i + 1;
        var nextAngle = (me.aAxis.angleList[nextInd] - me.aAxis.beginAngle) % me.allAngle;

        if (i == aLen - 1) {
          nextInd = 0;
          nextAngle = me.allAngle;
        }

        if (angle >= _a && angle <= nextAngle) {
          //说明就再这个angle区间
          if (angle - _a < nextAngle - angle) {
            aAxisInd = i;
          } else {
            aAxisInd = nextInd;
          }

          return false;
        }
      });

      return aAxisInd;
    }
  }, {
    key: "_initInduce",
    value: function _initInduce() {
      var me = this;
      me.induce = this._grid.induce;
      me.induce && me.induce.on(event.types.get(), function (e) {
        me.fire(e.type, e); //图表触发，用来处理Tips

        me.app.fire(e.type, e);
      });
    }
  }, {
    key: "getTipsInfoHandler",
    value: function getTipsInfoHandler(e) {
      //这里只获取xAxis的刻度信息;
      var me = this;
      var aNode = me.getAxisNodeOf(e);
      var obj = {
        //aAxis : aNode,
        //title : aNode.label,
        //iNode : aNode.ind,
        nodes: [//遍历_graphs 去拿东西
        ]
      };

      if (aNode) {
        obj.aAxis = aNode;
        obj.title = aNode.text;
        obj.iNode = aNode.ind;
      }

      if (e.eventInfo) {
        obj = _.extend(obj, e.eventInfo);
      }
      return obj;
    } //TODO待实现

  }, {
    key: "getPoint",
    value: function getPoint() {}
  }, {
    key: "getSizeAndOrigin",
    value: function getSizeAndOrigin() {}
  }, {
    key: "_getProp",
    value: function _getProp(p, nodeData, def) {
      var res = p;

      if (_.isFunction(p)) {
        res = p.apply(this, [nodeData]);
      }

      if (!res && def) {
        res = def;
      }

      return res;
    } //某axis变化了后，对应的依附于该axis的graphs都要重新reset

  }, {
    key: "resetGraphsOfAxis",
    value: function resetGraphsOfAxis(axis) {
      var graphs = this.app.getGraphs();
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        allAngle: {
          detail: '坐标系总角度',
          documentation: "",
          "default": 360,
          values: [0, 360]
        },
        startAngle: {
          detail: '坐标系起始角度',
          documentation: "",
          "default": 0,
          values: [0, 360]
        },
        radius: {
          detail: '坐标系的最大半径',
          documentation: "默认自动计算view的高宽，如果squareRange==true，则会取Math.min(width,height)",
          "default": 'auto',
          values: null
        },
        aAxis: {
          detail: '角度轴',
          documentation: "类似直角坐标系中的x轴",
          propertys: {
            data: [],
            angleList: [],
            //对应layoutType下的角度list
            layoutData: [],
            //aAxis.data的 label.format后版本
            field: {
              detail: '数据字段',
              documentation: "",
              "default": ''
            },
            layoutType: {
              detail: '布局类型',
              documentation: "",
              "default": 'proportion'
            },
            beginAngle: {
              detail: '起始角度',
              documentation: "",
              "default": -90
            },
            enabled: {
              detail: '是否显示',
              documentation: "",
              "default": false
            },
            label: {
              detail: '文本配置',
              documentation: '',
              propertys: {
                enabled: {
                  detail: '是否显示',
                  documentation: "",
                  "default": true
                },
                format: {
                  detail: 'label的格式化处理函数',
                  documentation: "",
                  "default": null
                },
                fontColor: {
                  detail: 'label颜色',
                  documentation: '',
                  "default": "#666"
                }
              }
            }
          }
        },
        rAxis: {
          detail: '半径维度轴',
          documentation: '类似直角坐标系中的y轴维度',
          propertys: {
            field: {
              detail: '数据字段',
              documentation: "",
              "default": ''
            },
            dataSection: {
              detail: '轴的显示数据',
              documentation: "默认根据源数据中自动计算，用户也可以手动指定",
              "default": false
            },
            enabled: {
              detail: '是否显示',
              documentation: "",
              "default": false
            }
          }
        }
      };
    }
  }]);
  return Polar;
}(_index["default"]);

_index["default"].registerComponent(Polar, 'coord', 'polar');

var _default = Polar;
exports["default"] = _default;
});

unwrapExports(polar);

var arrayWithHoles = createCommonjsModule(function (module) {
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(arrayWithHoles);

var iterableToArrayLimit = createCommonjsModule(function (module) {
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(iterableToArrayLimit);

var arrayLikeToArray$1 = createCommonjsModule(function (module) {
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(arrayLikeToArray$1);

var unsupportedIterableToArray$1 = createCommonjsModule(function (module) {
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray$1(o, minLen);
}

module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(unsupportedIterableToArray$1);

var nonIterableRest = createCommonjsModule(function (module) {
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(nonIterableRest);

var slicedToArray = createCommonjsModule(function (module) {
function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray$1(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(slicedToArray);

var color = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.colorIsHex = colorIsHex;
exports.colorRgb = colorRgb;
exports.colorRgba = colorRgba;
exports.gradient = gradient;
exports.hex2rgb = hex2rgb;
exports.rgb2hex = rgb2hex;
exports.rgba2rgb = rgba2rgb;

var _slicedToArray2 = interopRequireDefault(slicedToArray);

//十六进制颜色值的正则表达式 
var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;

function colorIsHex(color) {
  return reg.test(color);
}
/*16进制颜色转为RGB格式*/


function colorRgb(hex) {
  if (Array.isArray(hex)) {
    hex = hex[0];
  }

  if (!hex) {
    return 'RGB(0,0,0)';
  }
  var sColor = hex.toLowerCase();

  if (sColor && reg.test(sColor)) {
    if (sColor.length === 4) {
      var sColorNew = "#";

      for (var i = 1; i < 4; i += 1) {
        sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
      }

      sColor = sColorNew;
    } //处理六位的颜色值  


    var sColorChange = [];

    for (var _i = 1; _i < 7; _i += 2) {
      sColorChange.push(parseInt("0x" + sColor.slice(_i, _i + 2)));
    }

    return "RGB(" + sColorChange.join(",") + ")";
  } else {
    return sColor;
  }
}

function colorRgba(hex, a) {
  return colorRgb(hex).replace(')', ',' + a + ')').replace('RGB', 'RGBA');
}

function hex2rgb(hex, out) {
  var rgb = [];

  for (var i = 1; i < 7; i += 2) {
    rgb.push(parseInt("0x" + hex.slice(i, i + 2)));
  }

  return rgb;
}

function rgb2hex(rgb) {
  var r = rgb[0];
  var g = rgb[1];
  var b = rgb[2];
  var hex = (r << 16 | g << 8 | b).toString(16);
  return "#" + new Array(Math.abs(hex.length - 7)).join("0") + hex;
}

function rgba2rgb(RGBA_color) {
  var background_color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "#ffffff";

  var _RGBA_color$match = RGBA_color.match(/[\d\.]+/g),
      _RGBA_color$match2 = (0, _slicedToArray2["default"])(_RGBA_color$match, 4),
      r = _RGBA_color$match2[0],
      g = _RGBA_color$match2[1],
      b = _RGBA_color$match2[2],
      a = _RGBA_color$match2[3];

  var _colorRgb$match = colorRgb(background_color).match(/[\d\.]+/g),
      _colorRgb$match2 = (0, _slicedToArray2["default"])(_colorRgb$match, 3),
      br = _colorRgb$match2[0],
      bg = _colorRgb$match2[1],
      bb = _colorRgb$match2[2];

  return "RGB(" + [(1 - a) * br + a * r, (1 - a) * bg + a * g, (1 - a) * bb + a * b].join(',') + ")";
} // 计算渐变过渡色


function gradient(startColor, endColor) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
  // 将 hex 转换为rgb
  var sColor = hex2rgb(startColor);
  var eColor = hex2rgb(endColor); // 计算R\G\B每一步的差值

  var rStep = (eColor[0] - sColor[0]) / step;
  var gStep = (eColor[1] - sColor[1]) / step;
  var bStep = (eColor[2] - sColor[2]) / step;
  var gradientColorArr = [];

  for (var i = 0; i < step; i++) {
    // 计算每一步的hex值
    gradientColorArr.push(rgb2hex([parseInt(rStep * i + sColor[0]), parseInt(gStep * i + sColor[1]), parseInt(bStep * i + sColor[2])]));
  }

  return gradientColorArr;
}
});

unwrapExports(color);
var color_1 = color.colorIsHex;
var color_2 = color.colorRgb;
var color_3 = color.colorRgba;
var color_4 = color.gradient;
var color_5 = color.hex2rgb;
var color_6 = color.rgb2hex;
var color_7 = color.rgba2rgb;

var graphs = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = interopRequireDefault(_typeof_1$1);

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var AnimationFrame = _canvax["default"].AnimationFrame;
var _ = _canvax["default"]._;

var GraphsBase = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(GraphsBase, _Component);

  var _super = _createSuper(GraphsBase);

  function GraphsBase(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, GraphsBase);
    _this = _super.call(this, opt, app); //这里不能把opt个extend进this

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(GraphsBase.defaultProps()));

    _this.name = "graphs"; //这里所有的opts都要透传给 group

    _this._opt = opt || {};
    _this.app = app;
    _this.ctx = app.stage.ctx || app.stage.canvas.getContext("2d");
    _this.dataFrame = app.dataFrame; //app.dataFrame的引用

    _this.data = null; //没个graphs中自己_trimGraphs的数据

    _this.width = 0;
    _this.height = 0;
    _this.origin = {
      x: 0,
      y: 0
    };
    _this.inited = false;
    _this.sprite = new _canvax["default"].Display.Sprite({
      name: "graphs_" + opt.type
    });

    _this.app.graphsSprite.addChild(_this.sprite);

    _this._growTween = null;
    var me = (0, _assertThisInitialized2["default"])(_this);

    _this.sprite.on("destroy", function () {
      if (me._growTween) {
        AnimationFrame.destroyTween(me._growTween);
        me._growTween = null;
      }
    });

    return _this;
  }

  (0, _createClass2["default"])(GraphsBase, [{
    key: "tipsPointerOf",
    value: function tipsPointerOf(e) {}
  }, {
    key: "tipsPointerHideOf",
    value: function tipsPointerHideOf(e) {}
  }, {
    key: "focusAt",
    value: function focusAt(ind, field) {}
  }, {
    key: "unfocusAt",
    value: function unfocusAt(ind, field) {}
  }, {
    key: "selectAt",
    value: function selectAt(ind, field) {}
  }, {
    key: "unselectAt",
    value: function unselectAt(ind, field) {} //获取选中的 数据点

  }, {
    key: "getSelectedList",
    value: function getSelectedList() {
      return [];
    } //获取选中的 列数据, 比如柱状图中的多分组，选中一列数据，则包函了这分组内的所有柱子

  }, {
    key: "getSelectedRowList",
    value: function getSelectedRowList() {
      return [];
    }
  }, {
    key: "hide",
    value: function hide(field) {}
  }, {
    key: "show",
    value: function show(field) {}
  }, {
    key: "getLegendData",
    value: function getLegendData() {} //触发事件, 事件处理函数中的this都指向对应的graphs对象。

  }, {
    key: "triggerEvent",
    value: function triggerEvent(e) {
      var _this2 = this;

      var trigger = e.eventInfo.trigger;

      if ((0, _typeof2["default"])(trigger) == 'object') ;

      if (typeof trigger == 'string') {
        if (trigger == 'this') {
          trigger = this;
        } else {
          var triggerList = trigger.split(".");
          triggerList.map(function (cur) {
            if (cur != 'this') {
              trigger = _this2[cur];
            }
          });
        }
      }

      if (!trigger) {
        //TODO 这里会有隐藏的bug， 比如连个line 一个line的node有onclick， 一个line的node.onclick没有但是有line.onclick 
        //当点击那个line.node的click的时候， 后面这个line的 click也会被触发，
        //这里直接先去掉了
        //trigger = this;
        return;
      }

      var fn = trigger["on" + e.type];

      if (fn && _.isFunction(fn)) {
        //如果有在pie的配置上面注册对应的事件，则触发
        if (e.eventInfo && e.eventInfo.nodes && e.eventInfo.nodes.length) {
          //完整的nodes数据在e.eventInfo中有，但是添加第二个参数，如果nodes只有一个数据就返回单个，多个则数组
          if (e.eventInfo.nodes.length == 1) {
            fn.apply(this, [e, e.eventInfo.nodes[0]]);
          } else {
            fn.apply(this, [e, e.eventInfo.nodes]);
          }
        } else {
          /*
          let _arr = [];
          _.each( arguments, function(item, i){
              if( !!i ){
                  _arr.push( item );
              }
          } );
          */
          fn.apply(this, arguments);
        }
      }
    } //所有graphs默认的grow

  }, {
    key: "grow",
    value: function grow(callback, opt) {
      !opt && (opt = {});
      var me = this;
      var duration = this.aniDuration;

      if (!this.animation) {
        duration = 0;
      }
      var from = 0;
      var to = 1;
      if ("from" in opt) from = opt.from;
      if ("to" in opt) to = opt.to;
      this._growTween = AnimationFrame.registTween({
        from: {
          process: from
        },
        to: {
          process: to
        },
        duration: duration,
        easing: this.aniEasing,
        onUpdate: function onUpdate(status) {
          _.isFunction(callback) && callback(status.process);
        },
        onComplete: function onComplete() {
          this._growTween = null;
          me.fire("complete");
        }
      });
    }
  }, {
    key: "getFieldConfig",
    value: function getFieldConfig(field) {
      return this.app.getComponent({
        name: 'coord'
      }).getFieldConfig(field);
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        type: {
          detail: '绘图组件',
          "default": "",
          insertText: "type: ",
          values: ["bar", "line", "pie", "scat"] //具体的在index中批量设置，

        },
        animation: {
          detail: '是否开启入场动画',
          "default": true
        },
        aniDuration: {
          detail: '动画时长',
          "default": 800
        },
        aniEasing: {
          detail: '折线生长动画的动画类型参数，默认 Linear.None',
          documentation: '类型演示https://sole.github.io/tween.js/examples/03_graphs.html',
          "default": 'Linear.None'
        },
        color: {
          detail: 'line,area,node,label的抄底样式',
          "default": ''
        }
      };
    }
  }]);
  return GraphsBase;
}(_component["default"]);

exports["default"] = GraphsBase;
});

unwrapExports(graphs);

var bar = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);





var _index2 = interopRequireDefault(graphs);

var _numeral = interopRequireDefault(numeral);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var AnimationFrame = _canvax["default"].AnimationFrame;
var Rect = _canvax["default"].Shapes.Rect;

var BarGraphs = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(BarGraphs, _GraphsBase);

  var _super = _createSuper(BarGraphs);

  function BarGraphs(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, BarGraphs);
    _this = _super.call(this, opt, app);
    _this.type = "bar";
    _this.enabledField = null;
    _this.node = {
      _width: 0,
      _count: 0 //总共有多少个bar

    }; //分组的选中，不是选中具体的某个node，这里的选中靠groupRegion来表现出来
    //只有在第一个graphs bar 上配置有效

    _this.select = {
      _fillStyle: "#092848" //和bar.fillStyle一样可以支持array function

    };
    _this._barsLen = 0;
    _this.txtsSp = null;

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(BarGraphs.defaultProps()), opt);

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(BarGraphs, [{
    key: "init",
    value: function init() {
      this.barsSp = new _canvax["default"].Display.Sprite({
        id: "barsSp"
      });
      this.txtsSp = new _canvax["default"].Display.Sprite({
        id: "txtsSp",
        context: {//visible: false
        }
      });
    }
  }, {
    key: "getNodesAt",
    value: function getNodesAt(index) {
      //该index指当前
      var data = this.data;
      var _nodesInfoList = []; //节点信息集合

      _.each(this.enabledField, function (fs) {
        if (_.isArray(fs)) {
          _.each(fs, function (_fs) {
            //fs的结构两层到顶了
            var nodeData = data[_fs] ? data[_fs][index] : null;
            nodeData && _nodesInfoList.push(nodeData);
          });
        } else {
          var nodeData = data[fs] ? data[fs][index] : null;
          nodeData && _nodesInfoList.push(nodeData);
        }
      });

      return _nodesInfoList;
    }
  }, {
    key: "_getTargetField",
    value: function _getTargetField(b, v, i, field) {
      if (_.isString(field)) {
        return field;
      } else if (_.isArray(field)) {
        var res = field[b];

        if (_.isString(res)) {
          return res;
        } else if (_.isArray(res)) {
          return res[v];
        }
      }
    }
  }, {
    key: "_getColor",
    value: function _getColor(color, nodeData) {
      var field = nodeData.field;

      var _flattenField = _.flatten([this.field]);

      var fieldConfig = this.app.getComponent({
        name: 'coord'
      }).getFieldConfig(field);

      if (_.isFunction(color)) {
        color = color.apply(this, [nodeData]);
      }

      if (_.isString(color)) ;

      if (_.isArray(color)) {
        color = _.flatten(color)[_.indexOf(_flattenField, field)];
      }

      if (color && color.lineargradient && color.lineargradient.length) {
        //如果是个线性渐变的话，就需要加上渐变的位置
        color.points = [0, nodeData.rectHeight, 0, 0];
      }

      if (color === undefined || color === null) {
        //只有undefined(用户配置了function),null才会认为需要还原皮肤色
        //“”都会认为是用户主动想要设置的，就为是用户不想他显示
        color = fieldConfig.color;
      }
      return color;
    }
  }, {
    key: "_getProp",
    value: function _getProp(s, node) {
      if (_.isFunction(s)) {
        var _nodesInfo = [];

        if (node != undefined) {
          _nodesInfo.push(node);
        }
        return s.apply(this, _nodesInfo);
      }
      return s;
    }
  }, {
    key: "_getBarWidth",
    value: function _getBarWidth(cellWidth, ceilWidth2) {
      if (this.node.width) {
        if (_.isFunction(this.node.width)) {
          this.node._width = this.node.width(cellWidth);
        } else {
          this.node._width = this.node.width;
        }
      } else {
        this.node._width = ceilWidth2 - Math.max(1, ceilWidth2 * 0.2); //这里的判断逻辑用意已经忘记了，先放着， 有问题在看

        if (this.node._width == 1 && cellWidth > 3) {
          this.node._width = cellWidth - 2;
        }
      }
      this.node._width < 1 && (this.node._width = 1);
      this.node._width = parseInt(this.node._width);

      if (this.node._width > this.node.maxWidth) {
        this.node._width = this.node.maxWidth;
      }
      return this.node._width;
    }
  }, {
    key: "show",
    value: function show() {
      this.draw();
    }
  }, {
    key: "hide",
    value: function hide(field) {
      _.each(this.barsSp.children, function (h_groupSp, h) {
        var _bar = h_groupSp.getChildById("bar_" + h + "_" + field);

        _bar && _bar.destroy();
      });

      _.each(this.txtsSp.children, function (sp, h) {
        var _label = sp.getChildById("text_" + h + "_" + field);

        _label && _label.destroy();
      });

      this.draw();
    }
  }, {
    key: "resetData",
    value: function resetData(dataFrame) {
      if (dataFrame) {
        this.dataFrame = dataFrame;
      }
      this.draw();
    }
  }, {
    key: "clean",
    value: function clean() {
      this.data = {};
      this.barsSp.removeAllChildren();

      if (this.label.enabled) {
        this.txtsSp.removeAllChildren();
      }
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {}); //第二个data参数去掉，直接trimgraphs获取最新的data

      _.extend(true, this, opt);

      var me = this;
      var animate = me.animation && !opt.resize;
      this.data = this._trimGraphs();

      if (this.enabledField.length == 0 || this._dataLen == 0) {
        me._preDataLen = 0;
        this.clean();
        return;
      }
      var preDataLen = me._preDataLen; //纵向的分组，主要用于 resetData 的时候，对比前后data数量用

      var groupsLen = this.enabledField.length;
      var itemW = 0;
      me.node._count = 0;
      var preGraphs = 0;
      var barGraphs = me.app.getComponents({
        name: 'graphs',
        type: 'bar'
      });

      _.each(barGraphs, function (graph, i) {
        if (graph == me) {
          preGraphs = i;
        }
      });

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      _.each(this.enabledField, function (h_group, i) {
        h_group = _.flatten([h_group]);
        /*
        //h_group为横向的分组。如果yAxis.field = ["uv","pv"]的话，
        //h_group就会为两组，一组代表uv 一组代表pv。
        let spg = new Canvax.Display.Sprite({ id : "barGroup"+i });
        */
        //vLen 为一单元bar上面纵向堆叠的 length
        //比如yAxis.field = [?
        //    ["uv","pv"],  vLen == 2
        //    "ppc"       vLen == 1
        //]
        //if (h <= preDataLen - 1)的话说明本次绘制之前sprite里面已经有bar了。需要做特定的动画效果走过去

        var vLen = h_group.length;
        if (vLen == 0) return; //itemW 还是要跟着xAxis的xDis保持一致

        itemW = me.width / me._dataLen;
        me._barsLen = me._dataLen * groupsLen; // this bind到了 对应的元素上面

        function barGroupSectedHandle(e) {
          if (me.select.enabled && me.select.triggerEventType.indexOf(e.type) > -1) {
            //如果开启了图表的选中交互
            var ind = me.dataFrame.range.start + this.iNode; //region触发的selected，需要把所有的graphs都执行一遍

            if (_.indexOf(me.select.inds, ind) > -1) {
              //说明已经选中了
              _.each(barGraphs, function (barGraph) {
                barGraph.unselectAt(ind);
              });
            } else {
              _.each(barGraphs, function (barGraph) {
                barGraph.selectAt(ind);
              });
            }
          }
        }

        for (var h = 0; h < me._dataLen; h++) {
          //bar的group
          var groupH = null;

          if (i == 0) {
            //横向的分组
            if (h <= preDataLen - 1) {
              groupH = me.barsSp.getChildById("barGroup_" + h);
            } else {
              groupH = new _canvax["default"].Display.Sprite({
                id: "barGroup_" + h
              });
              me.barsSp.addChild(groupH);
              groupH.iNode = h;
            }

            if (!preGraphs) {
              //只有preGraphs == 0，第一组graphs的时候才需要加载这个region
              //这个x轴单元 nodes的分组，添加第一个rect用来接受一些事件处理
              //以及显示selected状态
              var groupRegion = void 0;
              var groupRegionWidth = itemW * me.select.width;

              if (me.select.width > 1) {
                //说明是具体指
                groupRegionWidth = me.select.width;
              }

              if (h <= preDataLen - 1) {
                groupRegion = groupH.getChildById("group_region_" + h);
                groupRegion.context.width = groupRegionWidth;
                groupRegion.context.x = itemW * h + (itemW - groupRegionWidth) / 2;
                groupRegion.context.globalAlpha = _.indexOf(me.select.inds, me.dataFrame.range.start + h) > -1 ? me.select.alpha : 0;
              } else {
                groupRegion = new Rect({
                  id: "group_region_" + h,
                  pointChkPriority: false,
                  hoverClone: false,
                  xyToInt: false,
                  context: {
                    x: itemW * h + (itemW - groupRegionWidth) / 2,
                    y: -me.height,
                    width: groupRegionWidth,
                    height: me.height,
                    fillStyle: me._getGroupRegionStyle(h),
                    globalAlpha: _.indexOf(me.select.inds, me.dataFrame.range.start + h) > -1 ? me.select.alpha : 0
                  }
                });
                groupH.addChild(groupRegion);
                groupRegion.iNode = h; //触发注册的事件

                groupRegion.on(event.types.get(), function (e) {
                  e.eventInfo = {
                    trigger: me,
                    iNode: this.iNode //TODO:这里设置了的话，会导致多graphs里获取不到别的graphs的nodes信息了
                    //nodes : me.getNodesAt( this.iNode ) 

                  };
                  barGroupSectedHandle.bind(this)(e); //触发root统一设置e.eventInfo.nodes,所以上面不需要设置

                  me.app.fire(e.type, e);
                });
              }
            }
          } else {
            groupH = me.barsSp.getChildById("barGroup_" + h);
          }

          var txtGroupH = null;

          if (i == 0) {
            if (h <= preDataLen - 1) {
              txtGroupH = me.txtsSp.getChildById("txtGroup_" + h);
            } else {
              txtGroupH = new _canvax["default"].Display.Sprite({
                id: "txtGroup_" + h
              });
              me.txtsSp.addChild(txtGroupH);
              txtGroupH.iGroup = i;
            }
          } else {
            txtGroupH = me.txtsSp.getChildById("txtGroup_" + h);
          }

          for (var v = 0; v < vLen; v++) {
            me.node._count++; //单个的bar，从纵向的底部开始堆叠矩形

            var nodeData = me.data[h_group[v]][h];
            nodeData.iGroup = i, nodeData.iNode = h, nodeData.iLay = v;
            var rectHeight = nodeData.y - nodeData.fromY;

            if (isNaN(nodeData.value)) {
              rectHeight = 0;
            } else {
              if (Math.abs(rectHeight) < Math.abs(me.node.minHeight)) {
                rectHeight = -me.node.minHeight;
              }
            }
            nodeData.rectHeight = rectHeight;

            var fillStyle = me._getColor(me.node.fillStyle, nodeData);

            nodeData.color = fillStyle; //如果用户配置了渐变， 那么tips里面就取对应的中间位置的颜色
            //fillStyle instanceof CanvasGradient 在小程序里会出错。改用fillStyle.addColorStop来嗅探

            if (fillStyle.addColorStop) {
              if (me.node.fillStyle.lineargradient) {
                var _middleStyle = me.node.fillStyle.lineargradient[parseInt(me.node.fillStyle.lineargradient.length / 2)];

                if (_middleStyle) {
                  nodeData.color = _middleStyle.color;
                }
              }
            }
            var finalPos = {
              x: Math.round(nodeData.x),
              y: nodeData.fromY,
              width: me.node._width,
              height: rectHeight,
              fillStyle: fillStyle,
              fillAlpha: me.node.fillAlpha,
              scaleY: -1
            };
            nodeData.width = finalPos.width;

            var rectFill = me._getFillStyle(finalPos.fillStyle, finalPos);

            var rectCtx = {
              x: finalPos.x,
              y: nodeData.yOriginPoint.pos,
              //0,
              width: finalPos.width,
              height: finalPos.height,
              fillStyle: rectFill,
              fillAlpha: me.node.fillAlpha,
              scaleY: 0,
              cursor: 'pointer'
            };

            if (!!me.node.radius && nodeData.isLeaf && !me.proportion) {
              var radiusR = Math.min(me.node._width / 2, Math.abs(rectHeight));
              radiusR = Math.min(radiusR, me.node.radius);
              rectCtx.radius = [radiusR, radiusR, 0, 0];
            }

            if (!animate) {
              delete rectCtx.scaleY;
              rectCtx.y = finalPos.y;
            }
            var rectEl = null;
            var barId = "bar_" + h + "_" + nodeData.field;

            if (h <= preDataLen - 1) {
              rectEl = groupH.getChildById(barId);
            }

            if (rectEl) {
              rectEl.context.fillStyle = fillStyle;
            } else {
              rectEl = new Rect({
                id: barId,
                context: rectCtx
              });
              rectEl.field = nodeData.field;
              groupH.addChild(rectEl); //是否在单个柱子上面启动事件监听

              if (me.node.eventEnabled) {
                rectEl.on(event.types.get(), function (e) {
                  e.eventInfo = {
                    trigger: 'this.node',
                    //me.node,
                    nodes: [this.nodeData]
                  };
                  barGroupSectedHandle.bind(this)(e);
                  me.app.fire(e.type, e);
                });
              }
            }
            rectEl.finalPos = finalPos;
            rectEl.iGroup = i, rectEl.iNode = h, rectEl.iLay = v; //nodeData, nodeElement ， data和图形之间互相引用的属性约定

            rectEl.nodeData = nodeData;
            nodeData.nodeElement = rectEl;
            me.node.filter && me.node.filter.apply(rectEl, [nodeData, me]); //label begin ------------------------------

            if (me.label.enabled) {
              var value = nodeData.value;

              if (me.label.format) {
                if (_.isFunction(me.label.format)) {
                  var _formatc = me.label.format.apply(me, [value, nodeData]);

                  if (_formatc !== undefined || _formatc !== null) {
                    value = _formatc;
                  }
                }

                if (typeof me.label.format == 'string') {
                  value = (0, _numeral["default"])(value).format(me.label.format);
                }
              } else {
                //否则用fieldConfig上面的
                var fieldConfig = _coord.getFieldConfig(nodeData.field);

                if (fieldConfig) {
                  value = fieldConfig.getFormatValue(value);
                }
              }

              if (value === undefined || value === null || value === "") {
                continue;
              }
              var textCtx = {
                fillStyle: me._getProp(me.label.fontColor, nodeData) || finalPos.fillStyle,
                fontSize: me._getProp(me.label.fontSize, nodeData),
                lineWidth: me._getProp(me.label.lineWidth, nodeData),
                strokeStyle: me._getProp(me.label.strokeStyle, nodeData) || finalPos.fillStyle,
                //textAlign     : me.label.textAlign, 在后面的_getTextAlign中设置
                textBaseline: me._getProp(me.label.verticalAlign, nodeData),
                rotation: me._getProp(me.label.rotation, nodeData)
              }; //然后根据position, offset确定x,y

              var _textPos = me._getTextPos(finalPos, nodeData);

              textCtx.x = _textPos.x;
              textCtx.y = _textPos.y;
              textCtx.textAlign = me._getTextAlign(finalPos, nodeData); //文字

              var textEl = null;
              var textId = "text_" + h + "_" + nodeData.field;

              if (h <= preDataLen - 1) {
                textEl = txtGroupH.getChildById(textId);
              }

              if (textEl) {
                //do something
                textEl.resetText(value);
                textEl.context.x = textCtx.x;
                textEl.context.y = textCtx.y;
              } else {
                textEl = new _canvax["default"].Display.Text(value, {
                  id: textId,
                  context: textCtx
                });
                textEl.field = nodeData.field;
                txtGroupH.addChild(textEl);
              }
            } //label end ------------------------------

          }
        }
      });

      this.sprite.addChild(this.barsSp); //如果有text设置， 就要吧text的txtsSp也添加到sprite

      if (this.label.enabled) {
        this.sprite.addChild(this.txtsSp);
      }
      this.sprite.context.x = this.origin.x;
      this.sprite.context.y = this.origin.y;
      this.grow(function () {
        me.fire("complete");
      }, {
        delay: 0,
        duration: 300,
        animate: animate
      });
      me._preDataLen = me._dataLen;
    }
  }, {
    key: "_getFillStyle",
    value: function _getFillStyle(fillColor, rect) {
      if (typeof fillColor == 'string' && (0, color.colorIsHex)(fillColor)) {
        var _style = {
          points: [0, rect.height, 0, 0],
          lineargradient: [{
            position: 0,
            color: (0, color.colorRgba)(fillColor, 1)
          }, {
            position: 1,
            color: (0, color.colorRgba)(fillColor, 0.6)
          }]
        };
        return _style;
      } else {
        return fillColor;
      }
    }
  }, {
    key: "setEnabledField",
    value: function setEnabledField() {
      //要根据自己的 field，从enabledFields中根据enabled数据，计算一个 enabled版本的field子集
      this.enabledField = this.app.getComponent({
        name: 'coord'
      }).filterEnabledFields(this.field);
    }
  }, {
    key: "_getGroupRegionStyle",
    value: function _getGroupRegionStyle(iNode) {
      var me = this;
      var _groupRegionStyle = me.select.fillStyle;

      if (_.isArray(me.select.fillStyle)) {
        _groupRegionStyle = me.select.fillStyle[iNode];
      }

      if (_.isFunction(me.select.fillStyle)) {
        _groupRegionStyle = me.select.fillStyle.apply(this, [{
          iNode: iNode,
          rowData: me.dataFrame.getRowDataAt(iNode)
        }]);
      }

      if (_groupRegionStyle === undefined || _groupRegionStyle === null) {
        return me.select._fillStyle;
      }
      return _groupRegionStyle;
    }
  }, {
    key: "_trimGraphs",
    value: function _trimGraphs() {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      }); //用来计算下面的hLen


      this.setEnabledField();
      this.data = {};
      var layoutGraphs = [];
      var hLen = 0; //总共有多少列（ 一个xAxis单元分组内 ）

      var preHLen = 0; //自己前面有多少个列（ 一个xAxis单元分组内 ）

      var _preHLenOver = false;

      if (!this.absolute) {
        _.each(me.app.getComponents({
          name: 'graphs',
          type: 'bar'
        }), function (_g) {
          if (!_g.absolute) {
            if (_g === me) {
              _preHLenOver = true;
            }

            if (_preHLenOver) {
              //排在me后面的 graphs，需要计算setEnabledField，才能计算出来 全部的hLen
              _g.setEnabledField();
            } else {
              preHLen += _g.enabledField.length;
            }

            hLen += _g.enabledField.length;
            layoutGraphs.push(_g);
          }
        });
      } else {
        layoutGraphs = [this];
        hLen = this.enabledField.length;
      }

      var cellWidth = _coord.getAxis({
        type: 'xAxis'
      }).getCellLength(); //x方向的二维长度，就是一个bar分组里面可能有n个子bar柱子，那么要二次均分


      var ceilWidth2 = cellWidth / (hLen + 1); //知道了ceilWidth2 后 检测下 barW是否需要调整

      var barW = this._getBarWidth(cellWidth, ceilWidth2);

      var barDis = ceilWidth2 - barW;

      if (this.node.xDis != null) {
        barDis = this.node.xDis;
      }
      var disLeft = (cellWidth - barW * hLen - barDis * (hLen - 1)) / 2;

      if (preHLen) {
        disLeft += (barDis + barW) * preHLen;
      }
      //然后计算出对于结构的dataOrg

      var dataOrg = this.dataFrame.getDataOrg(this.enabledField);
      var selectOpt = me.getGraphSelectOpt(); //自己的select.inds为空的情况下，才需要寻找是不是别的graphs设置了inds

      if (!me.select.inds.length && selectOpt && selectOpt.inds && selectOpt.inds.length) {
        me.select.inds = _.clone(selectOpt.inds);
      }

      _.each(dataOrg, function (hData, b) {
        //hData，可以理解为一根竹子 横向的分组数据，这个hData上面还可能有纵向的堆叠
        //tempBarData 一根柱子的数据， 这个柱子是个数据，上面可以有n个子元素对应的竹节
        var tempBarData = [];

        _.each(hData, function (vSectionData, v) {
          tempBarData[v] = []; //vSectionData 代表某个字段下面的一组数据比如 uv

          me._dataLen = vSectionData.length; //vSectionData为具体的一个field对应的一组数据

          _.each(vSectionData, function (val, i) {
            var vCount = val;

            if (me.proportion) {
              //先计算总量
              vCount = 0;

              _.each(hData, function (team) {
                vCount += team[i];
              });
            }

            var field = me._getTargetField(b, v, i, me.enabledField); //返回一个和value的结构对应的point结构{x:  y: }


            var point = _coord.getPoint({
              iNode: i,
              vIndex: v,
              field: field,
              value: {
                //x:
                y: val
              }
            });

            var _x = point.pos.x;
            var x = _x - cellWidth / 2 + disLeft + (barW + barDis) * b;
            var y = 0;

            if (me.proportion) {
              y = -val / vCount * _coord.height;
            } else {
              y = point.pos.y;
            }

            if (isNaN(y)) {
              y = 0;
            }

            var yOriginPoint = _coord.getAxisOriginPoint({
              field: field
            });

            function _getFromY(tempBarData, v, i, val, y) {
              var preData = tempBarData[v - 1];

              if (!preData) {
                return yOriginPoint.pos;
              }
              var preY = preData[i].y;
              var preVal = preData[i].value;
              var yBaseNumber = yOriginPoint.value;

              if (val >= yBaseNumber) {
                //如果大于基线的，那么就寻找之前所有大于基线的
                if (preVal >= yBaseNumber) {
                  //能找到，先把pre的isLeaf设置为false
                  preData[i].isLeaf = false;
                  return preY;
                } else {
                  return _getFromY(tempBarData, v - 1, i, val);
                }
              } else {
                if (preVal < yBaseNumber) {
                  //能找到，先把pre的isLeaf设置为false
                  preData[i].isLeaf = false;
                  return preY;
                } else {
                  return _getFromY(tempBarData, v - 1, i, val);
                }
              }
            } //找到其着脚点,一般就是 yOriginPoint.pos


            var fromY = _getFromY(tempBarData, v, i, val);

            y += fromY - yOriginPoint.pos;
            var nodeData = {
              type: "bar",
              value: val,
              vInd: v,
              //如果是堆叠图的话，这个node在堆叠中得位置
              vCount: vCount,
              //纵向方向的总数,比瑞堆叠了uv(100),pv(100),那么这个vCount就是200，比例柱状图的话，外部tips定制content的时候需要用到
              field: field,
              fromX: x,
              fromY: fromY,
              x: x,
              y: y,
              width: barW,
              yOriginPoint: yOriginPoint,
              isLeaf: true,
              xAxis: _coord.getAxis({
                type: 'xAxis'
              }).getNodeInfoOfX(_x),
              iNode: i,
              rowData: me.dataFrame.getRowDataAt(i),
              color: null,
              //focused       : false,  //是否获取焦点，外扩
              selected: false //是否选中

            };

            if (!me.data[nodeData.field]) {
              me.data[nodeData.field] = tempBarData[v];
            }

            if (_.indexOf(me.select.inds, i) > -1) {
              nodeData.selected = true;
            }
            tempBarData[v].push(nodeData);
          });
        }); //tempBarData.length && tmpData.push( tempBarData );

      });

      return me.data; //return tmpData;
    }
  }, {
    key: "_getTextAlign",
    value: function _getTextAlign(bar, nodeData) {
      var textAlign = this.label.textAlign;

      if (nodeData.value < nodeData.yOriginPoint.value) {
        if (textAlign == "left") {
          textAlign = "right";
        } else if (textAlign == "right") {
          textAlign = "left";
        }
      }
      return textAlign;
    }
  }, {
    key: "_getTextPos",
    value: function _getTextPos(bar, nodeData) {
      var me = this;
      var point = {
        x: 0,
        y: 0
      };
      var x = bar.x,
          y = bar.y;
      var isNegative = true; //是负数

      if (bar.y >= nodeData.y) {
        isNegative = false;
      }

      switch (me.label.position) {
        case "top":
          x = bar.x + bar.width / 2;
          y = bar.y + bar.height;

          if (isNegative) {
            y += 16;
          }
          break;

        case "topRight":
          x = bar.x + bar.width;
          y = bar.y + bar.height;

          if (isNegative) {
            y += 16;
          }
          break;

        case "right":
          x = bar.x + bar.width;
          y = bar.y + bar.height / 2;
          break;

        case "rightBottom":
          x = bar.x + bar.width;
          y = bar.y;
          break;

        case "bottom":
          x = bar.x + bar.width / 2;
          y = bar.y;
          break;

        case "bottomLeft":
          x = bar.x;
          y = bar.y;
          break;

        case "left":
          x = bar.x;
          y = bar.y + bar.height / 2;
          break;

        case "leftTop":
          x = bar.x;
          y = bar.y + bar.height;

          if (isNegative) {
            y += 16;
          }
          break;

        case "center":
          x = bar.x + bar.width / 2;
          y = bar.y + bar.height / 2;
          break;
      }
      x -= me.label.offsetX;
      var i = 1;

      if (nodeData.value < nodeData.yOriginPoint.value) {
        i = -1;
      }
      y -= i * me.label.offsetY;
      point.x = x;
      point.y = y;
      return point;
    }
    /**
     * 生长动画
     */

  }, {
    key: "grow",
    value: function grow(callback, opt) {
      var me = this; //console.log( me._preDataLen+"|"+ me._dataLen)
      //先把已经不在当前range范围内的元素destroy掉

      if (me._preDataLen > me._dataLen) {
        for (var i = me._dataLen, l = me._preDataLen; i < l; i++) {
          me.barsSp.getChildAt(i).destroy();
          me.label.enabled && me.txtsSp.getChildAt(i).destroy();
          i--;
          l--;
        }
      }

      if (!opt.animate) {
        callback && callback(me);
        return;
      }
      var sy = 1;

      var optsions = _.extend({
        delay: Math.min(1000 / this._barsLen, 80),
        easing: "Linear.None",
        //"Back.Out",
        duration: 500
      }, opt);

      var barCount = 0;

      _.each(me.enabledField, function (h_group) {
        h_group = _.flatten([h_group]);
        var vLen = h_group.length;
        if (vLen == 0) return;

        for (var h = 0; h < me._dataLen; h++) {
          for (var v = 0; v < vLen; v++) {
            var nodeData = me.data[h_group[v]][h];
            var group = me.barsSp.getChildById("barGroup_" + h);
            var bar = group.getChildById("bar_" + h + "_" + nodeData.field);

            if (optsions.duration == 0) {
              bar.context.scaleY = sy;
              bar.context.y = sy * sy * bar.finalPos.y;
              bar.context.x = bar.finalPos.x;
              bar.context.width = bar.finalPos.width;
              bar.context.height = bar.finalPos.height;
            } else {
              if (bar._tweenObj) {
                AnimationFrame.destroyTween(bar._tweenObj);
              }
              bar._tweenObj = bar.animate({
                scaleY: sy,
                y: sy * bar.finalPos.y,
                x: bar.finalPos.x,
                width: bar.finalPos.width,
                height: bar.finalPos.height
              }, {
                duration: optsions.duration,
                easing: optsions.easing,
                delay: h * optsions.delay,
                onUpdate: function onUpdate() {
                  this.context.fillStyle = me._getFillStyle(this.nodeData.color, this.context);
                },
                onComplete: function onComplete(arg) {
                  if (arg.width < 3 && this.context) {
                    this.context.radius = 0;
                  }

                  barCount++;

                  if (barCount === me.node._count) {
                    callback && callback(me);
                  }
                },
                id: bar.id
              });
            }
          }
        }
      });
    } //这里的ind是包含了start的全局index
    //为什么需要传全局的index呢， 因为这个接口需要对外抛出，外部用户并不需要知道当前dataFrame.range.start

  }, {
    key: "selectAt",
    value: function selectAt(ind) {
      var me = this;
      if (_.indexOf(this.select.inds, ind) > -1) return;
      this.select.inds.push(ind); //因为这里是带上了start的全局的index，

      var index = ind - this.dataFrame.range.start;

      _.each(this.data, function (list) {
        var nodeData = list[index];
        nodeData.selected = true;
        me.setNodeElementStyle(nodeData);
      });

      var group = this.barsSp.getChildById("barGroup_" + index);

      if (group) {
        var groupRegion = group.getChildById("group_region_" + index);

        if (groupRegion) {
          groupRegion.context.globalAlpha = this.select.alpha;
        }
      }
    } //这里的ind是包含了start的全局index

  }, {
    key: "unselectAt",
    value: function unselectAt(ind) {
      var me = this;
      if (_.indexOf(this.select.inds, ind) == -1) return;

      var _index = _.indexOf(this.select.inds, ind);

      this.select.inds.splice(_index, 1);
      var index = ind - this.dataFrame.range.start;

      _.each(this.data, function (list) {
        var nodeData = list[index];
        nodeData.selected = false;
        me.setNodeElementStyle(nodeData);
      });

      var group = this.barsSp.getChildById("barGroup_" + index);

      if (group) {
        var groupRegion = group.getChildById("group_region_" + index);

        if (groupRegion) {
          groupRegion.context.globalAlpha = 0;
        }
      }
    }
  }, {
    key: "getSelectedRowList",
    value: function getSelectedRowList() {
      var rowDatas = [];
      var me = this;

      _.each(me.select.inds, function (ind) {
        //TODO: 这里的inds 是全局的，而getRowDataAt只能获取到当前视图内的数据
        //所以用这个接口会有问题
        //let index = ind - me.dataFrame.range.start;
        //rowDatas.push( me.dataFrame.getRowDataAt( index ) )
        rowDatas.push(me.dataFrame.jsonOrg[ind]);
      });

      return rowDatas;
    }
  }, {
    key: "setNodeElementStyle",
    value: function setNodeElementStyle(nodeData) {
      var me = this;

      var fillStyle = me._getColor(me.node.fillStyle, nodeData);

      nodeData.nodeElement.context.fillStyle = fillStyle;
    }
  }, {
    key: "getGraphSelectOpt",
    value: function getGraphSelectOpt() {
      var me = this; //如果某个graph 配置了select ----start

      var selectOpt = me._opt.select;

      if (!selectOpt) {
        var barGraphs = me.app.getComponents({
          name: 'graphs',
          type: 'bar'
        });

        _.each(barGraphs, function (barGraph) {
          if (selectOpt) return false;

          if (!selectOpt && barGraph._opt.select) {
            selectOpt = barGraph.select;
          }
        });
      }
      return selectOpt;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: '字段设置',
          documentation: '支持二维数组格式的设置，一维方向就是横向分组，二维方向就是纵向的堆叠',
          "default": null
        },
        yAxisAlign: {
          detail: '绘制在哪根y轴上面',
          "default": 'left'
        },
        absolute: {
          detail: '是否脱离graphs的位置计算',
          documentation: '\
                    trimGraphs的时候是否需要和其他的 bar graphs一起并排计算，\
                    true的话这个就会和别的重叠,\
                    和css中得absolute概念一致，脱离文档流的绝对定位',
          "default": false
        },
        proportion: {
          detail: '比例柱状图',
          "default": false
        },
        node: {
          detail: '单个数据对应的图形设置',
          propertys: {
            width: {
              detail: 'bar的宽度',
              "default": 0
            },
            maxWidth: {
              detail: '最大width',
              "default": 50
            },
            minWidth: {
              detail: '最小width',
              "default": 1
            },
            minHeight: {
              detail: '最小height',
              "default": 0
            },
            radius: {
              detail: '叶子节点的圆角半径',
              "default": 10
            },
            fillStyle: {
              detail: 'bar填充色',
              "default": null
            },
            fillAlpha: {
              detail: 'bar透明度',
              "default": 0.95
            },
            xDis: {
              detail: '单分组内bar之间的间隔',
              "default": null
            },
            filter: {
              detail: 'bar过滤处理器',
              "default": null
            },
            eventEnabled: {
              detail: '是否在单个柱子上面启动事件的监听',
              "default": true
            }
          }
        },
        label: {
          detail: '文本设置',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": false
            },
            fontColor: {
              detail: '文本颜色',
              "default": null,
              documentation: '如果有设置text.fontColor那么优先使用fontColor'
            },
            fontSize: {
              detail: '文本字体大小',
              "default": 12
            },
            format: {
              detail: '文本格式化处理函数',
              "default": null
            },
            lineWidth: {
              detail: '文本描边线宽',
              "default": 0
            },
            strokeStyle: {
              detail: '文本描边颜色',
              "default": null
            },
            rotation: {
              detail: '旋转角度',
              "default": 0
            },
            textAlign: {
              detail: '水平对齐方式',
              documentation: 'left center right',
              "default": 'center'
            },
            verticalAlign: {
              detail: '垂直基线对齐方式',
              documentation: 'top middle bottom',
              "default": 'bottom'
            },
            position: {
              detail: '文本布局位置',
              documentation: 'top,topRight,right,rightBottom,bottom,bottomLeft,left,leftTop,center',
              "default": 'top'
            },
            offsetX: {
              detail: 'x偏移量',
              "default": 0
            },
            offsetY: {
              detail: 'y偏移量',
              "default": 0
            }
          }
        },
        select: {
          detail: '分组选中',
          documentation: '\
                    分组的选中，不是选中具体的某个node，这里的选中靠groupRegion来表现出来,\
                    目前只有在第一个graphs bar 上配置有效',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": false
            },
            inds: {
              detail: '选中的分组索引集合',
              documentation: '选中的列的索引集合,注意，这里的ind不是当前视图的ind，而是加上了dataFrame.range.start的全局ind',
              "default": []
            },
            width: {
              detail: '选中态背景宽度',
              "default": 1
            },
            alpha: {
              detail: '选中态背景透明度',
              "default": 0.2
            },
            fillStyle: {
              detail: '选中态背景填充色',
              "default": null
            },
            triggerEventType: {
              detail: '触发选中效果的事件',
              "default": 'click,tap'
            }
          }
        }
      };
    }
  }]);
  return BarGraphs;
}(_index2["default"]);

_index2["default"].registerComponent(BarGraphs, 'graphs', 'bar');

var _default = BarGraphs;
exports["default"] = _default;
});

unwrapExports(bar);

var group = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);





var _numeral = interopRequireDefault(numeral);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var AnimationFrame = _canvax["default"].AnimationFrame;
var BrokenLine = _canvax["default"].Shapes.BrokenLine;
var Circle = _canvax["default"].Shapes.Circle;
var Isogon = _canvax["default"].Shapes.Isogon;
var Rect = _canvax["default"].Shapes.Rect;
var Path = _canvax["default"].Shapes.Path;

var LineGraphsGroup = /*#__PURE__*/function (_event$Dispatcher) {
  (0, _inherits2["default"])(LineGraphsGroup, _event$Dispatcher);

  var _super = _createSuper(LineGraphsGroup);

  function LineGraphsGroup(fieldConfig, iGroup, opt, ctx, h, w, _graphs) {
    var _this;

    var bottomFieldMap = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
    (0, _classCallCheck2["default"])(this, LineGraphsGroup);
    _this = _super.call(this);
    _this._graphs = _graphs;
    _this._opt = opt;
    _this.fieldConfig = fieldConfig;
    _this.field = null; //在extend之后要重新设置

    _this.iGroup = iGroup;
    _this._yAxis = fieldConfig.yAxis;
    _this.ctx = ctx;
    _this.w = w;
    _this.h = h;
    _this.y = 0;
    _this.data = [];
    _this.sprite = null;
    _this._pointList = []; //brokenline最终的状态

    _this._currPointList = []; //brokenline 动画中的当前状态

    _this._line = null;
    _this._bottomPointList = []; // bottomLine的最终状态

    _this._currBottomPointList = []; // bottomLine 动画中的当前状态

    _this._bottomLine = null; //设置默认的color 为 fieldConfig.color

    _this.color = fieldConfig.color;

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(LineGraphsGroup.defaultProps()), opt); //TODO group中得field不能直接用opt中得field， 必须重新设置， 
    //group中得field只有一个值，代表一条折线, 后面要扩展extend方法，可以控制过滤哪些key值不做extend


    _this.field = fieldConfig.field; //iGroup 在yAxis.field中对应的值

    _this.clipRect = null;
    _this.__currFocusInd = -1;
    _this._growed = false; //_bottomField如果有， 那么在画area的时候起点是_bottomField上面的值，而不是从默认的坐标0开始

    _this._bottomField = bottomFieldMap[_this.field];

    _this.init(opt);

    return _this;
  }

  (0, _createClass2["default"])(LineGraphsGroup, [{
    key: "init",
    value: function init() {
      this.sprite = new _canvax["default"].Display.Sprite();
      this.graphSprite = new _canvax["default"].Display.Sprite();
      this.sprite.addChild(this.graphSprite);
      this.lineSprite = new _canvax["default"].Display.Sprite();
      this.graphSprite.addChild(this.lineSprite); //hover效果的node被添加到的容器

      this._focusNodes = new _canvax["default"].Display.Sprite({});
      this.sprite.addChild(this._focusNodes);
      this._nodes = new _canvax["default"].Display.Sprite({});
      this.sprite.addChild(this._nodes);
      this._labels = new _canvax["default"].Display.Sprite({});
      this.sprite.addChild(this._labels);
    }
  }, {
    key: "_clean",
    value: function _clean() {
      this.lineSprite.removeAllChildren();

      this._focusNodes.removeAllChildren();

      this._nodes.removeAllChildren();

      this._labels.removeAllChildren();

      this._line = null;
      this._bottomLine = null;
      this._area = null;
    }
  }, {
    key: "draw",
    value: function draw(opt, data) {
      _.extend(true, this, opt);

      this.data = data;

      this._widget(opt);
    } //自我销毁

  }, {
    key: "destroy",
    value: function destroy() {
      var me = this;
      me.sprite.animate({
        globalAlpha: 0
      }, {
        duration: 300,
        onComplete: function onComplete() {
          me.sprite.remove();
        }
      });
    } //styleType , normals , iGroup

  }, {
    key: "_getColor",
    value: function _getColor(s, iNode) {
      var color = this._getProp(s, iNode); //只有iNode有传数据的时候（ 获取node的color 或者 获取 label的color ），才做如下处理


      if (arguments.length > 1 && (color === undefined || color === null)) {
        if (s && s.lineargradient) {
          color = s.lineargradient[parseInt(s.lineargradient.length / 2)].color;
        }

        if (!color || !_.isString(color)) {
          //那么最后，取this.fieldConfig.color
          color = this.fieldConfig.color; //this._getProp(this.color, iNode) //this.color会被写入到fieldMap.color
        }
      }
      return color;
    }
  }, {
    key: "_getProp",
    value: function _getProp(s, iNode) {
      if (_.isArray(s)) {
        return s[this.iGroup];
      }

      if (_.isFunction(s)) {
        var _nodesInfo = [];

        if (iNode != undefined) {
          _nodesInfo.push(this.data[iNode]);
        }
        return s.apply(this, _nodesInfo);
      }
      return s;
    } //这个是tips需要用到的 

  }, {
    key: "getNodeInfoAt",
    value: function getNodeInfoAt($index, e) {
      var o = this.data[$index];

      if (e && e.eventInfo && e.eventInfo.dimension_1) {
        var lt = e.eventInfo.dimension_1.layoutType;

        if (lt == 'proportion') {
          //$index则代表的xpos，需要计算出来data中和$index最近的值作为 node
          var xDis;

          for (var i = 0, l = this.data.length; i < l; i++) {
            var _node = this.data[i];

            var _xDis = Math.abs(_node.x - $index);

            if (xDis == undefined || _xDis < xDis) {
              xDis = _xDis;
              o = _node;
              continue;
            }
          }
        }
      }
      return o;
    }
    /**
     * 
     * @param {object} opt 
     * @param {data} data 
     * 
     * 触发这次reset的触发原因比如{name : 'datazoom', left:-1,right:1},  
     * dataTrigger 描述了数据变化的原因和变化的过程，比如上面的数据 left少了一个数据，right多了一个数据
     * @param {object} dataTrigger 
     */

  }, {
    key: "resetData",
    value: function resetData(data, dataTrigger, opt) {
      var me = this;

      if (data) {
        this.data = data;
      }

      if (!dataTrigger || !dataTrigger.comp) {
        //如果是系统级别的调用，需要从新执行绘制, 不是内部的触发比如（datazoom）
        me._growed = false;

        if (me.clipRect) {
          me.clipRect.destroy();
          me.clipRect = null;
        }

        me._widget(this);

        me._grow();
      } else {
        me._pointList = this._getPointList(this.data);
        me._bottomPointList = this._getBottomPointList();
        var plen = me._pointList.length;
        var cplen = me._currPointList.length;
        var params = {
          left: 0,
          //默认左边数据没变
          right: plen - cplen
        };

        if (dataTrigger && dataTrigger.params) {
          _.extend(params, dataTrigger.params);
        }

        if (params.left) {
          if (params.left > 0) {
            this._currPointList = this._pointList.slice(0, params.left).concat(this._currPointList);

            if (this._bottomField) {
              this._currBottomPointList = this._bottomPointList.slice(0, params.left).concat(this._currBottomPointList);
            }
          }

          if (params.left < 0) {
            this._currPointList.splice(0, Math.abs(params.left));

            if (this._bottomField) {
              this._currBottomPointList.splice(0, Math.abs(params.left));
            }
          }
        }

        if (params.right) {
          if (params.right > 0) {
            this._currPointList = this._currPointList.concat(this._pointList.slice(-params.right));

            if (this._bottomField) {
              this._currBottomPointList = this._currBottomPointList.concat(this._bottomPointList.slice(-params.right));
            }
          }

          if (params.right < 0) {
            this._currPointList.splice(this._currPointList.length - Math.abs(params.right));

            if (this._bottomField) {
              this._currBottomPointList.splice(this._currBottomPointList.length - Math.abs(params.right));
            }
          }
        }

        me._createNodes();

        me._createTexts();

        me._transition();
      }
    } //数据变化后的切换动画

  }, {
    key: "_transition",
    value: function _transition(callback) {
      var me = this;

      if (!me.data.length) {
        //因为在index中有调用
        if (me._line.context) {
          me._line.context.pointList = [];
        }

        if (me._bottomLine.context) {
          me._bottomLine.context.pointList = [];
        }

        if (me._area && me._area.context) {
          me._area.context.path = '';
        }
        callback && callback(me);
        return;
      }

      function _update(pointList, bottomPointList) {
        if (!me._line) {
          me.sprite._removeTween(me._transitionTween);

          me._transitionTween = null;
          return;
        }

        var _strokeStyle = me._getLineStrokeStyle();

        if (me._line.context) {
          me._line.context.pointList = _.clone(pointList);
          me._line.context.strokeStyle = _strokeStyle;
        }

        if (me._bottomField && me._bottomLine && me._bottomLine.context) {
          me._bottomLine.context.pointList = _.clone(bottomPointList);
          me._bottomLine.context.strokeStyle = _strokeStyle;
        }

        if (me._area && me._area.context) {
          me._area.context.path = me._getFillPath(me._line, me._bottomLine);
          me._area.context.fillStyle = me._getFillStyle();
        }

        var iNode = 0;

        _.each(pointList, function (point, i) {
          if (_.isNumber(point[1])) {
            if (me._nodes) {
              var _node = me._nodes.getChildAt(iNode);

              if (_node) {
                _node.context.x = point[0];
                _node.context.y = point[1];
              }
            }

            if (me._labels) {
              var _text = me._labels.getChildAt(iNode);

              if (_text) {
                _text.context.x = point[0];
                _text.context.y = point[1] - 3 - 3;

                me._checkTextPos(_text, i);
              }
            }

            iNode++;
          }
        });
      }

      if (!this._growed) {
        //如果还在入场中
        me._currPointList = me._pointList;
        me._currBottomPointList = me._bottomPointList;

        _update(me._currPointList, me._currBottomPointList);

        return;
      }

      this._transitionTween = AnimationFrame.registTween({
        from: me._getPointPosStr(me._currPointList, me._currBottomPointList),
        to: me._getPointPosStr(me._pointList, me._bottomPointList),
        desc: me.field,
        onUpdate: function onUpdate(arg) {
          for (var p in arg) {
            var currPointerList = p.split("_")[0] == 'p' ? me._currPointList : me._currBottomPointList;
            var ind = parseInt(p.split("_")[2]);
            var xory = parseInt(p.split("_")[1]);
            currPointerList[ind] && (currPointerList[ind][xory] = arg[p]); //p_1_n中间的1代表x or y
          }

          _update(me._currPointList, me._currBottomPointList);
        },
        onComplete: function onComplete() {
          me.sprite._removeTween(me._transitionTween);

          me._transitionTween = null; //在动画结束后强制把目标状态绘制一次。
          //解决在onUpdate中可能出现的异常会导致绘制有问题。
          //这样的话，至少最后的结果会是对的。

          _update(me._pointList, me._bottomPointList);

          callback && callback(me);
        }
      });

      this.sprite._tweens.push(this._transitionTween);
    } //首次加载的进场动画

  }, {
    key: "_grow",
    value: function _grow(callback) {
      var _this2 = this;

      var _coord = this._graphs.app.getCoord();

      var width = _coord.width,
          height = _coord.height;
      this.clipRect = new Rect({
        context: {
          x: 0,
          //-100,
          y: -height - 3,
          width: 0,
          height: height + 6,
          fillStyle: 'green'
        }
      });
      var growTo = {
        width: width
      };
      this.lineSprite.clipTo(this.clipRect);
      this.graphSprite.addChild(this.clipRect);

      if (this.line.growDriction == 'rightLeft') {
        this.clipRect.context.x = width;
        growTo.x = 0;
      }
      this.clipRect.animate(growTo, {
        duration: this._graphs.aniDuration,
        easing: this.aniEasing,
        onUpdate: function onUpdate() {
          var clipRectCtx = _this2.clipRect.context;

          _this2._nodes.children.concat(_this2._labels.children).forEach(function (el) {
            var _ctx = el.context;

            if (_ctx.globalAlpha == 0 && _ctx.x >= clipRectCtx.x && _ctx.x <= clipRectCtx.x + clipRectCtx.width) {
              el.animate({
                globalAlpha: 1
              }, {
                duration: 300
              });
            }
          });
        },
        onComplete: function onComplete() {
          _this2._growed = true;
          callback && callback();
        }
      });
    }
  }, {
    key: "_getPointPosStr",
    value: function _getPointPosStr(pointList, bottomPointList) {
      var obj = {};
      pointList.forEach(function (p, i) {
        if (!p) {
          //折线图中这个节点可能没有
          return;
        }
        obj["p_1_" + i] = p[1]; //p_y==p_1

        obj["p_0_" + i] = p[0]; //p_x==p_0
      });
      bottomPointList.forEach(function (p, i) {
        if (!p) {
          //折线图中这个节点可能没有
          return;
        }
        obj["bp_1_" + i] = p[1]; //p_y==p_1

        obj["bp_0_" + i] = p[0]; //p_x==p_0
      });
      return obj;
    }
  }, {
    key: "_getPointList",
    value: function _getPointList(data) {
      var list = [];

      for (var a = 0, al = data.length; a < al; a++) {
        var o = data[a];
        list.push([o.x, o.y]);
      }
      return list;
    }
  }, {
    key: "_widget",
    value: function _widget(opt) {
      var me = this;
      !opt && (opt = {});

      if (opt.isResize) {
        me._growed = true;
      }

      me._clean();

      me._pointList = this._getPointList(me.data);

      if (me._pointList.length == 0) {
        //filter后，data可能length==0
        return;
      }
      var list = me._pointList;
      me._currPointList = list;

      var strokeStyle = me._getLineStrokeStyle(list); //在配置线性渐变的情况下会需要


      var blineCtx = {
        pointList: list,
        lineWidth: me.line.lineWidth,
        y: me.y,
        strokeStyle: strokeStyle,
        smooth: me.line.smooth,
        lineType: me._getProp(me.line.lineType),
        lineDash: me.line.lineDash,
        //TODO: 不能用_getProp
        lineJoin: 'bevel',
        lineCap: "round"
      };

      if (me.line.shadowBlur) {
        blineCtx.shadowBlur = me._getProp(me.line.shadowBlur);
        blineCtx.shadowColor = me._getProp(me.line.shadowColor) || strokeStyle;
        blineCtx.shadowOffsetY = me._getProp(me.line.shadowOffsetY);
        blineCtx.shadowOffsetX = me._getProp(me.line.shadowOffsetX);
      }
      var bline = new BrokenLine({
        //线条
        context: blineCtx
      });
      bline.on(event.types.get(), function (e) {
        e.eventInfo = {
          trigger: 'this.line',
          nodes: []
        };

        me._graphs.app.fire(e.type, e);
      });

      if (!this.line.enabled) {
        bline.context.visible = false;
      }
      me.lineSprite.addChild(bline);
      me._line = bline;

      if (me.area.enabled) {
        if (this._bottomField) {
          //如果有 _bottomField
          me._bottomPointList = this._getBottomPointList();
          var _list = me._bottomPointList;
          me._currBottomPointList = _list;
          var bottomLineCtx = {};
          Object.assign(bottomLineCtx, blineCtx);
          bottomLineCtx.pointList = me._bottomPointList;
          var bottomLine = new BrokenLine({
            //线条
            context: bottomLineCtx
          });

          if (!this.area.bottomLine.enabled) {
            bottomLine.context.visible = false;
          }
          me.lineSprite.addChild(bottomLine);
          me._bottomLine = bottomLine;
        }

        var area = new Path({
          //填充
          context: {
            path: me._getFillPath(me._line, me._bottomLine),
            fillStyle: me._getFillStyle(),
            globalAlpha: me.area.alpha
          }
        });
        area.on(event.types.get(), function (e) {
          e.eventInfo = {
            trigger: 'this.area',
            //me.area,
            nodes: []
          };

          me._graphs.app.fire(e.type, e);
        });
        me.lineSprite.addChild(area);
        me._area = area;
      }

      me._createNodes(opt);

      me._createTexts(opt);
    }
  }, {
    key: "_getBottomPointList",
    value: function _getBottomPointList() {
      var _this3 = this;

      if (!this._bottomField) return [];

      var _coord = this._graphs.app.getCoord();

      var bottomData = this._graphs.dataFrame.getFieldData(this._bottomField);

      this._yAxis.addValToSection(bottomData); //把bottomData的数据也同步到y轴的dataSection, 可能y轴需要更新


      var _bottomPointList = [];
      bottomData.forEach(function (item, i) {
        var point = _coord.getPoint({
          iNode: i,
          field: _this3.field,
          value: {
            //x:
            y: item
          }
        });

        _bottomPointList.push([point.pos.x, point.pos.y]);
      });
      return _bottomPointList;
    }
  }, {
    key: "_getFirstNode",
    value: function _getFirstNode() {
      var _firstNode = null;

      for (var i = 0, l = this.data.length; i < l; i++) {
        var nodeData = this.data[i];

        if (_.isNumber(nodeData.y)) {
          if (_firstNode === null || this.yAxisAlign == "right") {
            //_yAxis为右轴的话，
            _firstNode = nodeData;
          }

          if (this.yAxisAlign !== "right" && _firstNode !== null) {
            break;
          }
        }
      }

      return _firstNode;
    }
  }, {
    key: "_getFillStyle",
    value: function _getFillStyle() {
      var me = this;

      var _fillStyle;

      if (!this._opt.area || !this._opt.area.fillStyle) {
        //如果用户没有配置area.strokeStyle，那么就用默认的
        _fillStyle = this.color;
      } else {
        _fillStyle = this._getColor(this._opt.area.fillStyle);
      }

      var alpha = me.area.alpha;

      if ((0, color.colorIsHex)(_fillStyle) && !_.isArray(alpha)) {
        alpha = [1, 0];
      }

      if (_.isArray(alpha)) {
        //alpha如果是数组，那么就是渐变背景，那么就至少要有两个值
        //如果拿回来的style已经是个gradient了，那么就不管了
        alpha.length = 2;

        if (alpha[0] == undefined) {
          alpha[0] = 0;
        }

        if (alpha[1] == undefined) {
          alpha[1] = 0;
        }
        var fill_gradient = {
          lineargradient: []
        };

        if ((0, color.colorIsHex)(_fillStyle)) {
          //创建一个线性渐变
          fill_gradient.lineargradient = [{
            position: 0,
            color: (0, color.colorRgba)(_fillStyle, alpha[0])
          }, {
            position: 1,
            color: (0, color.colorRgba)(_fillStyle, alpha[1])
          }];
          _fillStyle = fill_gradient;
        }
      }

      if (_fillStyle && _fillStyle.lineargradient) {
        var lineargradient = _fillStyle.lineargradient; //如果是右轴的话，渐变色要对应的反转

        if (this.yAxisAlign == 'right') {
          lineargradient = lineargradient.reverse();
        }

        var lps = this._getLinearGradientPoints('area');

        if (lps && lps.length) {
          _fillStyle.points = lps;
        }
      } //最后，如果是一个十六进制的颜色的话，就变成一个抄底的渐变


      return _fillStyle;
    }
  }, {
    key: "_getLineStrokeStyle",
    value: function _getLineStrokeStyle(pointList, graphType) {
      var _style;

      if (!this._opt.line || !this._opt.line.strokeStyle) {
        //如果用户没有配置line.strokeStyle，那么就用默认的
        _style = this.color;
      } else {
        _style = this._getColor(this._opt.line.strokeStyle);
      }

      if ((0, color.colorIsHex)(_style)) {
        var _lineargradient = {
          lineargradient: [{
            position: 0,
            color: (0, color.colorRgba)(_style, 0.2) //'rgba(56, 90, 204, 0.2)'

          }, {
            position: 0.05,
            color: (0, color.colorRgba)(_style, 1) //'rgba(56, 90, 204,  1)'

          }, {
            position: 0.95,
            color: (0, color.colorRgba)(_style, 1) //'rgba(56, 90, 204, 1)'

          }, {
            position: 1,
            color: (0, color.colorRgba)(_style, 0.2) //'rgba(56, 90, 204, 0.2)'

          }]
        };
        _style = _lineargradient;
      }

      var lineargradient = _style.lineargradient;

      if (lineargradient) {
        //如果是右轴的话，渐变色要对应的反转
        if (this.yAxisAlign == 'right') {
          lineargradient = lineargradient.reverse();
        }

        var lps = this._getLinearGradientPoints('line', pointList);

        if (!lps) return;
        _style.points = lps;
        return _style;
      }

      return _style;
    }
  }, {
    key: "_getLinearGradientPoints",
    value: function _getLinearGradientPoints() {
      var graphType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'line';
      var pointList = arguments.length > 1 ? arguments[1] : undefined;
      //如果graphType 传入的是area，并且，用户并没有配area.lineargradientDriction,那么就会默认和line.lineargradientDriction对齐
      var driction = this[graphType].lineargradientDriction;
      !pointList && (pointList = this._line.context.pointList);
      var linearPointStart, linearPointEnd;

      if (driction == 'topBottom') {
        //top -> bottom
        var topX = 0,
            topY = 0,
            bottomX = 0,
            bottomY = 0;

        for (var i = 0, l = pointList.length; i < l; i++) {
          var point = pointList[i];
          var y = point[1];

          if (!isNaN(y)) {
            topY = Math.min(y, topY);
            bottomY = Math.max(y, bottomY);
          }
        }

        linearPointStart = {
          x: topX,
          y: topY
        };
        linearPointEnd = {
          x: bottomX,
          y: bottomY
        };

        if (graphType == 'area') {
          //面积图的话，默认就需要一致绘制到底的x轴位置去了
          linearPointEnd.y = 0;
        }
      } else {
        //left->right
        var leftX,
            rightX,
            leftY = 0,
            rightY = 0;

        for (var _i = 0, _l = pointList.length; _i < _l; _i++) {
          var _point2 = pointList[_i];
          var x = _point2[0];
          var _y = _point2[1];

          if (!isNaN(x) && !isNaN(_y)) {
            if (leftX == undefined) {
              leftX = x;
            } else {
              leftX = Math.min(x, leftX);
            }

            rightX = Math.max(x, leftX);
          }
        }
        linearPointStart = {
          x: leftX,
          y: leftY
        };
        linearPointEnd = {
          x: rightX,
          y: rightY
        };
      }

      if (linearPointStart.x == undefined || linearPointStart.y == undefined || linearPointEnd.x == undefined || linearPointEnd.y == undefined) {
        return null;
      }

      return [linearPointStart.x, linearPointStart.y, linearPointEnd.x, linearPointEnd.y];
    }
  }, {
    key: "_createNodes",
    value: function _createNodes() {
      var _this4 = this;
      var me = this;
      var list = me._currPointList;
      var iNode = 0; //这里不能和下面的a对等，以为list中有很多无效的节点

      var _loop = function _loop(a, al) {
        var node = me.data[a];

        var _nodeColor = me._getColor(me.node.strokeStyle || me.color, a);

        node.color = _nodeColor; //回写回data里，tips的是用的到

        var nodeEnabled = me.node.enabled;

        if (list.length == 1 && !nodeEnabled) {
          nodeEnabled = true; //只有一个数据的时候， 强制显示node
        } // if( !nodeEnabled ){
        //     //不能写return， 是因为每个data的color还是需要计算一遍
        //     continue;
        // };


        var _point = me._currPointList[a];

        if (!_point || !_.isNumber(_point[1])) {
          //折线图中有可能这个point为undefined
          return "continue";
        }
        var x = _point[0];
        var y = _point[1];
        var globalAlpha = 0;

        if (_this4.clipRect && me._growed) {
          var clipRectCtx = _this4.clipRect.context;

          if (x >= clipRectCtx.x && x <= clipRectCtx.x + clipRectCtx.width) {
            globalAlpha = 1;
          }
        }
        var lineWidth = me.node.lineWidth || me.line.lineWidth;
        var context = {
          x: x,
          y: y,
          r: me._getProp(me.node.radius, a),
          lineWidth: me._getProp(lineWidth, a) || 2,
          strokeStyle: _nodeColor,
          fillStyle: me._getProp(me.node.fillStyle, a) || _nodeColor,
          visible: nodeEnabled && !!me._getProp(me.node.visible, a),
          globalAlpha: globalAlpha
        };
        var nodeConstructor = Circle;

        var _shapeType = me._getProp(me.node.shapeType, a);

        if (_shapeType == "isogon") {
          nodeConstructor = Isogon;
          context.n = me._getProp(me.node.isogonPointNum, a);
        }

        if (_shapeType == "path") {
          nodeConstructor = Path;
          context.path = me._getProp(me.node.path, a);
        }
        var nodeElement = me._nodes.children[iNode]; //同一个元素，才能直接extend context

        if (nodeElement) {
          if (nodeElement.type == _shapeType) {
            _.extend(nodeElement.context, context);
          } else {
            nodeElement.destroy(); //重新创建一个新的元素放到相同位置

            nodeElement = new nodeConstructor({
              context: context
            });
            nodeElement.on(event.types.get(), function (e) {
              e.eventInfo = {
                trigger: 'this.node',
                //me.node,
                nodes: [node]
              };

              me._graphs.app.fire(e.type, e);
            });

            me._nodes.addChildAt(nodeElement, iNode);
          }
        } else {
          nodeElement = new nodeConstructor({
            context: context
          });
          nodeElement.on(event.types.get(), function (e) {
            e.eventInfo = {
              trigger: 'this.node',
              //me.node,
              nodes: [node]
            };

            me._graphs.app.fire(e.type, e);
          });

          me._nodes.addChild(nodeElement);
        }

        if (me.node.corner) {
          //拐角才有节点
          var _y2 = me._pointList[a][1];
          var pre = me._pointList[a - 1];
          var next = me._pointList[a + 1];

          if (pre && next) {
            if (_y2 == pre[1] && _y2 == next[1]) {
              nodeElement.context.visible = false;
            }
          }
        }
        node.nodeElement = nodeElement;
        iNode++;
      };

      for (var a = 0, al = list.length; a < al; a++) {
        var _ret = _loop(a);

        if (_ret === "continue") continue;
      }

      if (me._nodes.children.length > iNode) {
        for (var i = iNode, l = me._nodes.children.length; i < l; i++) {
          me._nodes.children[i].destroy();

          i--;
          l--;
        }
      }
    }
  }, {
    key: "_createTexts",
    value: function _createTexts() {
      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var me = this;
      var list = me._currPointList;

      var _coord = this._graphs.app.getCoord();

      if (me.label.enabled) {
        //节点上面的文本info
        var iNode = 0; //这里不能和下面的a对等，以为list中有很多无效的节点

        for (var a = 0, al = list.length; a < al; a++) {
          var _point = list[a];

          if (!_point || !_.isNumber(_point[1])) {
            //折线图中有可能这个point为undefined
            continue;
          }
          var x = _point[0];
          var y = _point[1] - this.node.radius - 2;
          var globalAlpha = 0;

          if (this.clipRect && opt._growed) {
            var clipRectCtx = this.clipRect.context;

            if (x >= clipRectCtx.x && x <= clipRectCtx.x + clipRectCtx.width) {
              globalAlpha = 1;
            }
          }
          var context = {
            x: x,
            y: y,
            fontSize: this.label.fontSize,
            textAlign: this.label.textAlign,
            textBaseline: this.label.textBaseline,
            fillStyle: me._getColor(me.label.fontColor, a),
            lineWidth: 1,
            strokeStyle: "#ffffff",
            globalAlpha: globalAlpha
          };
          var nodeData = me.data[a];
          var value = nodeData.value;

          if (me.label.format) {
            //如果有单独给label配置format，就用label上面的配置
            if (_.isFunction(me.label.format)) {
              value = me.label.format.apply(me, [value, nodeData]);
            }

            if (typeof me.label.format == 'string') {
              value = (0, _numeral["default"])(value).format(me.label.format);
            }
          } else {
            //否则用fieldConfig上面的
            var fieldConfig = _coord.getFieldConfig(this.field);

            if (fieldConfig) {
              value = fieldConfig.getFormatValue(value);
            }
          }

          if (value == undefined || value == null) {
            continue;
          }
          var _label = this._labels.children[iNode];

          if (_label) {
            _label.resetText(value);

            _.extend(_label.context, context);
          } else {
            _label = new _canvax["default"].Display.Text(value, {
              context: context
            });

            me._labels.addChild(_label);

            me._checkTextPos(_label, a);
          }

          iNode++;
        }

        if (me._labels.children.length > iNode) {
          for (var i = iNode, l = me._labels.children.length; i < l; i++) {
            me._labels.children[i].destroy();

            i--;
            l--;
          }
        }
      }
    }
  }, {
    key: "_checkTextPos",
    value: function _checkTextPos(_label, ind) {
      var me = this;
      var list = me._currPointList;
      var pre = list[ind - 1];
      var next = list[ind + 1];

      if (pre && next && pre[1] < _label.context.y && next[1] < _label.context.y) {
        _label.context.y += 12;
        _label.context.textBaseline = "top";
      }
    }
  }, {
    key: "_getFillPath",
    value: function _getFillPath(line, bottomLine) {
      var path = '';
      var M = 'M',
          L = 'L',
          Z = 'z';
      var originPos = -this._yAxis.originPos;
      var bottomGraphicsData = bottomLine ? bottomLine.graphics.graphicsData : [];
      line.graphics.graphicsData.forEach(function (graphicsData, gInd) {
        var points = [].concat(graphicsData.shape.points);

        if (points.length > 1) {
          if (bottomGraphicsData.length) {
            var bottomGraphicsDataGroup = bottomGraphicsData[gInd] || bottomGraphicsData.slice(-1)[0];
            var bpoints = bottomGraphicsDataGroup.shape.points;

            for (var _i2 = 0, l = bpoints.length / 2; _i2 < l; _i2++) {
              points.push(bpoints[(l - _i2 - 1) * 2]);
              points.push(bpoints[(l - _i2 - 1) * 2 + 1]);
            }

            points = points.concat([points[0], points[1]]);
          } else {
            points = points.concat([points[points.length - 2], originPos, points[0], originPos, points[0], points[1]]);
          }
          var pointLen = points.length / 2;

          for (var i = 0; i < pointLen; i++) {
            var x = points[i * 2];
            var y = points[i * 2 + 1];

            if (!i) {
              path += M + x + ' ' + y;
            } else {
              path += L + x + ' ' + y;

              if (i == pointLen - 1) {
                path += Z;
              }
            }
          }
        }
      });
      return path;
    } //根据x方向的 val来 获取对应的node， 这个node可能刚好是一个node， 也可能两个node中间的某个位置

  }, {
    key: "getNodeInfoOfX",
    value: function getNodeInfoOfX(x) {
      //现在从data中查找0.5px间距内的值，有的话返回
      for (var i = 0, l = this.data.length; i < l; i++) {
        if (this.data[i].value !== null && Math.abs(this.data[i].x - x) <= 0.5) {
          //左右相差不到0.5px的，都算
          return this.data[i];
        }
      }

      var getPointFromXInLine = function getPointFromXInLine(x, line) {
        var p = {
          x: x,
          y: 0
        };
        p.y = line[0][1] + (line[1][1] - line[0][1]) / (line[1][0] - line[0][0]) * (x - line[0][0]);
        return p;
      };

      var point;

      var search = function search(points) {
        //points 是一维的数据,至少一个点有两个数据
        if (points.length < 2) return;
        var pointLen = points.length / 2;

        if (x < points[0] || x > points[(pointLen - 1) * 2]) {
          //x<points[0][0] || x>points.slice(-1)[0][0]
          //x不在该points区间，忽略
          return;
        }
        var midInd = parseInt(pointLen / 2);
        var midNextInd = midInd + 1;
        var midPreInd = midInd - 1;
        var midX = points[midInd * 2];
        var midY = points[midInd * 2 + 1];

        if (Math.abs(midX - x) <= 0.5) {
          //假如中间点的x和查找的x相差0.5以内，就已该midX为准
          point = {
            x: midX,
            y: midY
          };
          return;
        }
        var _pl = [];

        if (x > midX) {
          if (x < points[midNextInd * 2]) {
            //大于midX但是小于下一个点
            point = getPointFromXInLine(x, [[midX, midY], [points[midNextInd * 2], points[midNextInd * 2 + 1]]]);
            return;
          } else {
            _pl = points.slice(midNextInd * 2);
          }
        } else {
          if (x > points[midPreInd * 2]) {
            point = getPointFromXInLine(x, [[points[midPreInd * 2], points[midPreInd * 2 + 1]], [midX, midY]]);
            return;
          } else {
            _pl = points.slice(0, midInd * 2);
          }
        }
        search(_pl);
      };

      if (this._line) {
        var lineGraphsData = this._line.graphics.graphicsData;
        lineGraphsData.forEach(function (graphsData) {
          if (!point) {
            search(graphsData.shape.points);
          }
        });
      }

      if (!point || point.y == undefined) {
        return null;
      }

      var node = {
        type: "line",
        iGroup: this.iGroup,
        iNode: -1,
        //并非data中的数据，而是计算出来的数据
        field: this.field,
        value: this._yAxis.getValOfPos(-point.y),
        x: point.x,
        y: point.y,
        rowData: null,
        //非data中的数据，没有rowData
        color: null
      };
      node.color = this._getProp(this.node.strokeStyle, node);
      return node;
    }
  }, {
    key: "tipsPointerOf",
    value: function tipsPointerOf(e) {
      if (e.eventInfo) {
        var iNode = e.eventInfo.iNode;

        if (iNode != this.__currFocusInd && this.__currFocusInd != -1) {
          this.unfocusOf(this.__currFocusInd);
        }
        this.focusOf(e.eventInfo.iNode);
      }
    }
  }, {
    key: "tipsPointerHideOf",
    value: function tipsPointerHideOf(e) {
      if (e.eventInfo) {
        this.unfocusOf(e.eventInfo.iNode);
      }
    }
  }, {
    key: "focusOf",
    value: function focusOf(iNode) {
      var node = this.data[iNode];

      if (node) {
        var _node = node.nodeElement;

        if (_node && !node.focused && this.__currFocusInd != iNode) {
          //console.log( 'focusOf' )
          _node._fillStyle = _node.context.fillStyle;
          _node.context.fillStyle = 'white';
          _node.context.r += _node.context.lineWidth / 2;
          _node._visible = _node.context.visible;
          _node.context.visible = true;

          var _focusNode = _node.clone();

          this._focusNodes.addChild(_focusNode); //_focusNode.context.r += 6;


          _focusNode.context.visible = true;
          _focusNode.context.lineWidth = 0; //不需要描边

          _focusNode.context.fillStyle = _node.context.strokeStyle;
          _focusNode.context.globalAlpha = this.node.focus.alpha;

          _focusNode.animate({
            r: _focusNode.context.r + this.node.focus.radiusDiff
          }, {
            duration: 300
          });

          this.__currFocusInd = iNode;
        }

        node.focused = true;
      }
    }
  }, {
    key: "unfocusOf",
    value: function unfocusOf(iNode) {
      if (this.__currFocusInd > -1) {
        iNode = this.__currFocusInd;
      }
      var node = this.data[iNode];

      if (node) {
        this._focusNodes.removeAllChildren();

        var _node = node.nodeElement;

        if (_node && node.focused) {
          //console.log('unfocus')
          _node.context.fillStyle = _node._fillStyle;
          _node.context.r -= _node.context.lineWidth / 2;
          _node.context.visible = _node._visible;
          node.focused = false;
          this.__currFocusInd = -1;
        }
      }
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        aniDuration: {
          //覆盖基类中的设置，line的duration要1000
          detail: '动画时长',
          "default": 1000
        },
        line: {
          detail: '线配置',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": true
            },
            growDriction: {
              detail: '生长动画的方向，默认为从左到右（leftRgiht）,可选rightLeft',
              "default": 'leftRight'
            },
            strokeStyle: {
              detail: '线的颜色',
              "default": undefined //不会覆盖掉constructor中的定义

            },
            lineargradientDriction: {
              detail: '线的填充色是渐变对象的话，这里用来描述方向，默认从上到下（topBottom）,可选leftRight',
              "default": 'leftRight' //可选 topBottom

            },
            lineWidth: {
              detail: '线的宽度',
              "default": 2
            },
            lineType: {
              detail: '线的样式',
              "default": 'solid'
            },
            lineDash: {
              detail: '虚线的线段样式，默认[6,3]',
              "default": [2, 5]
            },
            smooth: {
              detail: '是否平滑处理',
              "default": true
            },
            shadowOffsetX: {
              detail: '折线的X方向阴影偏移量',
              "default": 0
            },
            shadowOffsetY: {
              detail: '折线的Y方向阴影偏移量',
              "default": 2
            },
            shadowBlur: {
              detail: '折线的阴影模糊效果',
              "default": 8
            },
            shadowColor: {
              detail: '折线的阴影颜色，默认和折线的strokeStyle同步， 如果strokeStyle是一个渐变色，那么shadowColor就会失效，变成默认的黑色，需要手动设置该shadowColor',
              "default": function _default() {
                var fieldColor = this.color;
                return (0, color.colorRgba)(fieldColor, 0.4);
              }
            }
          }
        },
        node: {
          detail: '单个数据节点配置，对应线上的小icon图形',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": true
            },
            shapeType: {
              detail: '节点icon的图形类型，默认circle',
              documentation: '可选有"isogon"(正多边形)，"path"（自定义path路径，待实现）',
              "default": 'circle'
            },
            isogonPointNum: {
              detail: 'shapeType为"isogon"时有效，描述正多边形的边数',
              "default": 3
            },
            path: {
              detail: 'shapeType为path的时候，描述图形的path路径',
              "default": null
            },
            corner: {
              detail: '拐角才有节点',
              "default": false
            },
            radius: {
              detail: '节点半径',
              "default": 3
            },
            fillStyle: {
              detail: '节点图形的背景色',
              "default": null
            },
            strokeStyle: {
              detail: '节点图形的描边色，默认和line.strokeStyle保持一致',
              "default": null
            },
            lineWidth: {
              detail: '节点图形边宽大小,默认跟随line.lineWidth',
              "default": null
            },
            visible: {
              detail: '节点是否显示,支持函数',
              "default": true
            },
            focus: {
              detail: "节点hover态设置",
              propertys: {
                radiusDiff: {
                  detail: 'hover后的背景节点半径相差，正数为变大值,默认为4',
                  "default": 4
                },
                alpha: {
                  detail: 'hover后的背景节点透明度，默认为0.5',
                  "default": 0.5
                }
              }
            }
          }
        },
        label: {
          detail: '文本配置',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": false
            },
            fontColor: {
              detail: '文本颜色',
              "default": null
            },
            strokeStyle: {
              detail: '文本描边色',
              "default": null
            },
            fontSize: {
              detail: '文本字体大小',
              "default": 12
            },
            format: {
              detail: '文本格式化处理函数',
              "default": null
            },
            textAlign: {
              detail: '水平布局方式',
              "default": 'center'
            },
            textBaseline: {
              detail: '垂直布局方式',
              "default": 'bottom'
            }
          }
        },
        area: {
          detail: '面积区域配置',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": true
            },
            lineargradientDriction: {
              detail: '面积的填充色是渐变对象的话，这里用来描述方向，默认null(就会从line中取),从上到下（topBottom）,可选leftRight',
              "default": 'topBottom' //默认null（就会和line保持一致），可选 topBottom leftRight

            },
            fillStyle: {
              detail: '面积背景色',
              "default": null
            },
            alpha: {
              detail: '面积透明度',
              "default": 0.5
            },
            bottomLine: {
              detail: 'area的底部线配置',
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": true
                }
              }
            }
          }
        }
      };
    }
  }]);
  return LineGraphsGroup;
}(event.Dispatcher);

exports["default"] = LineGraphsGroup;
});

unwrapExports(group);

var line = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _group = interopRequireDefault(group);

var _index = interopRequireDefault(graphs);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

//假如用户传入的是和 堆叠柱状图一样的 二维数组的field [ [uv, uv_bottom], pv ] 这样的，
//那么就 只保留uv作为field， 第二个数据作为 bottom field， 其他的多余的删除掉
//然后，bottomFieldMap中用field的uv作为key，bottom的field作为值，传给group来绘制起点
var bottomFieldMap = {};

var LineGraphs = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(LineGraphs, _GraphsBase);

  var _super = _createSuper(LineGraphs);

  function LineGraphs(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, LineGraphs);
    _this = _super.call(this, opt, app);
    _this.type = "line";
    _this.enabledField = null;
    _this.groups = []; //群组集合

    Canvax._.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(LineGraphs.defaultProps()), opt);

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(LineGraphs, [{
    key: "init",
    value: function init() {}
  }, {
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {});
      this.width = opt.width;
      this.height = opt.height;

      Canvax._.extend(true, this.origin, opt.origin);

      this.sprite.context.x = this.origin.x;
      this.sprite.context.y = this.origin.y;
      this.data = this._trimGraphs();

      this._setGroupsForYfield(this.data, null, opt);

      if (this.animation && !opt.resize) {
        this.grow();
      } else {
        this.fire("complete");
      }

      return this;
    }
  }, {
    key: "resetData",
    value: function resetData(dataFrame, dataTrigger, opt) {
      var me = this;

      if (dataFrame) {
        me.dataFrame = dataFrame;
      }

      if (opt) {
        if ('origin' in opt) {
          if ('x' in opt.origin) this.sprite.context.x = opt.origin.x;
          if ('y' in opt.origin) this.sprite.context.y = opt.origin.y;
        }
      }

      me.data = me._trimGraphs();
      me.groups.forEach(function (g) {
        g.resetData(me.data[g.field].data, dataTrigger, opt);
      });
    }
  }, {
    key: "setEnabledField",
    value: function setEnabledField() {
      //要根据自己的 field，从enabledFields中根据enabled数据，计算一个 enabled版本的field子集
      this.enabledField = this.app.getComponent({
        name: 'coord'
      }).filterEnabledFields(this.field);
    } //dataFrame

  }, {
    key: "_trimGraphs",
    value: function _trimGraphs() {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      }); //{"uv":{}.. ,"ppc": "pv":]}
      //这样按照字段摊平的一维结构


      var tmpData = {};
      me.setEnabledField();

      Canvax._.each(Canvax._.flatten(me.enabledField), function (field, i) {
        //let maxValue = 0;
        var fieldConfig = me.app.getComponent({
          name: 'coord'
        }).getFieldConfig(field); //单条line的全部data数据

        var _lineData = me.dataFrame.getFieldData(field);

        if (!_lineData) return;
        var _graphsData = [];

        for (var b = 0, bl = _lineData.length; b < bl; b++) {
          //返回一个和value的结构对应的point结构{x:  y: }
          var point = _coord.getPoint({
            iNode: b,
            field: field,
            value: {
              //x:
              y: _lineData[b]
            }
          });

          var node = {
            type: "line",
            iGroup: i,
            iNode: b,
            field: field,
            value: _lineData[b],
            x: point.pos.x,
            y: point.pos.y,
            rowData: me.dataFrame.getRowDataAt(b),
            color: fieldConfig.color //默认设置皮肤颜色，动态的在group里面会被修改

          };

          _graphsData.push(node);
        }
        tmpData[field] = {
          yAxis: fieldConfig.yAxis,
          field: field,
          data: _graphsData
        };
      });

      return tmpData;
    }
    /**
     * 生长动画
     */

  }, {
    key: "grow",
    value: function grow(callback) {
      var gi = 0;
      var gl = this.groups.length;
      var me = this;

      Canvax._.each(this.groups, function (g) {
        g._grow(function () {
          gi++;
          callback && callback(g);

          if (gi == gl) {
            me.fire("complete");
          }
        });
      });

      return this;
    } //field 可以是单个 field 也可以是fields数组

  }, {
    key: "show",
    value: function show(field) {
      var _this2 = this;

      //过渡优化，有field的状态变化，可能就y轴的数据区间都有了变化，这里的优化就成了bug，所有的field都需要绘制一次
      //这个field不再这个graphs里面的，不相关
      // if( _.indexOf( _.flatten( [me.field] ), field ) == -1 ){
      //     return;
      // };
      this.data = this._trimGraphs(); //先把现有的group resetData

      this.groups.forEach(function (g) {
        g.resetData(_this2.data[g.field].data);
      }); //然后把field添加到groups里面去

      var newGroups = this._setGroupsForYfield(this.data, field);

      newGroups.forEach(function (g) {
        g._grow();
      });
    }
  }, {
    key: "hide",
    value: function hide(field) {
      var me = this;
      var i = me.getGroupIndex(field);

      if (i > -1) {
        this.groups.splice(i, 1)[0].destroy(); //return; //这里不能直接return，和上面的show一样，同样的属于过渡优化，因为这个时候y轴的值域可能变了， 其他的graphs需要重新绘制
      }
      this.data = this._trimGraphs();

      Canvax._.each(this.groups, function (g) {
        g.resetData(me.data[g.field].data);
      });
    }
  }, {
    key: "getGroupIndex",
    value: function getGroupIndex(field) {
      var ind = -1;

      for (var i = 0, l = this.groups.length; i < l; i++) {
        if (this.groups[i].field === field) {
          ind = i;
          break;
        }
      }

      return ind;
    }
  }, {
    key: "getGroup",
    value: function getGroup(field) {
      return this.groups[this.getGroupIndex(field)];
    }
  }, {
    key: "_setGroupsForYfield",
    value: function _setGroupsForYfield(data, fields, opt) {
      var me = this;
      !opt && (opt = {});

      if (fields) {
        //如果有传入field参数，那么就说明只需要从data里面挑选指定的field来添加
        //一般用在add()执行的时候
        fields = Canvax._.flatten([fields]);
      }

      var _flattenField = Canvax._.flatten([this.field]);

      var newGroups = [];

      Canvax._.each(data, function (g, field) {
        if (fields && Canvax._.indexOf(fields, field) == -1) {
          //如果有传入fields，但是当前field不在fields里面的话，不需要处理
          //说明该group已经在graphs里面了
          return;
        }
        var fieldConfig = me.app.getComponent({
          name: 'coord'
        }).getFieldConfig(field); //iGroup 是这条group在本graphs中的ind，而要拿整个图表层级的index， 就是fieldMap.ind

        var iGroup = Canvax._.indexOf(_flattenField, field);

        var group = new _group["default"](fieldConfig, iGroup, //不同于fieldMap.ind
        me._opt, me.ctx, me.height, me.width, me, bottomFieldMap);
        var insert = false; //在groups数组中插入到比自己_groupInd小的元素前面去

        for (var gi = 0, gl = me.groups.length; gi < gl; gi++) {
          if (iGroup < me.groups[gi].iGroup) {
            me.groups.splice(gi, 0, group);
            insert = true;
            me.sprite.addChildAt(group.sprite, gi);
            break;
          }
        }

        if (!insert) {
          var preGroup = me.groups.find(function (g) {
            return g.field == group.field;
          });

          if (preGroup) {
            me.groups.splice(me.groups.indexOf(preGroup), 1);
            preGroup.destroy();
          }

          me.groups.push(group);
          me.sprite.addChild(group.sprite);
        }
        group.draw({
          animation: me.animation,
          isResize: opt.resize
        }, g.data);
        newGroups.push(group);
      });

      return newGroups;
    }
  }, {
    key: "getNodesAt",
    value: function getNodesAt(ind, e) {
      var _nodesInfoList = []; //节点信息集合

      Canvax._.each(this.groups, function (group) {
        var node = group.getNodeInfoAt(ind, e);
        node && _nodesInfoList.push(node);
      });

      return _nodesInfoList;
    }
  }, {
    key: "getNodesOfPos",
    value: function getNodesOfPos(x) {
      var _nodesInfoList = []; //节点信息集合

      Canvax._.each(this.groups, function (group) {
        var node = group.getNodeInfoOfX(x);
        node && _nodesInfoList.push(node);
      });

      return _nodesInfoList;
    }
  }, {
    key: "tipsPointerOf",
    value: function tipsPointerOf(e) {
      this.groups.forEach(function (group) {
        group.tipsPointerOf(e);
      });
    }
  }, {
    key: "tipsPointerHideOf",
    value: function tipsPointerHideOf(e) {
      this.groups.forEach(function (group) {
        group.tipsPointerHideOf(e);
      });
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: '字段配置，支持二维数组格式',
          "default": null
        },
        yAxisAlign: {
          detail: '绘制在哪根y轴上面',
          "default": 'left'
        },
        _props: [_group["default"]]
      };
    }
  }, {
    key: "polyfill",
    value: function polyfill(opt) {
      if (Array.isArray(opt.field)) {
        opt.field.forEach(function (item) {
          if (Array.isArray(item) && item.length > 1) {
            //说明这个是一个河流图，[ [uv, uv_bottom] ] 这样的，
            var bottomField = item[1];
            item.length = 1;
            bottomFieldMap[item[0]] = bottomField;
          }
        });
      }

      return opt;
    }
  }]);
  return LineGraphs;
}(_index["default"]);

_index["default"].registerComponent(LineGraphs, 'graphs', 'line');

var _default = LineGraphs;
exports["default"] = _default;
});

unwrapExports(line);

var intersect_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function ccw(x1, y1, x2, y2, x3, y3) {
  var cw = (y3 - y1) * (x2 - x1) - (y2 - y1) * (x3 - x1);
  return cw > 0 ? true : cw < 0 ? false : true; // colinear
}

function intersect(seg1, seg2) {
  var x1 = seg1[0][0],
      y1 = seg1[0][1],
      x2 = seg1[1][0],
      y2 = seg1[1][1],
      x3 = seg2[0][0],
      y3 = seg2[0][1],
      x4 = seg2[1][0],
      y4 = seg2[1][1];
  return ccw(x1, y1, x3, y3, x4, y4) !== ccw(x2, y2, x3, y3, x4, y4) && ccw(x1, y1, x2, y2, x3, y3) !== ccw(x1, y1, x2, y2, x4, y4);
}

var _default = intersect;
exports["default"] = _default;
});

unwrapExports(intersect_1);

var grid_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function Grid(points, cellSize) {
  this._cells = [];
  this._cellSize = cellSize;
  this._reverseCellSize = 1 / cellSize;

  for (var i = 0; i < points.length; i++) {
    var point = points[i];
    var x = this.coordToCellNum(point[0]);
    var y = this.coordToCellNum(point[1]);

    if (!this._cells[x]) {
      var array = [];
      array[y] = [point];
      this._cells[x] = array;
    } else if (!this._cells[x][y]) {
      this._cells[x][y] = [point];
    } else {
      this._cells[x][y].push(point);
    }
  }
}

Grid.prototype = {
  cellPoints: function cellPoints(x, y) {
    // (Number, Number) -> Array
    return this._cells[x] !== undefined && this._cells[x][y] !== undefined ? this._cells[x][y] : [];
  },
  rangePoints: function rangePoints(bbox) {
    // (Array) -> Array
    var tlCellX = this.coordToCellNum(bbox[0]);
    var tlCellY = this.coordToCellNum(bbox[1]);
    var brCellX = this.coordToCellNum(bbox[2]);
    var brCellY = this.coordToCellNum(bbox[3]);
    var points = [];

    for (var x = tlCellX; x <= brCellX; x++) {
      for (var y = tlCellY; y <= brCellY; y++) {
        Array.prototype.push.apply(points, this.cellPoints(x, y));
      }
    }

    return points;
  },
  removePoint: function removePoint(point) {
    // (Array) -> Array
    var cellX = this.coordToCellNum(point[0]);
    var cellY = this.coordToCellNum(point[1]);
    var cell = this._cells[cellX][cellY];
    var pointIdxInCell;

    for (var i = 0; i < cell.length; i++) {
      if (cell[i][0] === point[0] && cell[i][1] === point[1]) {
        pointIdxInCell = i;
        break;
      }
    }

    cell.splice(pointIdxInCell, 1);
    return cell;
  },
  trunc: Math.trunc || function (val) {
    // (number) -> number
    return val - val % 1;
  },
  coordToCellNum: function coordToCellNum(x) {
    // (number) -> number
    return this.trunc(x * this._reverseCellSize);
  },
  extendBbox: function extendBbox(bbox, scaleFactor) {
    // (Array, Number) -> Array
    return [bbox[0] - scaleFactor * this._cellSize, bbox[1] - scaleFactor * this._cellSize, bbox[2] + scaleFactor * this._cellSize, bbox[3] + scaleFactor * this._cellSize];
  }
};

function grid(points, cellSize) {
  return new Grid(points, cellSize);
}

var _default = grid;
exports["default"] = _default;
});

unwrapExports(grid_1);

var format = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = {
  toXy: function toXy(pointset, format) {
    if (format === undefined) {
      return pointset.slice();
    }

    return pointset.map(function (pt) {
      /*jslint evil: true */
      var _getXY = new Function('pt', 'return [pt' + format[0] + ',' + 'pt' + format[1] + '];');

      return _getXY(pt);
    });
  },
  fromXy: function fromXy(pointset, format) {
    if (format === undefined) {
      return pointset.slice();
    }

    return pointset.map(function (pt) {
      /*jslint evil: true */
      var _getObj = new Function('pt', 'const o = {}; o' + format[0] + '= pt[0]; o' + format[1] + '= pt[1]; return o;');

      return _getObj(pt);
    });
  }
};
exports["default"] = _default;
});

unwrapExports(format);

var convex_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _cross(o, a, b) {
  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
}

function _upperTangent(pointset) {
  var lower = [];

  for (var l = 0; l < pointset.length; l++) {
    while (lower.length >= 2 && _cross(lower[lower.length - 2], lower[lower.length - 1], pointset[l]) <= 0) {
      lower.pop();
    }

    lower.push(pointset[l]);
  }

  lower.pop();
  return lower;
}

function _lowerTangent(pointset) {
  var reversed = pointset.reverse(),
      upper = [];

  for (var u = 0; u < reversed.length; u++) {
    while (upper.length >= 2 && _cross(upper[upper.length - 2], upper[upper.length - 1], reversed[u]) <= 0) {
      upper.pop();
    }

    upper.push(reversed[u]);
  }

  upper.pop();
  return upper;
} // pointset has to be sorted by X


function convex(pointset) {
  var upper = _upperTangent(pointset),
      lower = _lowerTangent(pointset);

  var convex = lower.concat(upper);
  convex.push(pointset[0]);
  return convex;
}

var _default = convex;
exports["default"] = _default;
});

unwrapExports(convex_1);

var hull_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _intersect2 = interopRequireDefault(intersect_1);

var _grid = interopRequireDefault(grid_1);

var _format = interopRequireDefault(format);

var _convex = interopRequireDefault(convex_1);

/*
 (c) 2014-2019, Andrii Heonia
 Hull.js, a JavaScript library for concave hull generation by set of points.
 https://github.com/AndriiHeonia/hull
*/
function _filterDuplicates(pointset) {
  var unique = [pointset[0]];
  var lastPoint = pointset[0];

  for (var i = 1; i < pointset.length; i++) {
    var currentPoint = pointset[i];

    if (lastPoint[0] !== currentPoint[0] || lastPoint[1] !== currentPoint[1]) {
      unique.push(currentPoint);
    }

    lastPoint = currentPoint;
  }

  return unique;
}

function _sortByX(pointset) {
  return pointset.sort(function (a, b) {
    return a[0] - b[0] || a[1] - b[1];
  });
}

function _sqLength(a, b) {
  return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);
}

function _cos(o, a, b) {
  var aShifted = [a[0] - o[0], a[1] - o[1]],
      bShifted = [b[0] - o[0], b[1] - o[1]],
      sqALen = _sqLength(o, a),
      sqBLen = _sqLength(o, b),
      dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];

  return dot / Math.sqrt(sqALen * sqBLen);
}

function _intersect(segment, pointset) {
  for (var i = 0; i < pointset.length - 1; i++) {
    var seg = [pointset[i], pointset[i + 1]];

    if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] || segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {
      continue;
    }

    if ((0, _intersect2["default"])(segment, seg)) {
      return true;
    }
  }

  return false;
}

function _occupiedArea(pointset) {
  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;

  for (var i = pointset.length - 1; i >= 0; i--) {
    if (pointset[i][0] < minX) {
      minX = pointset[i][0];
    }

    if (pointset[i][1] < minY) {
      minY = pointset[i][1];
    }

    if (pointset[i][0] > maxX) {
      maxX = pointset[i][0];
    }

    if (pointset[i][1] > maxY) {
      maxY = pointset[i][1];
    }
  }

  return [maxX - minX, // width
  maxY - minY // height
  ];
}

function _bBoxAround(edge) {
  return [Math.min(edge[0][0], edge[1][0]), // left
  Math.min(edge[0][1], edge[1][1]), // top
  Math.max(edge[0][0], edge[1][0]), // right
  Math.max(edge[0][1], edge[1][1]) // bottom
  ];
}

function _midPoint(edge, innerPoints, convex) {
  var point = null,
      angle1Cos = MAX_CONCAVE_ANGLE_COS,
      angle2Cos = MAX_CONCAVE_ANGLE_COS,
      a1Cos,
      a2Cos;

  for (var i = 0; i < innerPoints.length; i++) {
    a1Cos = _cos(edge[0], edge[1], innerPoints[i]);
    a2Cos = _cos(edge[1], edge[0], innerPoints[i]);

    if (a1Cos > angle1Cos && a2Cos > angle2Cos && !_intersect([edge[0], innerPoints[i]], convex) && !_intersect([edge[1], innerPoints[i]], convex)) {
      angle1Cos = a1Cos;
      angle2Cos = a2Cos;
      point = innerPoints[i];
    }
  }

  return point;
}

function _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList) {
  var midPointInserted = false;

  for (var i = 0; i < convex.length - 1; i++) {
    var edge = [convex[i], convex[i + 1]]; // generate a key in the format X0,Y0,X1,Y1

    var keyInSkipList = edge[0][0] + ',' + edge[0][1] + ',' + edge[1][0] + ',' + edge[1][1];

    if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen || edgeSkipList.has(keyInSkipList)) {
      continue;
    }

    var scaleFactor = 0;

    var bBoxAround = _bBoxAround(edge);

    var bBoxWidth = void 0;
    var bBoxHeight = void 0;
    var midPoint = void 0;

    do {
      bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);
      bBoxWidth = bBoxAround[2] - bBoxAround[0];
      bBoxHeight = bBoxAround[3] - bBoxAround[1];
      midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);
      scaleFactor++;
    } while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));

    if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {
      edgeSkipList.add(keyInSkipList);
    }

    if (midPoint !== null) {
      convex.splice(i + 1, 0, midPoint);
      grid.removePoint(midPoint);
      midPointInserted = true;
    }
  }

  if (midPointInserted) {
    return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);
  }

  return convex;
}

function hull(pointset, concavity, format) {
  var maxEdgeLen = concavity || 20;

  var points = _filterDuplicates(_sortByX(_format["default"].toXy(pointset, format)));

  if (points.length < 4) {
    return points.concat([points[0]]);
  }

  var occupiedArea = _occupiedArea(points);

  var maxSearchArea = [occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT, occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT];
  var convex = (0, _convex["default"])(points);
  var innerPoints = points.filter(function (pt) {
    return convex.indexOf(pt) < 0;
  });
  var cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));

  var concave = _concave(convex, Math.pow(maxEdgeLen, 2), maxSearchArea, (0, _grid["default"])(innerPoints, cellSize), new Set());

  if (format) {
    return _format["default"].fromXy(concave, format);
  } else {
    return concave;
  }
}

var MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg

var MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;
var _default = hull;
exports["default"] = _default;
});

unwrapExports(hull_1);

var scat = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = interopRequireDefault(_typeof_1$1);

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(graphs);



var _index2 = interopRequireDefault(hull_1);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Circle = _canvax["default"].Shapes.Circle;
var Rect = _canvax["default"].Shapes.Rect;
var Line = _canvax["default"].Shapes.Line;
var Polygon = _canvax["default"].Shapes.Polygon; //TODO iGroup 的实现有问题

var ScatGraphs = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(ScatGraphs, _GraphsBase);

  var _super = _createSuper(ScatGraphs);

  function ScatGraphs(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, ScatGraphs);
    _this = _super.call(this, opt, app);
    _this.type = "scat"; //计算半径的时候需要用到， 每次执行_trimGraphs都必须要初始化一次

    _this._rData = null;
    _this._rMaxValue = null;
    _this._rMinValue = null;
    _this._alphaData = null;
    _this._alphaMaxValue = null;
    _this._alphaMinValue = null;
    _this._groupData = {}; //groupField配置有的情况下会被赋值，在_trimGraphs会被先置空，然后赋值

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(ScatGraphs.defaultProps()), opt);

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(ScatGraphs, [{
    key: "init",
    value: function init() {
      this._shapesp = new _canvax["default"].Display.Sprite({
        id: "scat_shapesp"
      });
      this._textsp = new _canvax["default"].Display.Sprite({
        id: "textsp"
      });
      this._linesp = new _canvax["default"].Display.Sprite({
        id: "textsp"
      });
      this._areasp = new _canvax["default"].Display.Sprite({
        id: "areasp"
      });
      this.sprite.addChild(this._areasp);
      this.sprite.addChild(this._linesp);
      this.sprite.addChild(this._shapesp);
      this.sprite.addChild(this._textsp);
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {});

      _.extend(true, this, opt);

      this.data = this._trimGraphs();

      this._widget();

      this.sprite.context.x = this.origin.x;
      this.sprite.context.y = this.origin.y;
      var me = this;

      if (this.animation && !opt.resize && !me.inited) {
        this.grow(function () {
          me.fire("complete");
        });
      } else {
        this.fire("complete");
      }

      this.inited = true;
      return this;
    }
  }, {
    key: "resetData",
    value: function resetData(dataFrame) {
      this.dataFrame = dataFrame;
      this.data = this._trimGraphs();

      this._widget();

      this.grow();
    }
  }, {
    key: "getNodesAt",
    value: function getNodesAt() {
      return [];
    }
  }, {
    key: "_trimGraphs",
    value: function _trimGraphs() {
      var tmplData = [];
      this._groupData = {};

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      var dataLen = this.dataFrame.length; ////计算半径的时候需要用到， 每次执行_trimGraphs都必须要初始化一次

      this._rData = null;
      this._rMaxValue = null;
      this._rMinValue = null;
      this._alphaData = null;
      this._alphaMaxValue = null;
      this._alphaMinValue = null;

      for (var i = 0; i < dataLen; i++) {
        var rowData = this.dataFrame.getRowDataAt(i);

        var fieldConfig = _coord.getFieldConfig(this.field);

        var point = _coord.getPoint({
          iNode: i,
          field: this.field,
          value: {
            //x:
            y: rowData[this.field]
          }
        });

        if (point.pos.x == undefined || point.pos.y == undefined) {
          continue;
        }
        var nodeLayoutData = {
          type: "scat",
          rowData: rowData,
          x: point.pos.x,
          y: point.pos.y,
          value: point.value,
          field: this.field,
          fieldColor: fieldConfig.color,
          iNode: i,
          focused: false,
          selected: false,
          //下面的属性都单独设置
          radius: null,
          //这里先不设置，在下面的_setR里单独设置
          fillStyle: null,
          color: null,
          strokeStyle: null,
          lineType: null,
          lineDash: null,
          strokeAlpha: 1,
          lineWidth: 0,
          shapeType: null,
          label: null,
          fillAlpha: 1,
          nodeElement: null //对应的canvax 节点， 在widget之后赋值

        };

        this._setR(nodeLayoutData);

        this._setFillStyle(nodeLayoutData);

        this._setFillAlpha(nodeLayoutData);

        this._setStrokeStyle(nodeLayoutData);

        this._setLineWidth(nodeLayoutData);

        this._setLineType(nodeLayoutData);

        this._setLineDash(nodeLayoutData);

        this._setStrokeAlpha(nodeLayoutData);

        this._setNodeType(nodeLayoutData);

        this._setText(nodeLayoutData);

        if (this.dataFilter) {
          if (_.isFunction(this.dataFilter)) {
            if (!this.dataFilter.apply(this, [nodeLayoutData])) {
              continue;
            }
          }
        } //如果有分组字段，则记录在_groupData，供后面的一些分组需求用，比如area


        if (this.groupField) {
          var groupVal = rowData[this.groupField];

          if (groupVal) {
            if (!this._groupData[groupVal]) {
              this._groupData[groupVal] = [];
            }
            !this._groupData[groupVal].push(nodeLayoutData);
          }
        } else {
          if (!this._groupData.all) {
            this._groupData.all = [];
          }

          this._groupData.all.push(nodeLayoutData);
        }

        tmplData.push(nodeLayoutData);
      }
      return tmplData;
    }
  }, {
    key: "_setR",
    value: function _setR(nodeLayoutData) {
      var r = this.node.normalRadius;
      var rowData = nodeLayoutData.rowData;

      if (this.node.radius != null) {
        if (_.isString(this.node.radius) && rowData[this.node.radius]) {
          //如果配置了某个字段作为r，那么就要自动计算比例
          if (!this._rData && !this._rMaxValue && !this._rMinValue) {
            this._rData = this.dataFrame.getFieldData(this.node.radius);
            this._rData = this._rData.filter(function (item) {
              return item || item == 0;
            });
            this._rMaxValue = _.max(this._rData);
            this._rMinValue = _.min(this._rData);
          }
          var rVal = rowData[this.node.radius];

          if (this._rMaxValue == this._rMinValue) {
            r = this.node.minRadius + (this.node.maxRadius - this.node.minRadius) / 2;
          } else {
            r = this.node.minRadius + (rVal - this._rMinValue) / (this._rMaxValue - this._rMinValue) * (this.node.maxRadius - this.node.minRadius);
          }
        }

        if (_.isFunction(this.node.radius)) {
          r = this.node.radius(rowData);
        }

        if (!isNaN(parseInt(this.node.radius))) {
          r = parseInt(this.node.radius);
        }
      }
      r = Math.max(r * this.node.radiusScale, 2);
      nodeLayoutData.radius = r;
      return this;
    }
  }, {
    key: "_setText",
    value: function _setText(nodeLayoutData) {
      if (this.label.field != null) {
        if (_.isString(this.label.field) && nodeLayoutData.rowData[this.label.field]) {
          nodeLayoutData.label = this.label.format(nodeLayoutData.rowData[this.label.field], nodeLayoutData);
        }
      }
    }
  }, {
    key: "_setFillStyle",
    value: function _setFillStyle(nodeLayoutData) {
      nodeLayoutData.color = nodeLayoutData.fillStyle = this._getStyle(this.node.fillStyle, nodeLayoutData);
      return this;
    }
  }, {
    key: "_setFillAlpha",
    value: function _setFillAlpha(nodeLayoutData) {
      // nodeLayoutData.fillAlpha = this._getProp( this.node.fillAlpha, nodeLayoutData );
      // return this;
      var alpha;
      var _alpha = this.node.fillAlpha;
      var minAlpha = this.node.minFillAlpha;
      var maxAlpha = this.node.maxFillAlpha;
      var rowData = nodeLayoutData.rowData;

      if (_alpha != null) {
        if (_.isString(_alpha) && rowData[_alpha]) {
          //如果配置了某个字段作为r，那么就要自动计算比例
          if (!this._alphaData && !this._alphaMaxValue && !this._alphaMinValue) {
            this._alphaData = this.dataFrame.getFieldData(_alpha);
            this._alphaData = this._alphaData.filter(function (item) {
              return item || item == 0;
            });
            this._alphaMaxValue = _.max(this._alphaData);
            this._alphaMinValue = _.min(this._alphaData);
          }
          var rVal = rowData[_alpha];

          if (this._alphaMaxValue == this._alphaMinValue) {
            alpha = minAlpha + (maxAlpha - minAlpha) / 2;
          } else {
            alpha = minAlpha + (rVal - this._alphaMinValue) / (this._alphaMaxValue - this._alphaMinValue) * (maxAlpha - minAlpha);
          }
        } else {
          alpha = this._getProp(this.node.fillAlpha, nodeLayoutData);
        }
      } else {
        alpha = 0;
      } //console.log(alpha)


      nodeLayoutData.fillAlpha = alpha;
      return this;
    }
  }, {
    key: "_setStrokeAlpha",
    value: function _setStrokeAlpha(nodeLayoutData) {
      nodeLayoutData.strokeAlpha = this._getProp(this.node.strokeAlpha, nodeLayoutData);
      return this;
    }
  }, {
    key: "_setStrokeStyle",
    value: function _setStrokeStyle(nodeLayoutData) {
      nodeLayoutData.strokeStyle = this._getStyle(this.node.strokeStyle || this.node.fillStyle, nodeLayoutData);
      return this;
    }
  }, {
    key: "_getProp",
    value: function _getProp(prop, nodeLayoutData) {
      var _prop = prop;

      if (_.isArray(prop)) {
        _prop = prop[nodeLayoutData.iGroup];
      }

      if (_.isFunction(prop)) {
        _prop = prop.apply(this, [nodeLayoutData]);
      }
      return _prop;
    }
  }, {
    key: "_getStyle",
    value: function _getStyle(style, nodeLayoutData) {
      var _style = style;

      if (_.isArray(style)) {
        _style = style[nodeLayoutData.iGroup];
      }

      if (_.isFunction(style)) {
        _style = style.apply(this, [nodeLayoutData]);
      }

      if (!_style) {
        _style = nodeLayoutData.fieldColor;
      }
      return _style;
    }
  }, {
    key: "_setLineWidth",
    value: function _setLineWidth(nodeLayoutData) {
      nodeLayoutData.lineWidth = this._getProp(this.node.lineWidth, nodeLayoutData);
      return this;
    }
  }, {
    key: "_setLineType",
    value: function _setLineType(nodeLayoutData) {
      nodeLayoutData.lineType = this._getProp(this.node.lineType, nodeLayoutData);
      return this;
    }
  }, {
    key: "_setLineDash",
    value: function _setLineDash(nodeLayoutData) {
      var _this2 = this;

      var _getProp = function _getProp(prop, nodeLayoutData) {
        var _prop = prop; // if( _.isArray( prop ) ){
        //     _prop = prop[ nodeLayoutData.iGroup ]
        // };

        if (_.isFunction(prop)) {
          _prop = prop.apply(_this2, [nodeLayoutData]);
        }
        return _prop;
      };

      nodeLayoutData.lineDash = _getProp(this.node.lineDash, nodeLayoutData);
      return this;
    }
  }, {
    key: "_setNodeType",
    value: function _setNodeType(nodeLayoutData) {
      var shapeType = this.node.shapeType;

      if (_.isArray(shapeType)) {
        shapeType = shapeType[nodeLayoutData.iGroup];
      }

      if (_.isFunction(shapeType)) {
        shapeType = shapeType(nodeLayoutData);
      }

      if (!shapeType) {
        shapeType = "circle";
      }
      nodeLayoutData.shapeType = shapeType;
      return this;
    } //根据layoutdata开始绘制

  }, {
    key: "_widget",
    value: function _widget() {
      var _this3 = this;

      var me = this;

      _.each(_.flatten([me._shapesp.children, me._textsp.children, me._linesp.children]), function (el) {
        el.__used = false;
      });

      _.each(me.data, function (nodeData, iNode) {
        var _nodeElement = me._getNodeElement(nodeData, iNode);

        if (!_nodeElement) {
          nodeData.__isNew = true;
        }

        var _context = me._getNodeContext(nodeData);

        var Shape = nodeData.shapeType == "circle" ? Circle : Rect; //let _nodeElement = me._shapesp.getChildAt( iNode );

        if (!_nodeElement) {
          _nodeElement = new Shape({
            id: "shape_" + iNode,
            hoverClone: false,
            context: _context
          });

          me._shapesp.addChild(_nodeElement);

          _nodeElement.on(event.types.get(), function (e) {
            e.eventInfo = {
              title: null,
              trigger: 'this.node',
              //me.node,
              nodes: [this.nodeData]
            };

            if (this.nodeData.label) {
              e.eventInfo.title = this.nodeData.label;
            }

            if (e.type == 'mouseover') {
              me.focusAt(this.nodeData);
            }

            if (e.type == 'mouseout') {
              !this.nodeData.selected && me.unfocusAt(this.nodeData);
            }
            //先触发用户事件，再处理后面的选中事件

            me.app.fire(e.type, e);
          });
        } else {
          //_nodeElement.context = _context;
          //_.extend( _nodeElement.context, _context );
          _nodeElement.animate(_context);
        }
        _nodeElement.__used = true; //数据和canvax原件相互引用

        _nodeElement.nodeData = nodeData;
        _nodeElement.iNode = iNode;
        nodeData.nodeElement = _nodeElement;

        if (me.line.enabled) {
          var _line = _nodeElement.lineElement; //me._linesp.getChildAt( iNode );

          var _lineContext = {
            start: {
              x: _context.x,
              y: _context.y + _context.r
            },
            end: {
              x: _context.x,
              y: 0
            },
            lineWidth: me.line.lineWidth,
            strokeStyle: me.line.strokeStyle,
            lineType: me.line.lineType
          };

          if (!_line) {
            _line = new Line({
              context: _lineContext
            });

            me._linesp.addChild(_line);
          } else {
            _line.animate(_lineContext);
          }
          _line.__used = true;
          _nodeElement.lineElement = _line;
        }

        if (nodeData.label && me.label.enabled) {
          var _label = _nodeElement.labelElement; //me._textsp.getChildAt( iNode );

          var _labelContext = {};

          if (!_label) {
            _label = new _canvax["default"].Display.Text(nodeData.label, {
              id: "scat_text_" + iNode,
              context: {}
            });
            _labelContext = me._getTextContext(_label, _context); //_label.animate( _labelContext );

            _.extend(_label.context, _labelContext);

            me._textsp.addChild(_label);
          } else {
            _label.resetText(nodeData.label);

            _labelContext = me._getTextContext(_label, _context);

            _label.animate(_labelContext);
          }
          _label.__used = true; //图形节点和text文本相互引用

          _nodeElement.labelElement = _label;
          _label.nodeElement = _nodeElement;
        }
      });

      if (me.area.enabled) {
        me._areasp.removeAllChildren();

        var gi = 0;

        var _loop = function _loop(_groupKey) {
          var _group = _this3._groupData[_groupKey];
          var _groupData = {
            name: _groupKey,
            iGroup: gi,
            data: _group
          };
          var _groupPoints = [];

          function getCirclePoints(nodeData, n) {
            if (!n || n == 1) {
              return [[nodeData.x, nodeData.y]];
            }
            var _points = [];

            for (var i = 0; i < n; i++) {
              var degree = 360 / (n - 1) * i;
              var r = nodeData.radius + 3;
              var x = nodeData.x + Math.cos(Math.PI * 2 / 360 * degree) * r;
              var y = nodeData.y + Math.sin(Math.PI * 2 / 360 * degree) * r;

              _points.push([x, y]);
            }
            return _points;
          }

          _.each(_group, function (nodeData) {
            _groupPoints = _groupPoints.concat(getCirclePoints(nodeData, me.area.quantile));
          });

          var areaPoints = (0, _index2["default"])(_groupPoints, me.area.concavity);
          var defStyle = me.app.getTheme(gi);
          var areaFillStyle = me._getStyle(me.area.fillStyle, _groupData) || defStyle;

          var areaFillAlpha = me._getProp(me.area.fillAlpha, _groupData);

          var areaStrokeStyle = me._getStyle(me.area.strokeStyle, _groupData) || defStyle;

          var areaLineWidth = me._getProp(me.area.lineWidth, _groupData);

          var areaStrokeAlpha = me._getProp(me.area.strokeAlpha, _groupData);

          var _areaElement = new Polygon({
            context: {
              pointList: areaPoints,
              fillStyle: areaFillStyle,
              fillAlpha: areaFillAlpha,
              strokeStyle: areaStrokeStyle,
              lineWidth: areaLineWidth,
              strokeAlpha: areaStrokeAlpha,
              smooth: false
            }
          });

          me._areasp.addChild(_areaElement);

          gi++;
        };

        for (var _groupKey in this._groupData) {
          _loop(_groupKey);
        }
      }

      _.each(_.flatten([me._shapesp.children, me._textsp.children, me._linesp.children]), function (el) {
        if (!el.__used) {
          el.animate({
            globalAlpha: 0,
            r: 0
          }, {
            onComplete: function onComplete() {
              el.destroy();
            }
          });
        }
      });

      if (me.label.enabled) {
        for (var i = 0, l = me.data.length; i < l; i++) {
          var ind = me.data.length - 1 - i;
          var currNodeData = me.data[ind];
          var currLabel = me.data[ind].nodeElement.labelElement;
          if (!currLabel) continue;
          var preNodeData = void 0,
              preLabel = void 0;

          if (ind == me.data.length - 1) {
            //第一个肯定要显示
            currLabel.context.visible = true;
          } else {
            var intersect = false;

            for (var ii = ind + 1, ll = me.data.length - 1; ii <= ll; ii++) {
              preNodeData = me.data[ii];
              preLabel = me.data[ii].nodeElement.labelElement;
              if (!preLabel.context.visible) continue;
              var currLeft = currNodeData.x - currLabel.getTextWidth() / 2;
              var currRight = currLeft + currLabel.getTextWidth();
              var currTop = currNodeData.y - currLabel.getTextHeight() / 2;
              var currBottom = currTop + currLabel.getTextHeight();
              var preLeft = preNodeData.x - preLabel.getTextWidth() / 2;
              var preRight = preLeft + preLabel.getTextWidth();
              var preTop = preNodeData.y - preLabel.getTextHeight() / 2;
              var preBottom = preTop + preLabel.getTextHeight();

              if (!(currRight < preLeft || currLeft > preRight || currBottom < preTop || currTop > preBottom)) {
                //说明curr 和 pre 两个 label相交了，那么curr要 隐藏掉
                intersect = true;
              }
            }

            if (intersect) {
              currLabel.context.visible = false;
            } else {
              currLabel.context.visible = true;
            }
          }
        }
      }
    }
  }, {
    key: "_getNodeElement",
    value: function _getNodeElement(nodeData, iNode) {
      var me = this;
      var nodeEle;
      var dataKey = me.node.dataKey;

      if (!dataKey) {
        nodeEle = me._shapesp.getChildAt(iNode);
      } else {
        if (_.isString(dataKey)) {
          dataKey = dataKey.split(",");
        }

        for (var i = 0, l = this._shapesp.children.length; i < l; i++) {
          var _nodeEle = this._shapesp.children[i];
          var isThisNodeEle = true;

          for (var ii = 0, ll = dataKey.length; ii < ll; ii++) {
            var key = dataKey[ii];

            if (_nodeEle.nodeData.rowData[key] != nodeData.rowData[key]) {
              isThisNodeEle = false;
              break;
            }
          }

          if (isThisNodeEle && dataKey.length) {
            nodeEle = _nodeEle;
            break;
          }
        }
      }
      return nodeEle;
    }
  }, {
    key: "_getTextPosition",
    value: function _getTextPosition(_label, opt) {
      var x = 0,
          y = 0;

      switch (this.label.position) {
        case "center":
          x = opt.x;
          y = opt.y;
          break;

        case "top":
          x = opt.x;
          y = opt.y - opt.r;
          break;

        case "right":
          x = opt.x + opt.r;
          y = opt.y;
          break;

        case "bottom":
          x = opt.x;
          y = opt.y + opt.r;
          break;

        case "left":
          x = opt.x - opt.r;
          y = opt.y;
          break;

        case "auto":
          x = opt.x;
          y = opt.y;

          if (_label.getTextWidth() > opt.r * 2) {
            y = opt.y + opt.r + _label.getTextHeight() * 0.5;
          }
          break;
      }
      var point = {
        x: x + this.label.offsetX,
        y: y + this.label.offsetY
      };
      return point;
    }
  }, {
    key: "_getTextContext",
    value: function _getTextContext(_label, _context) {
      var textPoint = this._getTextPosition(_label, _context);

      var fontSize = this.label.fontSize;

      if (_label.getTextWidth() > _context.r * 2) {
        fontSize -= 2;
      }
      var ctx = {
        x: textPoint.x,
        y: textPoint.y,
        fillStyle: this.label.fontColor || _context.fillStyle,
        fontSize: fontSize,
        strokeStyle: this.label.strokeStyle || _context.fillStyle,
        lineWidth: this.label.lineWidth,
        textAlign: this.label.textAlign,
        textBaseline: this.label.verticalAlign
      };

      if (this.animation && !this.inited) {
        this._setCtxAniOrigin(ctx);
      }
      return ctx;
    }
  }, {
    key: "_setCtxAniOrigin",
    value: function _setCtxAniOrigin(ctx) {
      if (this.aniOrigin == "default") {
        ctx.y = 0;
      }

      if (this.aniOrigin == "origin") {
        var _coord = this.app.getComponent({
          name: 'coord'
        });

        var originPoint = _coord.getOriginPos({
          field: this.field
        });

        ctx.x = originPoint.x;
        ctx.y = originPoint.y;
      }

      if (this.aniOrigin == "center") {
        ctx.x = this.width / 2;
        ctx.y = -(this.height / 2);
      }
    }
  }, {
    key: "_getNodeContext",
    value: function _getNodeContext(nodeData) {
      if (nodeData.shapeType == "circle") {
        return this._getCircleContext(nodeData);
      }
    }
  }, {
    key: "_getCircleContext",
    value: function _getCircleContext(nodeData) {
      var ctx = {
        x: nodeData.x,
        y: nodeData.y,
        r: nodeData.radius,
        fillStyle: nodeData.fillStyle,
        strokeStyle: nodeData.strokeStyle,
        strokeAlpha: nodeData.strokeAlpha,
        lineWidth: nodeData.lineWidth,
        lineType: nodeData.lineType,
        lineDash: nodeData.lineDash,
        fillAlpha: nodeData.fillAlpha,
        cursor: "pointer"
      };

      if (this.animation && (!this.inited || nodeData.__isNew)) {
        this._setCtxAniOrigin(ctx);

        ctx.r = 1;
      }
      return ctx;
    }
    /**
     * 生长动画
     */

  }, {
    key: "grow",
    value: function grow(callback) {
      var i = 0;
      var l = this.data.length - 1;
      var me = this;

      _.each(this.data, function (nodeData) {
        if (nodeData.__isNew) {
          me._growNode(nodeData, function () {
            i = i + 1;
            delete nodeData.__isNew;

            if (i == l) {
              callback && callback();
            }
          });
        }
      });
    }
  }, {
    key: "_growNode",
    value: function _growNode(nodeData, callback) {
      var me = this;
      nodeData.nodeElement.animate({
        x: nodeData.x,
        y: nodeData.y,
        r: nodeData.radius
      }, {
        onUpdate: function onUpdate(opt) {
          if (this.labelElement && this.labelElement.context) {
            var _textPoint = me._getTextPosition(this.labelElement, opt);

            this.labelElement.context.x = _textPoint.x;
            this.labelElement.context.y = _textPoint.y;
          }

          if (this.lineElement && this.lineElement.context) {
            this.lineElement.context.start.y = opt.y + opt.r;
          }
        },
        delay: Math.round(Math.random() * 300),
        onComplete: function onComplete() {
          callback && callback();
        }
      });
    }
  }, {
    key: "focusAt",
    value: function focusAt(target) {
      var nodeData;
      var iNode;

      if ((0, _typeof2["default"])(target) == 'object') {
        nodeData = target;
      } else {
        iNode = target;
        nodeData = this.data.find(function (item) {
          return item.iNode == iNode;
        });
      }

      if (!this.node.focus.enabled || nodeData.focused) return;
      var nctx = nodeData.nodeElement.context;
      nctx.lineWidth = this._getProp(this.node.focus.lineWidth, nodeData);
      nctx.strokeAlpha = this._getProp(this.node.focus.strokeAlpha, nodeData);
      nctx.fillAlpha = this._getProp(this.node.focus.fillAlpha, nodeData);
      nodeData.focused = true;
    }
  }, {
    key: "unfocusAt",
    value: function unfocusAt(target) {
      var nodeData;
      var iNode;

      if ((0, _typeof2["default"])(target) == 'object') {
        nodeData = target;
      } else {
        iNode = target;
        nodeData = this.data.find(function (item) {
          return item.iNode == iNode;
        });
      }

      if (!this.node.focus.enabled || !nodeData.focused) return;
      var nctx = nodeData.nodeElement.context;
      nctx.lineWidth = this._getProp(nodeData.lineWidth, nodeData);
      nctx.strokeAlpha = this._getProp(nodeData.strokeAlpha, nodeData);
      nctx.fillAlpha = this._getProp(nodeData.fillAlpha, nodeData);
      nctx.strokeStyle = this._getProp(nodeData.strokeStyle, nodeData);
      nodeData.focused = false;
    }
  }, {
    key: "selectAt",
    value: function selectAt(target) {
      //let nodeData = this.data[ ind ];
      var nodeData;
      var iNode;

      if ((0, _typeof2["default"])(target) == 'object') {
        nodeData = target;
      } else {
        iNode = target;
        nodeData = this.data.find(function (item) {
          return item.iNode == iNode;
        });
      }

      if (!this.node.select.enabled || nodeData.selected) return;
      var nctx = nodeData.nodeElement.context;
      nctx.lineWidth = this._getProp(this.node.select.lineWidth, nodeData);
      nctx.strokeAlpha = this._getProp(this.node.select.strokeAlpha, nodeData);
      nctx.fillAlpha = this._getProp(this.node.select.fillAlpha, nodeData);
      nodeData.selected = true;
    }
  }, {
    key: "unselectAt",
    value: function unselectAt(target) {
      //let nodeData = this.data[ ind ];
      var nodeData;
      var iNode;

      if ((0, _typeof2["default"])(target) == 'object') {
        nodeData = target;
      } else {
        iNode = target;
        nodeData = this.data.find(function (item) {
          return item.iNode == iNode;
        });
      }

      if (!this.node.select.enabled || !nodeData.selected) return;
      var nctx = nodeData.nodeElement.context;

      if (nodeData.focused) {
        //有e 说明这个函数是事件触发的，鼠标肯定还在node上面
        nctx.lineWidth = this._getProp(this.node.focus.lineWidth, nodeData);
        nctx.strokeAlpha = this._getProp(this.node.focus.strokeAlpha, nodeData);
        nctx.fillAlpha = this._getProp(this.node.focus.fillAlpha, nodeData);
      } else {
        nctx.lineWidth = nodeData.lineWidth;
        nctx.strokeAlpha = nodeData.strokeAlpha;
        nctx.fillAlpha = nodeData.fillAlpha;
      }
      nodeData.selected = false;
    }
  }, {
    key: "getNodesOfPos",
    value: function getNodesOfPos() {
      //sat的 getNodesOfPos 一定要有两个点
      var _nodesInfoList = []; //节点信息集合

      return _nodesInfoList;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: '字段配置',
          "default": null
        },
        groupField: {
          detail: '分组字段',
          "default": null,
          documentation: '分组字段，如果area配置enabled为true，那么需要groupField来构建几个area'
        },
        // sortField: {
        //     detail: '排序字段',
        //     default: null,
        //     documentation: '在需要按照优先级显示label的时候有用'
        // },
        dataFilter: {
          detail: '散点过滤数据',
          "default": null,
          documentation: "数据过滤器，可以和groupField实现交叉过滤"
        },
        aniOrigin: {
          detail: '节点动画的原点',
          "default": 'default',
          documentation: '可选的还有center（坐标正中）、origin（坐标原点）'
        },
        node: {
          detail: '单数据节点图形设置',
          propertys: {
            dataKey: {
              detail: '元素的数据id，默认索引匹配',
              "default": '__index__'
            },
            shapeType: {
              detail: '图形类型',
              "default": 'circle',
              documentation: '节点的现状可以是圆 ，也可以是rect，也可以是三角形，后面两种后面实现'
            },
            maxRadius: {
              detail: '节点最大半径',
              "default": 25
            },
            minRadius: {
              detail: '节点最小半径',
              "default": 5
            },
            radius: {
              detail: '半径',
              "default": null
            },
            radiusScale: {
              detail: '半径缩放比例',
              documentation: '在计算好真实半径后缩放，主要用在,缩略图中，比如datazoom的缩略图',
              "default": 1
            },
            normalRadius: {
              detail: '默认半径',
              "default": 15
            },
            fillStyle: {
              detail: '节点景色',
              "default": null
            },
            fillAlpha: {
              detail: '节点透明度',
              "default": 0.8
            },
            maxFillAlpha: {
              detail: '节点最大透明度',
              "default": 1
            },
            minFillAlpha: {
              detail: '节点最小透明度',
              "default": 0.2
            },
            strokeStyle: {
              detail: '节点描边颜色',
              "default": null
            },
            lineWidth: {
              detail: '节点描边线宽',
              "default": 0
            },
            lineType: {
              detail: '描边样式',
              "default": 'solid'
            },
            lineDash: {
              detail: '虚线样式',
              "default": [2, 6]
            },
            strokeAlpha: {
              detail: '节点描边透明度',
              "default": 1
            },
            focus: {
              detail: "节点hover态设置",
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": true
                },
                lineWidth: {
                  detail: 'hover后的边框大小',
                  "default": 6
                },
                strokeAlpha: {
                  detail: 'hover后的边框透明度',
                  "default": 0.2
                },
                fillAlpha: {
                  detail: 'hover后的背景透明度',
                  "default": 0.8
                }
              }
            },
            select: {
              detail: "节点选中态设置",
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": false
                },
                lineWidth: {
                  detail: '选中后的边框大小',
                  "default": 8
                },
                strokeAlpha: {
                  detail: '选中后的边框透明度',
                  "default": 0.4
                },
                fillAlpha: {
                  detail: '选中后的背景透明度',
                  "default": 1
                }
              }
            }
          }
        },
        line: {
          detail: '每个节点和指标轴线的连线',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": false
            },
            lineWidth: {
              detail: '连线宽',
              "default": 1
            },
            strokeStyle: {
              detail: '连线颜色',
              "default": '#ccc'
            },
            lineType: {
              detail: '连线类型',
              "default": 'dashed'
            }
          }
        },
        area: {
          detail: '散点集合组成的面',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": false
            },
            concavity: {
              detail: '凹凸系数，默认80，越大越凸',
              "default": 88
            },
            quantile: {
              detail: '散点用来计入面积的分位数',
              "default": 8
            },
            fillStyle: {
              detail: '散点集合面的背景色',
              "default": null
            },
            fillAlpha: {
              detail: '散点集合面的透明度',
              "default": 0.15
            },
            strokeStyle: {
              detail: '散点集合面的描边颜色',
              "default": null
            },
            lineWidth: {
              detail: '散点集合面的描边线宽',
              "default": 0
            },
            strokeAlpha: {
              detail: '散点集合面的描边透明度',
              "default": 0.5
            }
          }
        },
        label: {
          detail: '文本设置',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": true
            },
            field: {
              detail: '获取label的字段',
              "default": null
            },
            format: {
              detail: 'label格式化处理函数',
              "default": function _default(txt) {
                return txt;
              }
            },
            fontSize: {
              detail: 'label字体大小',
              "default": 13
            },
            fontColor: {
              detail: '字体颜色',
              "default": '#888'
            },
            strokeStyle: {
              detail: '字体描边颜色',
              "default": '#ffffff'
            },
            lineWidth: {
              detail: '描边大小',
              "default": 0
            },
            textAlign: {
              detail: '水平对齐方式',
              "default": 'center'
            },
            verticalAlign: {
              detail: '垂直基线对齐方式',
              "default": 'middle'
            },
            position: {
              detail: '文本布局位置',
              documentation: 'auto(目前等于center，还未实现),center,top,right,bottom,left',
              "default": 'center'
            },
            offsetX: {
              detail: 'x方向偏移量',
              "default": 0
            },
            offsetY: {
              detail: 'y方向偏移量',
              "default": 0
            }
          }
        }
      };
    }
  }]);
  return ScatGraphs;
}(_index["default"]);

_index["default"].registerComponent(ScatGraphs, 'graphs', 'scat');

var _default2 = ScatGraphs;
exports["default"] = _default2;
});

unwrapExports(scat);

var pie = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Sector = _canvax["default"].Shapes.Sector;
var Path = _canvax["default"].Shapes.Path;
var Text = _canvax["default"].Display.Text;
var AnimationFrame = _canvax["default"].AnimationFrame;

var Pie = /*#__PURE__*/function (_event$Dispatcher) {
  (0, _inherits2["default"])(Pie, _event$Dispatcher);

  var _super = _createSuper(Pie);

  function Pie(_graphs, data) {
    var _this;

    (0, _classCallCheck2["default"])(this, Pie);
    _this = _super.call(this);
    _this.width = 0;
    _this.height = 0;
    _this.origin = {
      x: 0,
      y: 0
    }; //这个pie所属的graphs对象

    _this._graphs = _graphs;
    _this.domContainer = _graphs.app.canvax.domView;
    _this.data = data;
    _this.sprite = null;
    _this.textSp = null;
    _this.sectorsSp = null;
    _this.selectedSp = null;

    _this.init();

    _this.sectors = [];
    _this.textMaxCount = 15;
    _this.textList = [];
    _this.completed = false; //首次加载动画是否完成

    return _this;
  }

  (0, _createClass2["default"])(Pie, [{
    key: "init",
    value: function init() {
      this.sprite = new _canvax["default"].Display.Sprite();
      this.sectorsSp = new _canvax["default"].Display.Sprite();
      this.sprite.addChild(this.sectorsSp);
      this.selectedSp = new _canvax["default"].Display.Sprite();
      this.sprite.addChild(this.selectedSp);

      if (this._graphs.label.enabled) {
        this.textSp = new _canvax["default"].Display.Sprite();
      }
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      var me = this;

      _.extend(true, this, opt);

      this.sprite.context.x = me.origin.x;
      this.sprite.context.y = me.origin.y;

      me._widget();
    }
  }, {
    key: "resetData",
    value: function resetData(data) {
      var me = this;
      this.data = data;
      me.destroyLabel();
      var completedNum = 0;

      for (var i = 0; i < me.sectors.length; i++) {
        var sec = me.sectors[i];
        var secData = this.data.list[i];
        sec.animate({
          r: secData.outRadius,
          startAngle: secData.startAngle,
          endAngle: secData.endAngle
        }, {
          duration: 280,
          onComplete: function onComplete() {
            completedNum++;

            if (completedNum == me.sectors.length) {
              if (me._graphs.label.enabled) {
                me._startWidgetLabel();
              }
            }
          }
        });
      }
    }
  }, {
    key: "_widget",
    value: function _widget() {
      var me = this;
      var list = me.data.list;
      var total = me.data.total; //let moreSecData;

      if (list.length > 0 && total > 0) {
        me.textSp && me.sprite.addChild(me.textSp);

        for (var i = 0; i < list.length; i++) {
          var item = list[i]; //扇形主体          

          var sector = new Sector({
            hoverClone: false,
            xyToInt: false,
            //扇形不需要自动取整
            context: {
              x: item.focused ? item.outOffsetx : 0,
              y: item.focused ? item.outOffsety : 0,
              r0: item.innerRadius,
              r: item.outRadius,
              startAngle: item.startAngle,
              endAngle: item.endAngle,
              fillStyle: item.fillStyle,
              //iNode: item.iNode,
              cursor: "pointer"
            },
            id: 'sector' + i
          });
          sector.nodeData = item;
          item.focusEnabled && sector.hover(function () {
            me.focusOf(this.nodeData);
          }, function () {
            !this.nodeData.selected && me.unfocusOf(this.nodeData);
          }); //触发注册的事件

          sector.on(event.types.get(), function (e) {
            //me.fire( e.type, e );
            e.eventInfo = {
              trigger: 'this._graphs.node',
              //me._graphs.node,
              nodes: [this.nodeData]
            }; //图表触发，用来处理Tips

            me._graphs.app.fire(e.type, e);
          });
          me.sectorsSp.addChildAt(sector, 0);
          me.sectors.push(sector);
        }

        if (me._graphs.label.enabled) {
          me._startWidgetLabel();
        }
      }
    }
  }, {
    key: "focusOf",
    value: function focusOf(node, callback) {
      if (node.focused) return;
      var me = this;
      var sec = me.sectors[node.iNode];
      sec.animate({
        //x: node.outOffsetx,
        //y: node.outOffsety
        r: node.outRadius + node.moveDis
      }, {
        duration: 100,
        onComplete: function onComplete() {
          callback && callback();
        }
      });
      node.focused = true;
    }
  }, {
    key: "unfocusOf",
    value: function unfocusOf(node, callback) {
      if (!node.focused) return;
      var me = this;
      var sec = me.sectors[node.iNode];
      sec.animate({
        //x: 0,
        //y: 0
        r: node.outRadius
      }, {
        duration: 100,
        onComplete: function onComplete() {
          callback && callback();
        }
      });
      node.focused = false;
    }
  }, {
    key: "selectOf",
    value: function selectOf(node) {
      var me = this;

      if (!this.sectors.length || !node.selectEnabled) {
        return;
      }
      var sec = this.sectors[node.iNode];

      if (node.selected) {
        return;
      }

      if (!node.focused) {
        node._focusTigger = "select";
        this.focusOf(node, function () {
          me.addCheckedSec(sec);
        });
      } else {
        this.addCheckedSec(sec);
      }
      node.selected = true;
    }
  }, {
    key: "unselectOf",
    value: function unselectOf(node) {
      var sec = this.sectors[node.iNode];

      if (!node.selected || !node.selectEnabled) {
        return;
      }
      var me = this;
      me.cancelCheckedSec(sec, function () {
        if (node._focusTigger == "select") {
          me.unfocusOf(node);
        }
      });
      node.selected = false;
    }
  }, {
    key: "addCheckedSec",
    value: function addCheckedSec(sec, callback) {
      var secc = sec.context;
      var nodeData = sec.nodeData;
      if (!secc) return;
      var sector = new Sector({
        xyToInt: false,
        context: {
          x: secc.x,
          y: secc.y,
          r0: secc.r - 1,
          r: secc.r + nodeData.selectedR,
          startAngle: secc.startAngle,
          endAngle: secc.startAngle,
          //secc.endAngle,
          fillStyle: secc.fillStyle,
          globalAlpha: nodeData.selectedAlpha
        },
        id: 'selected_' + sec.id
      });
      sec._selectedSec = sector;
      this.selectedSp.addChild(sector);

      if (this.completed) {
        sector.animate({
          endAngle: secc.endAngle
        }, {
          duration: this._getAngleTime(secc),
          onComplete: function onComplete() {
            callback && callback();
          }
        });
      } else {
        sector.context.endAngle = secc.endAngle;
      }
    }
  }, {
    key: "cancelCheckedSec",
    value: function cancelCheckedSec(sec, callback) {
      var selectedSec = sec._selectedSec;
      selectedSec.animate({
        startAngle: selectedSec.context.endAngle - 0.5
      }, {
        duration: this._getAngleTime(sec.context),
        onComplete: function onComplete() {
          delete sec._selectedSec;
          selectedSec.destroy();
          callback && callback();
        }
      });
    }
  }, {
    key: "_getAngleTime",
    value: function _getAngleTime(secc) {
      return Math.abs(secc.startAngle - secc.endAngle) / 360 * 500;
    }
  }, {
    key: "grow",
    value: function grow(callback) {
      var me = this;

      _.each(me.sectors, function (sec) {
        if (sec.context) {
          sec.context.r0 = 0;
          sec.context.r = 0;
          sec.context.startAngle = me._graphs.startAngle;
          sec.context.endAngle = me._graphs.startAngle;
        }
      });

      me._hideGrowLabel();

      var _tween = AnimationFrame.registTween({
        from: {
          process: 0
        },
        to: {
          process: 1
        },
        duration: 500,
        onUpdate: function onUpdate(status) {
          for (var i = 0; i < me.sectors.length; i++) {
            var sec = me.sectors[i];
            var nodeData = sec.nodeData;
            var secc = sec.context;
            var _startAngle = nodeData.startAngle;
            var _endAngle = nodeData.endAngle;
            var _r = nodeData.outRadius;
            var _r0 = nodeData.innerRadius;

            if (secc) {
              secc.r = _r * status.process;
              secc.r0 = _r0 * status.process;

              if (i == 0) {
                secc.startAngle = _startAngle;
                secc.endAngle = _startAngle + (_endAngle - _startAngle) * status.process;
              } else {
                var lastEndAngle = function (iNode) {
                  var lastIndex = iNode - 1;
                  var lastSecc = me.sectors[lastIndex].context;

                  if (lastIndex == 0) {
                    return lastSecc ? lastSecc.endAngle : 0;
                  }

                  if (lastSecc) {
                    return lastSecc.endAngle;
                  } else {
                    return arguments.callee(lastIndex);
                  }
                }(i);

                secc.startAngle = lastEndAngle;
                secc.endAngle = secc.startAngle + (_endAngle - _startAngle) * status.process;
              } //如果已经被选中，有一个选中态


              if (sec._selectedSec) {
                sec._selectedSec.context.r0 = secc.r - 1;
                sec._selectedSec.context.r = secc.r + nodeData.selectedR;
                sec._selectedSec.context.startAngle = secc.startAngle;
                sec._selectedSec.context.endAngle = secc.endAngle;
              }
            }
          }
        },
        onComplete: function onComplete() {
          //把下面me.sprite._tweens.push( _tween );的 动画实例删除
          me.sprite._removeTween(_tween);

          me._showGrowLabel();

          me.completed = true;
          callback && callback();
        }
      });

      me.sprite._tweens.push(_tween);
    }
  }, {
    key: "_widgetLabel",
    value: function _widgetLabel(quadrant, indexs, lmin, rmin, isEnd, ySpaceInfo) {
      var me = this;
      var count = 0;
      var data = me.data.list;
      var minTxtDis = 15;
      var textOffsetX = 5;
      var currentIndex;
      var preY, currentY, adjustX, txtDis, bwidth, bheight, bx, by;
      var yBound, remainingNum, remainingY;
      var isleft = quadrant == 2 || quadrant == 3;
      var isup = quadrant == 3 || quadrant == 4;
      var minY = isleft ? lmin : rmin; //text的绘制顺序做修正，text的Y值在饼图上半部分（isup）时，Y值越小的先画，反之Y值在饼图下部分时，Y值越大的先画.

      if (indexs.length > 0) {
        indexs.sort(function (a, b) {
          return isup ? data[a].edgey - data[b].edgey : data[b].edgey - data[a].edgey;
        });
      }

      for (var i = 0; i < indexs.length; i++) {
        currentIndex = indexs[i];
        var itemData = data[currentIndex];
        var outCircleRadius = itemData.outRadius + itemData.moveDis; //若Y值小于最小值，不画text    

        if (!itemData.enabled || itemData.y < minY || count >= me.textMaxCount) continue;
        count++;
        currentY = itemData.edgey;
        adjustX = Math.abs(itemData.edgex);
        txtDis = currentY - preY;

        if (i != 0 && (Math.abs(txtDis) < minTxtDis || isup && txtDis < 0 || !isup && txtDis > 0)) {
          currentY = isup ? preY + minTxtDis : preY - minTxtDis;

          if (outCircleRadius - Math.abs(currentY) > 0) {
            adjustX = Math.sqrt(Math.pow(outCircleRadius, 2) - Math.pow(currentY, 2));
          }

          if (isleft && -adjustX > itemData.edgex || !isleft && adjustX < itemData.edgex) {
            adjustX = Math.abs(itemData.edgex);
          }
        }

        if (isEnd) {
          yBound = isleft ? ySpaceInfo.left : ySpaceInfo.right;
          remainingNum = indexs.length - i;
          remainingY = isup ? yBound - remainingNum * minTxtDis : yBound + remainingNum * minTxtDis;

          if (isup && currentY > remainingY || !isup && currentY < remainingY) {
            currentY = remainingY;
          }
        }

        preY = currentY;

        if (!isEnd) {
          if (isleft) {
            ySpaceInfo.left = preY;
          } else {
            ySpaceInfo.right = preY;
          }
        }
        var currentX = isleft ? -adjustX - textOffsetX : adjustX + textOffsetX;
        var globalX = currentX + me.origin.x;
        var globalY = currentY + me.origin.y;

        if (globalX > me._graphs.app.width || globalY < 0 || globalY > me._graphs.app.height) {
          return;
        }
        var pathStr = "M" + itemData.centerx + "," + itemData.centery;
        pathStr += "Q" + itemData.outx + "," + itemData.outy + "," + currentX + "," + currentY;
        var path = new Path({
          context: {
            lineType: 'solid',
            path: pathStr,
            lineWidth: 1,
            strokeStyle: itemData.fillStyle
          }
        });
        var textTxt = itemData.labelText;
        var textEle = void 0;

        if (me.domContainer) {
          textEle = document.createElement("div");
          textEle.style.cssText = " ;position:absolute;left:-1000px;top:-1000px;color:" + itemData.fillStyle + "";
          textEle.innerHTML = textTxt;
          me.domContainer.appendChild(textEle);
          bwidth = textEle.offsetWidth;
          bheight = textEle.offsetHeight;
        } else {
          //小程序等版本里面没有domContainer， 需要直接用cavnas绘制
          textEle = new Text(textTxt, {
            context: {
              fillStyle: itemData.fillStyle
            }
          });
          me.textSp.addChild(textEle);
          bwidth = Math.ceil(textEle.getTextWidth());
          bheight = Math.ceil(textEle.getTextHeight());
        }

        bx = isleft ? -adjustX : adjustX;
        by = currentY;

        switch (quadrant) {
          case 1:
            bx += textOffsetX;
            by -= bheight / 2;
            break;

          case 2:
            bx -= bwidth + textOffsetX;
            by -= bheight / 2;
            break;

          case 3:
            bx -= bwidth + textOffsetX;
            by -= bheight / 2;
            break;

          case 4:
            bx += textOffsetX;
            by -= bheight / 2;
            break;
        }

        if (textEle.style) {
          textEle.style.left = bx + me.origin.x + "px";
          textEle.style.top = by + me.origin.y + "px";
        } else if (textEle.context) {
          textEle.context.x = bx;
          textEle.context.y = by;
        }
        me.textSp.addChild(path);
        me.textList.push({
          width: bwidth,
          height: bheight,
          x: bx + me.origin.x,
          y: by + me.origin.y,
          data: itemData,
          textTxt: textTxt,
          textEle: textEle
        });
      }
    }
  }, {
    key: "_startWidgetLabel",
    value: function _startWidgetLabel() {
      var me = this;
      var data = me.data.list;
      var rMinPercentage = 0,
          lMinPercentage = 0,
          rMinY = 0,
          lMinY = 0;
      var quadrantsOrder = [];
      var quadrantInfo = [{
        indexs: [],
        count: 0
      }, {
        indexs: [],
        count: 0
      }, {
        indexs: [],
        count: 0
      }, {
        indexs: [],
        count: 0
      }]; //默认从top开始画

      var widgetInfo = {
        right: {
          startQuadrant: 4,
          endQuadrant: 1,
          clockwise: true,
          indexs: []
        },
        left: {
          startQuadrant: 3,
          endQuadrant: 2,
          clockwise: false,
          indexs: []
        }
      };

      for (var i = 0; i < data.length; i++) {
        var cur = data[i].quadrant;
        quadrantInfo[cur - 1].indexs.push(i);
        quadrantInfo[cur - 1].count++;
      } //1,3象限的绘制顺序需要反转


      if (quadrantInfo[0].count > 1) quadrantInfo[0].indexs.reverse();
      if (quadrantInfo[2].count > 1) quadrantInfo[2].indexs.reverse();

      if (quadrantInfo[0].count > quadrantInfo[3].count) {
        widgetInfo.right.startQuadrant = 1;
        widgetInfo.right.endQuadrant = 4;
        widgetInfo.right.clockwise = false;
      }

      if (quadrantInfo[1].count > quadrantInfo[2].count) {
        widgetInfo.left.startQuadrant = 2;
        widgetInfo.left.endQuadrant = 3;
        widgetInfo.left.clockwise = true;
      }

      widgetInfo.right.indexs = quadrantInfo[widgetInfo.right.startQuadrant - 1].indexs.concat(quadrantInfo[widgetInfo.right.endQuadrant - 1].indexs);
      widgetInfo.left.indexs = quadrantInfo[widgetInfo.left.startQuadrant - 1].indexs.concat(quadrantInfo[widgetInfo.left.endQuadrant - 1].indexs);
      var overflowIndexs, sortedIndexs;

      if (widgetInfo.right.indexs.length > me.textMaxCount) {
        sortedIndexs = widgetInfo.right.indexs.slice(0);
        sortedIndexs.sort(function (a, b) {
          return data[b].y - data[a].y;
        });
        overflowIndexs = sortedIndexs.slice(me.textMaxCount);
        rMinPercentage = data[overflowIndexs[0]].percentage;
        rMinY = data[overflowIndexs[0]].y;
      }

      if (widgetInfo.left.indexs.length > me.textMaxCount) {
        sortedIndexs = widgetInfo.left.indexs.slice(0);
        sortedIndexs.sort(function (a, b) {
          return data[b].y - data[a].y;
        });
        overflowIndexs = sortedIndexs.slice(me.textMaxCount);
        lMinPercentage = data[overflowIndexs[0]].percentage;
        lMinY = data[overflowIndexs[0]].y;
      }

      quadrantsOrder.push(widgetInfo.right.startQuadrant);
      quadrantsOrder.push(widgetInfo.right.endQuadrant);
      quadrantsOrder.push(widgetInfo.left.startQuadrant);
      quadrantsOrder.push(widgetInfo.left.endQuadrant);
      var ySpaceInfo = {};

      for (var _i = 0; _i < quadrantsOrder.length; _i++) {
        var isEnd = _i == 1 || _i == 3;

        me._widgetLabel(quadrantsOrder[_i], quadrantInfo[quadrantsOrder[_i] - 1].indexs, lMinY, rMinY, isEnd, ySpaceInfo);
      }
    }
  }, {
    key: "destroyLabel",
    value: function destroyLabel() {
      var me = this;

      if (this.textSp) {
        this.textSp.removeAllChildren();
      }

      _.each(this.textList, function (lab) {
        if (me.domContainer) {
          me.domContainer.removeChild(lab.textEle);
        }
      });

      this.textList = [];
    }
  }, {
    key: "_showGrowLabel",
    value: function _showGrowLabel() {
      if (this.textSp && this.textSp.context) {
        this.textSp.context.globalAlpha = 1;

        _.each(this.textList, function (lab) {
          if (lab.textEle.style) {
            lab.textEle.style.visibility = "visible";
          }
        });
      }
    }
  }, {
    key: "_hideGrowLabel",
    value: function _hideGrowLabel() {
      if (this.textSp && this.textSp.context) {
        this.textSp.context.globalAlpha = 0;

        _.each(this.textList, function (lab) {
          if (lab.textEle.style) {
            lab.textEle.style.visibility = "hidden";
          }
        });
      }
    }
  }]);
  return Pie;
}(event.Dispatcher);

exports["default"] = Pie;
});

unwrapExports(pie);

var pie$1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _pie = interopRequireDefault(pie);

var _index = interopRequireDefault(graphs);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var PieGraphs = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(PieGraphs, _GraphsBase);

  var _super = _createSuper(PieGraphs);

  function PieGraphs(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, PieGraphs);
    _this = _super.call(this, opt, app);
    _this.type = "pie";

    Canvax._.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(PieGraphs.defaultProps()), opt);

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(PieGraphs, [{
    key: "init",
    value: function init() {
      //初步设置下data，主要legend等需要用到
      this.data = this._dataHandle();
    }
  }, {
    key: "_computerProps",
    value: function _computerProps() {
      var w = this.width;
      var h = this.height; //根据配置情况重新修正 outRadius ，innerRadius ------------

      if (!this.node.outRadius) {
        var outRadius = Math.min(w, h) / 2;

        if (this.label.enabled) {
          //要预留moveDis位置来hover sector 的时候外扩
          outRadius -= this.node.moveDis;
        }
        this.node.outRadius = parseInt(outRadius);
      }

      if (this.node.radius !== null && Canvax._.isNumber(this.node.radius)) {
        //如果用户有直接配置 radius，那么radius优先，用来计算
        this.node.radius = Math.max(this.node.radius, this.node.minRadius); //this.node.outRadius = this.node.innerRadius + this.node.radius;

        this.node.innerRadius = this.node.outRadius - this.node.radius;
      }

      if (this.node.outRadius - this.node.innerRadius < this.node.minRadius) {
        this.node.innerRadius = this.node.outRadius - this.node.minRadius;
      }

      if (this.node.innerRadius < 0) {
        this.node.innerRadius = 0;
      }
    }
    /**
     * opt ==> {width,height,origin}
     */

  }, {
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {});

      Canvax._.extend(true, this, opt);

      this._computerProps(); //这个时候就是真正的计算布局用得layoutdata了


      this._pie = new _pie["default"](this, this._trimGraphs(this.data));

      this._pie.draw(opt);

      var me = this;

      if (this.animation && !opt.resize) {
        this._pie.grow(function () {
          me.fire("complete");
        });
      } else {
        this.fire("complete");
      }

      this.sprite.addChild(this._pie.sprite);
    }
  }, {
    key: "show",
    value: function show(label) {
      this._setEnabled(label, true);
    }
  }, {
    key: "hide",
    value: function hide(label) {
      this._setEnabled(label, false);
    }
  }, {
    key: "_setEnabled",
    value: function _setEnabled(label, status) {
      var me = this;

      Canvax._.each(this.data, function (item) {
        if (item.label === label) {
          item.enabled = status;
          return false;
        }
      });

      me._pie.resetData(me._trimGraphs(me.data));
    }
  }, {
    key: "_dataHandle",
    value: function _dataHandle() {
      var me = this; //let _coord = me.app.getComponent({name:'coord'});

      var data = [];
      var dataFrame = me.dataFrame;

      for (var i = 0, l = dataFrame.length; i < l; i++) {
        var rowData = dataFrame.getRowDataAt(i);
        var layoutData = {
          type: "pie",
          field: me.field,
          rowData: rowData,
          //把这一行数据给到layoutData引用起来
          focused: false,
          //是否获取焦点，外扩
          focusEnabled: me.node.focus.enabled,
          selected: false,
          //是否选中
          selectEnabled: me.node.select.enabled,
          selectedR: me.node.select.radius,
          selectedAlpha: me.node.select.alpha,
          enabled: true,
          //是否启用，显示在列表中
          fillStyle: null,
          color: null,
          //加个color属性是为了给tips用
          value: rowData[me.field],
          label: rowData[me.keyField || me.field],
          labelText: null,
          //绘制的时候再设置,label format后的数据
          iNode: i
        }; //设置颜色

        var color = me._getColor(me.node.fillStyle, layoutData);

        layoutData.fillStyle = layoutData.color = color;
        data.push(layoutData);
      }

      if (data.length && me.sort) {
        data.sort(function (a, b) {
          if (me.sort == 'asc') {
            return a.value - b.value;
          } else {
            return b.value - a.value;
          }
        }); //重新设定下ind

        Canvax._.each(data, function (d, i) {
          d.iNode = i;
        });
      }
      return data;
    }
  }, {
    key: "_trimGraphs",
    value: function _trimGraphs(data) {
      var me = this;
      var total = 0;
      me.currentAngle = 0 + me.startAngle % 360; //me.allAngle;

      var limitAngle = me.allAngle + me.startAngle % me.allAngle;
      var percentFixedNum = 2; //下面连个变量当node.r设置为数据字段的时候用

      var maxRval = 0;
      var minRval = 0;

      if (data.length) {
        //先计算出来value的总量
        for (var i = 0; i < data.length; i++) {
          //enabled为false的secData不参与计算
          if (!data[i].enabled) continue;
          total += data[i].value;

          if (me.node.radius && Canvax._.isString(me.node.radius) && me.node.radius in data[i].rowData) {
            var _r = Number(data[i].rowData[me.node.radius]);

            maxRval = Math.max(maxRval, _r);
            minRval = Math.min(minRval, _r);
          }
        }

        if (total > 0) {
          for (var j = 0; j < data.length; j++) {
            var percentage = data[j].value / total; //enabled为false的sec，比率就设置为0

            if (!data[j].enabled) {
              percentage = 0;
            }
            var fixedPercentage = +(percentage * 100).toFixed(percentFixedNum);
            var angle = me.allAngle * percentage;
            var endAngle = me.currentAngle + angle > limitAngle ? limitAngle : me.currentAngle + angle;
            var cosV = Math.cos((me.currentAngle + angle / 2) / 180 * Math.PI);
            var sinV = Math.sin((me.currentAngle + angle / 2) / 180 * Math.PI);
            var midAngle = me.currentAngle + angle / 2; //cosV = cosV.toFixed(5);
            //sinV = sinV.toFixed(5);

            var quadrant = function (ang) {
              if (ang >= limitAngle) {
                ang = limitAngle;
              }

              ang = ang % me.allAngle;
              var angleRatio = parseInt(ang / 90);

              if (ang >= 0) {
                switch (angleRatio) {
                  case 0:
                    return 1;

                  case 1:
                    return 2;

                  case 2:
                    return 3;

                  case 3:
                  case 4:
                    return 4;
                }
              } else if (ang < 0) {
                switch (angleRatio) {
                  case 0:
                    return 4;

                  case -1:
                    return 3;

                  case -2:
                    return 2;

                  case -3:
                  case -4:
                    return 1;
                }
              }
            }(midAngle);

            var outRadius = me.node.outRadius;

            if (me.node.radius && Canvax._.isString(me.node.radius) && me.node.radius in data[j].rowData) {
              var _rr = Number(data[j].rowData[me.node.radius]);

              outRadius = parseInt((me.node.outRadius - me.node.innerRadius) * ((_rr - minRval) / (maxRval - minRval)) + me.node.innerRadius);
            }
            var moveDis = me.node.moveDis;

            Canvax._.extend(data[j], {
              outRadius: outRadius,
              innerRadius: me.node.innerRadius,
              startAngle: me.currentAngle,
              //起始角度
              endAngle: endAngle,
              //结束角度
              midAngle: midAngle,
              //中间角度
              moveDis: moveDis,
              outOffsetx: moveDis * 0.7 * cosV,
              //focus的事实外扩后圆心的坐标x
              outOffsety: moveDis * 0.7 * sinV,
              //focus的事实外扩后圆心的坐标y
              centerx: outRadius * cosV,
              centery: outRadius * sinV,
              outx: (outRadius + moveDis) * cosV,
              outy: (outRadius + moveDis) * sinV,
              edgex: (outRadius + moveDis) * cosV,
              edgey: (outRadius + moveDis) * sinV,
              orginPercentage: percentage,
              percentage: fixedPercentage,
              quadrant: quadrant,
              //象限
              labelDirection: quadrant == 1 || quadrant == 4 ? 1 : 0,
              iNode: j
            }); //这个时候可以计算下label，因为很多时候外部label如果是配置的


            data[j].labelText = me._getLabelText(data[j]);
            data[j].subValue = fixedPercentage + "%";
            me.currentAngle += angle;

            if (me.currentAngle > limitAngle) {
              me.currentAngle = limitAngle;
            }
          }
        }
      }

      return {
        list: data,
        total: total
      };
    }
  }, {
    key: "_getColor",
    value: function _getColor(prop, layoutData) {
      var me = this;
      var iNode = layoutData.iNode;
      var color = prop;

      if (Canvax._.isArray(prop)) {
        color = prop[iNode];
      }

      if (Canvax._.isFunction(prop)) {
        color = prop.apply(this, [layoutData]);
      }

      if (!color) {
        color = me.app.getTheme(iNode);
      }
      return color;
    }
  }, {
    key: "_getLabelText",
    value: function _getLabelText(itemData) {
      var str;

      if (this.label.enabled) {
        if (this.label.format) {
          if (Canvax._.isFunction(this.label.format)) {
            str = this.label.format(itemData.label, itemData);
          }
        } else {
          var _field = this.keyField;

          if (_field) {
            str = itemData.rowData[_field] + "：" + itemData.percentage + "%";
          } else {
            str = itemData.percentage + "%";
          }
        }
      }

      return str;
    }
  }, {
    key: "getList",
    value: function getList() {
      return this.data;
    }
  }, {
    key: "getLegendData",
    value: function getLegendData() {
      //return this.data;
      var legendData = [];

      Canvax._.each(this.data, function (item) {
        legendData.push({
          name: item.label,
          color: item.fillStyle,
          enabled: item.enabled
        });
      });

      return legendData;
    }
  }, {
    key: "tipsPointerOf",
    value: function tipsPointerOf() {}
  }, {
    key: "tipsPointerHideOf",
    value: function tipsPointerHideOf() {}
  }, {
    key: "focusAt",
    value: function focusAt(ind) {
      var nodeData = this._pie.data.list[ind];
      if (!this.node.focus.enabled) return;

      this._pie.focusOf(nodeData);
    }
  }, {
    key: "unfocusAt",
    value: function unfocusAt(ind) {
      var nodeData = this._pie.data.list[ind];
      if (!nodeData.node.focus.enabled) return;

      this._pie.unfocusOf(nodeData);
    }
  }, {
    key: "selectAt",
    value: function selectAt(ind) {
      var nodeData = this._pie.data.list[ind];
      if (!this.node.select.enabled) return;

      this._pie.selectOf(nodeData);
    }
  }, {
    key: "unselectAt",
    value: function unselectAt(ind) {
      var nodeData = this._pie.data.list[ind];
      if (!this.node.select.enabled) return;

      this._pie.unselectOf(nodeData);
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: '字段配置',
          "default": null
        },
        keyField: {
          detail: '分组字段',
          "default": null,
          documentation: 'keyField主要是给legend用的， 所有在legend中需要显示的分组数据，都用keyField'
        },
        sort: {
          detail: '排序，默认不排序，可以配置为asc,desc',
          "default": null
        },
        startAngle: {
          detail: '起始角度',
          "default": -90
        },
        allAngle: {
          detail: '全部角度',
          "default": 360
        },
        node: {
          detail: '单个节点（扇形）配置',
          propertys: {
            radius: {
              detail: '半径',
              "default": null,
              documentation: '每个扇形单元的半径，也可以配置一个字段，就成了丁格尔玫瑰图'
            },
            innerRadius: {
              detail: '内径',
              "default": 0
            },
            outRadius: {
              detail: '外径',
              "default": null
            },
            minRadius: {
              detail: '最小的半径厚度',
              "default": 10,
              documentation: 'outRadius - innerRadius ， 也就是radius的最小值'
            },
            moveDis: {
              detail: 'hover偏移量',
              "default": 8,
              documentation: '要预留moveDis位置来hover sector 的时候外扩'
            },
            fillStyle: {
              detail: '单个图形背景色',
              "default": null
            },
            focus: {
              detail: '图形的hover设置',
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": true
                }
              }
            },
            select: {
              detail: '图形的选中效果',
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": true
                },
                radius: {
                  detail: '选中效果图形的半径厚度',
                  "default": 5
                },
                alpha: {
                  detail: '选中效果图形的透明度',
                  "default": 0.7
                }
              }
            }
          }
        },
        label: {
          detail: 'label',
          propertys: {
            field: {
              detail: '获取label的字段',
              "default": null
            },
            enabled: {
              detail: '是否开启',
              "default": false
            },
            format: {
              detail: 'label的格式化函数，支持html',
              "default": null
            }
          }
        }
      };
    }
  }, {
    key: "polyfill",
    value: function polyfill(opt) {
      if (opt.groupField) {
        //20220304 keyField 统一为keyField
        opt.keyField = opt.groupField;
        delete opt.groupField;
      }

      if (opt.label && opt.label.field) {
        //已经移除，开始使用keyField
        opt.keyField = opt.label.field;
        delete opt.label.field;
      }

      return opt;
    }
  }]);
  return PieGraphs;
}(_index["default"]);

_index["default"].registerComponent(PieGraphs, 'graphs', 'pie');

var _default = PieGraphs;
exports["default"] = _default;
});

unwrapExports(pie$1);

var radar = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(graphs);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Polygon = _canvax["default"].Shapes.Polygon;
var Circle = _canvax["default"].Shapes.Circle;

var RadarGraphs = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(RadarGraphs, _GraphsBase);

  var _super = _createSuper(RadarGraphs);

  function RadarGraphs(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, RadarGraphs);
    _this = _super.call(this, opt, app);
    _this.type = "radar";
    _this.enabledField = null;
    _this.groups = {//uv : {
      //   area : ,
      //   nodes: 
      //}
    };

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(RadarGraphs.defaultProps()), opt);

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(RadarGraphs, [{
    key: "init",
    value: function init() {}
  }, {
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {}); //let me = this;

      _.extend(true, this, opt);

      this.data = this._trimGraphs();

      this._widget();

      this.sprite.context.x = this.origin.x;
      this.sprite.context.y = this.origin.y;
      this.fire("complete");
    }
  }, {
    key: "_widget",
    value: function _widget() {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      var iGroup = 0;

      _.each(this.data, function (list, field) {
        var group = {};
        var pointList = [];

        _.each(list, function (node) {
          pointList.push([node.point.x, node.point.y]);
        });

        var fieldConfig = _coord.getFieldConfig(field);

        var _strokeStyle = me._getStyle(me.line.strokeStyle, fieldConfig, iGroup, fieldConfig.color);

        var _lineType = me._getStyle(me.line.lineType, fieldConfig, iGroup, fieldConfig.color);

        var polyCtx = {
          pointList: pointList,
          cursor: "pointer"
        };

        if (me.line.enabled) {
          polyCtx.lineWidth = me.line.lineWidth;
          polyCtx.strokeStyle = _strokeStyle;
          polyCtx.lineType = _lineType;
        }

        if (me.area.enabled) {
          polyCtx.fillStyle = me._getStyle(me.area.fillStyle, fieldConfig, iGroup, fieldConfig.color);
          polyCtx.fillAlpha = me._getStyle(me.area.fillAlpha, fieldConfig, iGroup, 1);
        }

        var _poly = new Polygon({
          hoverClone: false,
          context: polyCtx
        });

        group.area = _poly;
        me.sprite.addChild(_poly);
        _poly.__hoverFillAlpha = _poly.context.fillAlpha + 0.2;
        _poly.__fillAlpha = _poly.context.fillAlpha;

        _poly.on(event.types.get(), function (e) {
          if (e.type == "mouseover") {
            this.context.fillAlpha = this.__hoverFillAlpha;
          }

          if (e.type == "mouseout") {
            this.context.fillAlpha = this.__fillAlpha;
          }
          me.app.fire(e.type, e);
        });

        var _nodes = [];

        if (me.node.enabled) {
          //绘制圆点
          _.each(list, function (node, i) {
            pointList.push([node.point.x, node.point.y]);

            var _node = new Circle({
              context: {
                cursor: "pointer",
                x: node.point.x,
                y: node.point.y,
                r: me.node.radius,
                lineWidth: me.node.lineWidth,
                strokeStyle: me.node.strokeStyle,
                fillStyle: _strokeStyle
              }
            });

            me.sprite.addChild(_node);
            _node.iNode = i;
            _node.nodeData = node;
            _node._strokeStyle = _strokeStyle;

            _node.on(event.types.get(), function (e) {
              //这样就会直接用这个aAxisInd了，不会用e.point去做计算
              e.aAxisInd = this.iNode;
              e.eventInfo = {
                trigger: 'this.node',
                //me.node,
                nodes: [this.nodeData]
              };
              me.app.fire(e.type, e);
            });

            _nodes.push(_node);
          });
        }
        group.nodes = _nodes;
        me.groups[field] = group;
        iGroup++;
      });
    }
  }, {
    key: "tipsPointerOf",
    value: function tipsPointerOf(e) {
      var me = this;
      me.tipsPointerHideOf(e);

      if (e.eventInfo && e.eventInfo.nodes) {
        _.each(e.eventInfo.nodes, function (eventNode) {
          if (me.data[eventNode.field]) {
            _.each(me.data[eventNode.field], function (n, i) {
              if (eventNode.iNode == i) {
                me.focusOf(n);
              } //else {
              //    me.unfocusOf(n);
              //}

            });
          }
        });
      }
    }
  }, {
    key: "tipsPointerHideOf",
    value: function tipsPointerHideOf() {
      var me = this;

      _.each(me.data, function (g) {
        _.each(g, function (node) {
          me.unfocusOf(node);
        });
      });
    }
  }, {
    key: "focusOf",
    value: function focusOf(node) {
      if (node.focused) return;
      var me = this;

      if (me.node.enabled) {
        var _node = me.groups[node.field].nodes[node.iNode];
        _node.context.r += 1;
        _node.context.fillStyle = me.node.strokeStyle;
        _node.context.strokeStyle = _node._strokeStyle;
      }

      node.focused = true;
    }
  }, {
    key: "unfocusOf",
    value: function unfocusOf(node) {
      if (!node.focused) return;
      var me = this;

      if (me.node.enabled) {
        var _node = me.groups[node.field].nodes[node.iNode];
        _node.context.r -= 1;
        _node.context.fillStyle = _node._strokeStyle;
        _node.context.strokeStyle = me.node.strokeStyle;
      }

      node.focused = false;
    }
  }, {
    key: "hide",
    value: function hide(field) {
      //用来计算下面的hLen
      var _coord = this.app.getComponent({
        name: 'coord'
      });

      this.enabledField = _coord.filterEnabledFields(this.field);
      var group = this.groups[field];

      if (group) {
        group.area.context.visible = false;

        _.each(group.nodes, function (element) {
          element.context.visible = false;
        });
      }
    }
  }, {
    key: "show",
    value: function show(field) {
      var _coord = this.app.getComponent({
        name: 'coord'
      });

      this.enabledField = _coord.filterEnabledFields(this.field);
      var group = this.groups[field];

      if (group) {
        group.area.context.visible = true;

        _.each(group.nodes, function (element) {
          element.context.visible = true;
        });
      }
    }
  }, {
    key: "_trimGraphs",
    value: function _trimGraphs() {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      }); //用来计算下面的hLen


      this.enabledField = _coord.filterEnabledFields(this.field);
      var data = {};

      _.each(this.enabledField, function (field) {
        var dataOrg = me.dataFrame.getFieldData(field);

        var fieldConfig = _coord.getFieldConfig(field);

        var arr = [];

        _.each(_coord.aAxis.angleList, function (_a, i) {
          //弧度
          var _r = Math.PI * _a / 180;

          var point = _coord.getPointInRadianOfR(_r, _coord.getROfNum(dataOrg[i]));

          arr.push({
            type: "radar",
            field: field,
            iNode: i,
            rowData: me.dataFrame.getRowDataAt(i),
            focused: false,
            value: dataOrg[i],
            point: point,
            color: fieldConfig.color
          });
        });

        data[field] = arr;
      });

      return data;
    }
  }, {
    key: "_getStyle",
    value: function _getStyle(style, fieldConfig, iGroup, def) {
      var _s = def;

      if (_.isString(style) || _.isNumber(style)) {
        _s = style;
      }

      if (_.isArray(style)) {
        _s = style[iGroup];
      }

      if (_.isFunction(style)) {
        _s = style(iGroup, fieldConfig);
      }

      if (_s === undefined || _s === null) {
        //只有undefined(用户配置了function),null才会认为需要还原皮肤色
        //“”都会认为是用户主动想要设置的，就为是用户不想他显示
        _s = def;
      }
      return _s;
    }
  }, {
    key: "getNodesAt",
    value: function getNodesAt(index) {
      //该index指当前
      var data = this.data;
      var _nodesInfoList = []; //节点信息集合

      _.each(this.enabledField, function (fs) {
        if (_.isArray(fs)) {
          _.each(fs, function (_fs) {
            //fs的结构两层到顶了
            var node = data[_fs][index];
            node && _nodesInfoList.push(node);
          });
        } else {
          var node = data[fs][index];
          node && _nodesInfoList.push(node);
        }
      });

      return _nodesInfoList;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: '字段配置',
          "default": null
        },
        line: {
          detail: '线配置',
          propertys: {
            enabled: {
              detail: '是否显示',
              "default": true
            },
            lineWidth: {
              detail: '线宽',
              "default": 2
            },
            strokeStyle: {
              detail: '线颜色',
              "default": null
            },
            lineType: {
              detail: '线条样式,默认solid，可选dashed',
              "default": 'solid'
            }
          }
        },
        area: {
          detail: '面积区域配置',
          propertys: {
            enabled: {
              detail: '是否显示',
              "default": true
            },
            fillStyle: {
              detail: '面积背景色',
              "default": null
            },
            fillAlpha: {
              detail: '面积透明度',
              "default": 0.1
            }
          }
        },
        node: {
          detail: '线上面的单数据节点图形配置',
          propertys: {
            enabled: {
              detail: '是否显示',
              "default": true
            },
            strokeStyle: {
              detail: '边框色',
              "default": '#ffffff'
            },
            radius: {
              detail: '半径',
              "default": 4
            },
            lineWidth: {
              detail: '边框大小',
              "default": 1
            }
          }
        }
      };
    }
  }]);
  return RadarGraphs;
}(_index["default"]);

_index["default"].registerComponent(RadarGraphs, 'graphs', 'radar');

var _default = RadarGraphs;
exports["default"] = _default;
});

unwrapExports(radar);

var dispatch_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var noop = {
  value: function value() {}
};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _) throw new Error("illegal type: " + t);
    _[t] = [];
  }

  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
        i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {
      type: t,
      name: name
    };
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function on(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length; // If no callback was specified, return the callback of the given type and name.

    if (arguments.length < 2) {
      while (++i < n) {
        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      }

      return;
    } // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.


    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);

    while (++i < n) {
      t = (typename = T[i]).type;
      if (t) _[t] = set(_[t], typename.name, callback);else if (callback == null) for (t in _) {
        _[t] = set(_[t], typename.name, null);
      }
    }

    return this;
  },
  copy: function copy() {
    var copy = {},
        _ = this._;

    for (var t in _) {
      copy[t] = _[t].slice();
    }

    return new Dispatch(copy);
  },
  call: function call(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) {
      args[i] = arguments[i + 2];
    }
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

    for (t = this._[type], i = 0, n = t.length; i < n; ++i) {
      t[i].value.apply(that, args);
    }
  },
  apply: function apply(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) {
      t[i].value.apply(that, args);
    }
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }

  if (callback != null) type.push({
    name: name,
    value: callback
  });
  return type;
}

var _default = dispatch;
exports["default"] = _default;
});

unwrapExports(dispatch_1);

var cloud_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _dispatch = interopRequireDefault(dispatch_1);

// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/
// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf
var cloudRadians = Math.PI / 180,
    cw = 1 << 11 >> 5,
    ch = 1 << 11;

var cloud = function cloud() {
  var size = [256, 256],
      text = cloudText,
      font = cloudFont,
      fontSize = cloudFontSize,
      fontStyle = cloudFontNormal,
      fontWeight = cloudFontNormal,
      rotate = cloudRotate,
      padding = cloudPadding,
      spiral = archimedeanSpiral,
      words = [],
      timeInterval = Infinity,
      event = (0, _dispatch["default"])("word", "end"),
      timer = null,
      random = Math.random,
      cloud = {},
      canvas = cloudCanvas;

  cloud.canvas = function (_) {
    return arguments.length ? (canvas = functor(_), cloud) : canvas;
  };

  cloud.start = function () {
    var contextAndRatio = getContext(canvas()),
        board = zeroArray((size[0] >> 5) * size[1]),
        bounds = null,
        n = words.length,
        i = -1,
        tags = [],
        data = words.map(function (d, i) {
      d.text = text.call(this, d, i);
      d.font = font.call(this, d, i);
      d.style = fontStyle.call(this, d, i);
      d.weight = fontWeight.call(this, d, i);
      d.rotate = rotate.call(this, d, i);
      d.size = ~~fontSize.call(this, d, i);
      d.padding = padding.call(this, d, i);
      return d;
    }).sort(function (a, b) {
      return b.size - a.size;
    });
    if (timer) clearInterval(timer);
    timer = setInterval(step, 0);
    step();
    return cloud;

    function step() {
      var start = Date.now();

      while (Date.now() - start < timeInterval && ++i < n && timer) {
        var d = data[i];
        d.x = size[0] * (random() + .5) >> 1;
        d.y = size[1] * (random() + .5) >> 1;
        cloudSprite(contextAndRatio, d, data, i);

        if (d.hasText && place(board, d, bounds)) {
          tags.push(d);
          event.call("word", cloud, d);
          if (bounds) cloudBounds(bounds, d);else bounds = [{
            x: d.x + d.x0,
            y: d.y + d.y0
          }, {
            x: d.x + d.x1,
            y: d.y + d.y1
          }]; // Temporary hack

          d.x -= size[0] >> 1;
          d.y -= size[1] >> 1;
        }
      }

      if (i >= n) {
        cloud.stop();
        event.call("end", cloud, tags, bounds);
      }
    }
  };

  cloud.stop = function () {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }

    return cloud;
  };

  function getContext(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context = canvas.getContext("2d");
    context.fillStyle = context.strokeStyle = "red";
    context.textAlign = "center";
    return {
      context: context,
      ratio: ratio
    };
  }

  function place(board, tag, bounds) {
    var perimeter = [{
      x: 0,
      y: 0
    }, {
      x: size[0],
      y: size[1]
    }],
        startX = tag.x,
        startY = tag.y,
        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
        s = spiral(size),
        dt = random() < .5 ? 1 : -1,
        t = -dt,
        dxdy,
        dx,
        dy;

    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue; // TODO only check for collisions within current bounds.

      if (!bounds || !cloudCollide(tag, board, size[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          var sprite = tag.sprite,
              w = tag.width >> 5,
              sw = size[0] >> 5,
              lx = tag.x - (w << 4),
              sx = lx & 0x7f,
              msx = 32 - sx,
              h = tag.y1 - tag.y0,
              x = (tag.y + tag.y0) * sw + (lx >> 5),
              last;

          for (var j = 0; j < h; j++) {
            last = 0;

            for (var i = 0; i <= w; i++) {
              board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
            }

            x += sw;
          }

          delete tag.sprite;
          return true;
        }
      }
    }

    return false;
  }

  cloud.timeInterval = function (_) {
    return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;
  };

  cloud.words = function (_) {
    return arguments.length ? (words = _, cloud) : words;
  };

  cloud.size = function (_) {
    return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;
  };

  cloud.font = function (_) {
    return arguments.length ? (font = functor(_), cloud) : font;
  };

  cloud.fontStyle = function (_) {
    return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;
  };

  cloud.fontWeight = function (_) {
    return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;
  };

  cloud.rotate = function (_) {
    return arguments.length ? (rotate = functor(_), cloud) : rotate;
  };

  cloud.text = function (_) {
    return arguments.length ? (text = functor(_), cloud) : text;
  };

  cloud.spiral = function (_) {
    return arguments.length ? (spiral = spirals[_] || _, cloud) : spiral;
  };

  cloud.fontSize = function (_) {
    return arguments.length ? (fontSize = functor(_), cloud) : fontSize;
  };

  cloud.padding = function (_) {
    return arguments.length ? (padding = functor(_), cloud) : padding;
  };

  cloud.random = function (_) {
    return arguments.length ? (random = _, cloud) : random;
  };

  cloud.on = function () {
    var value = event.on.apply(event, arguments);
    return value === event ? cloud : value;
  };

  return cloud;
};

function cloudText(d) {
  return d.text;
}

function cloudFont() {
  return "serif";
}

function cloudFontNormal() {
  return "normal";
}

function cloudFontSize(d) {
  return Math.sqrt(d.value);
}

function cloudRotate() {
  return (~~(Math.random() * 6) - 3) * 30;
}

function cloudPadding() {
  return 1;
} // Fetches a monochrome sprite bitmap for the specified text.
// Load in batches for speed.


function cloudSprite(contextAndRatio, d, data, di) {
  if (d.sprite) return;
  var c = contextAndRatio.context,
      ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x = 0,
      y = 0,
      maxh = 0,
      n = data.length;
  --di;

  while (++di < n) {
    d = data[di];
    c.save();
    c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
    var w = c.measureText(d.text + "m").width * ratio,
        h = d.size << 1;

    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians),
          cr = Math.cos(d.rotate * cloudRadians),
          wcr = w * cr,
          wsr = w * sr,
          hcr = h * cr,
          hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 0x1f >> 5 << 5;
    }

    if (h > maxh) maxh = h;

    if (x + w >= cw << 5) {
      x = 0;
      y += maxh;
      maxh = 0;
    }

    if (y + h >= ch) break;
    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
    if (d.rotate) c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);
    if (d.padding) c.lineWidth = 2 * d.padding, c.strokeText(d.text, 0, 0);
    c.restore();
    d.width = w;
    d.height = h;
    d.xoff = x;
    d.yoff = y;
    d.x1 = w >> 1;
    d.y1 = h >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x += w;
  }

  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
      sprite = [];

  while (--di >= 0) {
    d = data[di];
    if (!d.hasText) continue;
    var w = d.width,
        w32 = w >> 5,
        h = d.y1 - d.y0; // Zero the buffer

    for (var i = 0; i < h * w32; i++) {
      sprite[i] = 0;
    }

    x = d.xoff;
    if (x == null) return;
    y = d.yoff;
    var seen = 0,
        seenRow = -1;

    for (var j = 0; j < h; j++) {
      for (var i = 0; i < w; i++) {
        var k = w32 * j + (i >> 5),
            m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m;
        seen |= m;
      }

      if (seen) seenRow = j;else {
        d.y0++;
        h--;
        j--;
        y++;
      }
    }

    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
} // Use mask-based collision detection.


function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite,
      w = tag.width >> 5,
      lx = tag.x - (w << 4),
      sx = lx & 0x7f,
      msx = 32 - sx,
      h = tag.y1 - tag.y0,
      x = (tag.y + tag.y0) * sw + (lx >> 5),
      last;

  for (var j = 0; j < h; j++) {
    last = 0;

    for (var i = 0; i <= w; i++) {
      if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;
    }

    x += sw;
  }

  return false;
}

function cloudBounds(bounds, d) {
  var b0 = bounds[0],
      b1 = bounds[1];
  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
}

function collideRects(a, b) {
  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}

function archimedeanSpiral(size) {
  var e = size[0] / size[1];
  return function (t) {
    return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
  };
}

function rectangularSpiral(size) {
  var dy = 4,
      dx = dy * size[0] / size[1],
      x = 0,
      y = 0;
  return function (t) {
    var sign = t < 0 ? -1 : 1; // See triangular numbers: T_n = n * (n + 1) / 2.

    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
      case 0:
        x += dx;
        break;

      case 1:
        y += dy;
        break;

      case 2:
        x -= dx;
        break;

      default:
        y -= dy;
        break;
    }

    return [x, y];
  };
} // TODO reuse arrays?


function zeroArray(n) {
  var a = [],
      i = -1;

  while (++i < n) {
    a[i] = 0;
  }

  return a;
}

function cloudCanvas() {
  return document.createElement("canvas");
}

function functor(d) {
  return typeof d === "function" ? d : function () {
    return d;
  };
}

var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
var _default = cloud;
exports["default"] = _default;
});

unwrapExports(cloud_1);

var cloud = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(graphs);

var _cloud = interopRequireDefault(cloud_1);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Text = _canvax["default"].Display.Text;

var CloudGraphs = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(CloudGraphs, _GraphsBase);

  var _super = _createSuper(CloudGraphs);

  function CloudGraphs(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, CloudGraphs);
    _this = _super.call(this, opt, app);
    _this.type = "cloud";
    var me = (0, _assertThisInitialized2["default"])(_this); //坚持一个数据节点的设置都在一个node下面

    _this.node = {
      _maxFontSizeVal: 0,
      //fontSizer如果配置为一个field的话， 找出这个field数据的最大值
      _minFontSizeVal: null //fontSizer如果配置为一个field的话， 找出这个field数据的最小值

    };

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(CloudGraphs.defaultProps()), opt);

    _this.node.fontColor = function (nodeData) {
      return me.app.getTheme(nodeData.iNode);
    };

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(CloudGraphs, [{
    key: "init",
    value: function init() {}
  }, {
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {});

      _.extend(true, this, opt);

      this._drawGraphs();

      this.sprite.context.x = this.width / 2;
      this.sprite.context.y = this.height / 2;
      this.fire("complete");
    }
  }, {
    key: "getDaraFrameIndOfVal",
    value: function getDaraFrameIndOfVal(val) {
      var me = this;
      var df = this.dataFrame;

      var org = _.find(df.data, function (d) {
        return d.field == me.field;
      });

      var ind = _.indexOf(org.data, val);

      return ind;
    }
  }, {
    key: "_getFontSize",
    value: function _getFontSize(rowData) {
      var size = this.node.minFontSize;

      if (_.isFunction(this.node.fontSize)) {
        size = this.node.fontSize(rowData);
      }

      if (_.isString(this.node.fontSize) && this.node.fontSize in rowData) {
        var val = Number(rowData[this.node.fontSize]);

        if (!isNaN(val)) {
          size = this.node.minFontSize + (this.node.maxFontSize - this.node.minFontSize) / (this.node._maxFontSizeVal - this.node._minFontSizeVal) * (val - this.node._minFontSizeVal);
        }
      }

      if (_.isNumber(this.node.fontSize)) {
        size = this.node.fontSize;
      }

      return size;
    }
  }, {
    key: "_getRotate",
    value: function _getRotate(item, ind) {
      var rotation = this.node.rotation;

      if (_.isFunction(this.node.rotation)) {
        rotation = this.node.rotation(item, ind) || 0;
      }
      return rotation;
    }
  }, {
    key: "_getFontColor",
    value: function _getFontColor(nodeData) {
      var color;

      if (_.isString(this.node.fontColor)) {
        color = this.node.fontColor;
      }

      if (_.isFunction(this.node.fontColor)) {
        color = this.node.fontColor(nodeData);
      }

      if (color === undefined || color === null) {
        //只有undefined才会认为需要一个抄底色
        //“”都会认为是用户主动想要设置的，就为是用户不想他显示
        color = "#ccc";
      }
      return color;
    }
  }, {
    key: "_drawGraphs",
    value: function _drawGraphs() {
      var me = this; //查找fontSize的max和min
      //let maxFontSizeVal = 0;
      //let minFontSizeVal = 0;

      if (_.isString(this.node.fontSize)) {
        _.each(me.dataFrame.getFieldData(this.node.fontSize), function (val) {
          me.node._maxFontSizeVal = Math.max(me.node._maxFontSizeVal, val);
          me.node._minFontSizeVal = Math.min(me.node._minFontSizeVal, val);
        });
      }

      var layout = (0, _cloud["default"])().size([me.width, me.height]).words(me.dataFrame.getFieldData(me.field).map(function (txt, ind) {
        //这里不能直接用i去从dataFrame里查询,因为cloud layout后，可能会扔掉渲染不下的部分
        var rowData = me.app.dataFrame.getRowDataAt(me.getDaraFrameIndOfVal(txt));
        var tag = {
          type: "cloud",
          rowData: rowData,
          field: me.field,
          name: "",
          //tips中就不会显示name
          value: txt,
          text: null,
          size: me._getFontSize(rowData, txt),
          iNode: ind,
          color: null,
          //在绘制的时候统一设置
          __no__name: true
        };
        tag.fontColor = me._getFontColor(tag);
        var _txt = txt;

        if (me.node.format) {
          _txt = me.node.format(txt, tag);
        } else {
          //否则用fieldConfig上面的
          var _coord = me.app.getComponent({
            name: 'coord'
          });

          var fieldConfig = _coord.getFieldConfig(me.field);

          if (fieldConfig) {
            _txt = fieldConfig.getFormatValue(txt);
          }
        }
        tag.text = _txt || txt;
        return tag;
      })).padding(me.node.padding).rotate(function (item, ind) {
        //return 0;
        return me._getRotate(item, ind);
      }).font(me.node.fontFamily).fontSize(function (d) {
        return d.size;
      }).on("end", draw);
      layout.start();

      function draw(data) {
        me.data = data;
        me.sprite.removeAllChildren();

        _.each(data, function (tag, i) {
          tag.iNode = i;
          tag.dataLen = data.length;
          tag.focused = false;
          tag.selected = false;
          var tagTxt = new Text(tag.text, {
            context: {
              x: tag.x,
              y: tag.y,
              fontSize: tag.size,
              fontFamily: tag.font,
              rotation: tag.rotate,
              textBaseline: "middle",
              textAlign: "center",
              cursor: 'pointer',
              fontWeight: me.node.fontWeight,
              fillStyle: tag.fontColor
            }
          });
          me.sprite.addChild(tagTxt);
          me.node.focus.enabled && tagTxt.hover(function () {
            me.focusAt(this.nodeData.iNode);
          }, function () {
            !this.nodeData.selected && me.unfocusAt(this.nodeData.iNode);
          });
          tagTxt.nodeData = tag;
          tag._node = tagTxt;
          tagTxt.on(event.types.get(), function (e) {
            e.eventInfo = {
              trigger: 'this.node',
              title: null,
              nodes: [this.nodeData]
            };

            if (this.nodeData.text) {
              e.eventInfo.title = ''; //this.nodeData.text;
            }

            me.app.fire(e.type, e);
          });
        });
      }
    }
  }, {
    key: "focusAt",
    value: function focusAt(ind) {
      var nodeData = this.data[ind];
      if (!this.node.focus.enabled || nodeData.focused) return;
      var nctx = nodeData._node.context;
      nctx.fontSize += 3;
      nodeData.focused = true;
    }
  }, {
    key: "unfocusAt",
    value: function unfocusAt(ind) {
      var nodeData = this.data[ind];
      if (!this.node.focus.enabled || !nodeData.focused) return;
      var nctx = nodeData._node.context;
      nctx.fontSize -= 3;
      nodeData.focused = false;
    }
  }, {
    key: "selectAt",
    value: function selectAt(ind) {
      var nodeData = this.data[ind];
      if (!this.node.select.enabled || nodeData.selected) return;
      var nctx = nodeData._node.context;
      nctx.lineWidth = this.node.select.lineWidth;
      nctx.strokeAlpha = this.node.select.strokeAlpha;
      nctx.strokeStyle = this.node.select.strokeStyle;
      nodeData.selected = true;
    }
  }, {
    key: "unselectAt",
    value: function unselectAt(ind) {
      var nodeData = this.data[ind];
      if (!this.node.select.enabled || !nodeData.selected) return;
      var nctx = nodeData._node.context;
      nctx.strokeStyle = this.node.strokeStyle;
      nodeData.selected = false;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: '字段配置',
          "default": null
        },
        node: {
          detail: '节点文字配置',
          propertys: {
            fontFamily: {
              detail: '字体设置',
              "default": 'Impact'
            },
            fontColor: {
              detail: '文字颜色',
              "default": '#999'
            },
            fontSize: {
              detail: '文本字体大小',
              "default": function _default() {
                //fontSize默认12-50的随机值
                return this.minFontSize + Math.random() * this.maxFontSize;
              }
            },
            maxFontSize: {
              detail: '文本最大字体大小',
              "default": 30
            },
            minFontSize: {
              detail: '文本最小字体大小',
              "default": 16
            },
            fontWeight: {
              detail: 'fontWeight',
              "default": 'normal'
            },
            format: {
              detail: '文本格式化处理函数',
              "default": null
            },
            padding: {
              detail: '文本间距',
              "default": 10
            },
            rotation: {
              detail: '文本旋转角度',
              "default": function _default() {
                return (~~(Math.random() * 6) - 3) * 30;
              }
            },
            strokeStyle: {
              detail: '文本描边颜色',
              "default": null
            },
            select: {
              detail: '文本选中效果',
              propertys: {
                enabled: {
                  detail: '是否开启选中',
                  "default": true
                },
                lineWidth: {
                  detail: '选中后的文本描边宽',
                  "default": 2
                },
                strokeStyle: {
                  detail: '选中后的文本描边色',
                  "default": '#666'
                }
              }
            },
            focus: {
              detail: '文本hover效果',
              propertys: {
                enabled: {
                  detail: '是否开启hover效果',
                  "default": true
                }
              }
            }
          }
        }
      };
    }
  }]);
  return CloudGraphs;
}(_index["default"]);

_index["default"].registerComponent(CloudGraphs, 'graphs', 'cloud');

var _default2 = CloudGraphs;
exports["default"] = _default2;
});

unwrapExports(cloud);

var group$1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _canvax = interopRequireDefault(Canvax);



var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Circle = _canvax["default"].Shapes.Circle;

var PlanetGroup = /*#__PURE__*/function () {
  function PlanetGroup(opt, dataFrame, _graphs) {
    (0, _classCallCheck2["default"])(this, PlanetGroup);
    this._opt = opt;
    this.dataFrame = dataFrame;
    this._graphs = _graphs;
    this.app = _graphs.app;
    this.field = null;
    this.iGroup = 0;
    this.groupLen = 1; //分组可以绘制的半径范围

    this.rRange = {
      start: 0,
      to: 0
    };
    this.width = 0;
    this.height = 0;
    this.selectInds = []; //会从外面的index中传入一个统一的selectInds 引用

    this.layoutType = "radian"; //坑位，用来做占位

    this.pit = {
      radius: 30
    };
    this.planets = [];
    this.maxRingNum = 0;
    this.ringNum = 0;

    _.extend(true, this, (0, tools.getDefaultProps)(PlanetGroup.defaultProps()), opt); //circle.maxRadius 绝对不能大于最大 占位 pit.radius


    if (this.node.maxRadius > this.pit.radius) {
      this.pit.radius = this.node.maxRadius;
    }
    this.init();
  }

  (0, _createClass2["default"])(PlanetGroup, [{
    key: "init",
    value: function init() {
      //let me = this;
      var _coord = this.app.getComponent({
        name: 'coord'
      });

      this.sprite = new _canvax["default"].Display.Sprite({
        id: "group_" + this.iGroup,
        context: {
          x: _coord.origin.x,
          y: _coord.origin.y
        }
      });

      this._trimGraphs();

      this.draw();
    }
  }, {
    key: "_trimGraphs",
    value: function _trimGraphs() {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      var _coordMaxDis = _coord.getMaxDisToViewOfOrigin();

      if ((_coordMaxDis - this.rRange.to) / (this.pit.radius * 2) < this.groupLen - 1 - this.iGroup) {
        //要保证后面的group至少能有意个ringNum
        this.rRange.to = _coordMaxDis - (this.groupLen - 1 - this.iGroup) * this.pit.radius * 2;
      }

      if (this.rRange.to - this.rRange.start < this.pit.radius * 2) {
        this.rRange.to = this.rRange.start + this.pit.radius * 2;
      }

      if (!this.maxRingNum) {
        this.maxRingNum = parseInt((this.rRange.to - this.rRange.start) / (this.pit.radius * 2), 10);
        /* TODO: 这个目前有问题
        //如果可以划10个环，但是其实数据只有8条， 那么就 当然是只需要划分8ring
        //this.ringNum = Math.min( this.maxRingNum , this.dataFrame.length );
        */

        this.ringNum = this.maxRingNum;
      }

      this.rRange.to = this.rRange.start + this.ringNum * this.pit.radius * 2; //根据数据创建n个星球

      var planets = [];
      var dataLen = this.dataFrame.length;

      for (var i = 0; i < dataLen; i++) {
        var rowData = this.dataFrame.getRowDataAt(i);
        var planetLayoutData = {
          type: "planet",
          groupLen: this.groupLen,
          iGroup: me.iGroup,
          iNode: i,
          nodeElement: null,
          //canvax元素
          labelElement: null,
          //label的canvax元素
          rowData: rowData,
          //下面这些都只能在绘制的时候确定然后赋值
          iRing: null,
          iPlanet: null,
          fillStyle: null,
          color: null,
          //给tips用
          strokeStyle: null,
          pit: null,
          //假设这个planet是个萝卜，那么 pit 就是这个萝卜的坑
          ringInd: -1,
          field: me.field,
          label: rowData[me.field],
          focused: false,
          selected: !!~_.indexOf(this.selectInds, rowData.__index__)
        };
        planets.push(planetLayoutData);
      }

      if (me.sortField) {
        planets = planets.sort(function (a, b) {
          var field = me.sortField;

          if (me.sort == "desc") {
            return b.rowData[field] - a.rowData[field];
          } else {
            return a.rowData[field] - b.rowData[field];
          }
        }); //修正下 排序过后的 iNode

        _.each(planets, function (planet, i) {
          planet.iNode = i;
        });
      }
      this._rings = this["_setRings_" + this.layoutType + "Range"](planets);
      this.planets = planets;
    } //根据弧度对应可以排列多少个星球的占比来分段

  }, {
    key: "_setRings_radianRange",
    value: function _setRings_radianRange(planets) {
      var me = this;
      var _rings = [];

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      for (var i = 0, l = this.ringNum; i < l; i++) {
        var _r = i * this.pit.radius * 2 + this.pit.radius + this.rRange.start;

        if (!me._graphs.center.enabled) {
          _r = i * this.pit.radius * 2 + this.rRange.start;
        }

        var arcs = _coord.getRadiansAtR(_r, me.width, me.height); //测试代码begin---------------------------------------------------
        //用来绘制弧度的辅助线

        /*
        _.each( arcs, function( arc ){
            let sector = new Canvax.Shapes.Sector({
                context: {
                    r: _r,
                    startAngle: arc[0].radian*180/Math.PI,
                    endAngle: arc[1].radian*180/Math.PI, //secc.endAngle,
                    strokeStyle: "#ccc",
                    lineWidth:1
                },
            });
            me.sprite.addChild( sector );
        } );
        */
        //测试代码end------------------------------------------------------
        //该半径圆弧上，可以绘制一个星球的最小弧度值
        //let minRadianItem = Math.atan( this.pit.radius / _r );


        _rings.push({
          arcs: arcs,
          pits: [],
          //萝卜坑
          planets: [],
          //将要入坑的萝卜
          radius: _r,
          //这个ring所在的半径轨道
          max: 0 //这个环上面最多能布局下的 planet 数量

        });
      }
      var allplanetsMax = 0; //所有ring里面
      //计算每个环的最大可以创建星球数量,然后把所有的数量相加做分母。
      //然后计算自己的比例去 planets 里面拿对应比例的数据

      _.each(_rings, function (ring) {
        //先计算上这个轨道上排排站一共可以放的下多少个星球
        //一个星球需要多少弧度
        var minRadian = Math.asin(me.pit.radius / ring.radius) * 2;

        if (ring.radius == 0) {
          //说明就在圆心
          minRadian = Math.PI * 2;
        }
        var _count = 0;

        _.each(ring.arcs, function (arc) {
          var _adiff = me._getDiffRadian(arc[0].radian, arc[1].radian);

          if (_adiff >= minRadian) {
            var _arc_count = parseInt(_adiff / minRadian, 10);

            _count += _arc_count; //这个弧段里可以放_count个坑位

            for (var p = 0; p < _arc_count; p++) {
              var pit = {
                hasRadish: false,
                //是否已经有萝卜(一个萝卜一个坑)
                start: (arc[0].radian + minRadian * p + Math.PI * 2) % (Math.PI * 2)
              };
              pit.middle = (pit.start + minRadian / 2 + Math.PI * 2) % (Math.PI * 2);
              pit.to = (pit.start + minRadian + Math.PI * 2) % (Math.PI * 2);
              ring.pits.push(pit); //测试占位情况代码begin---------------------------------------------

              /*
              let point = me.app.getComponent({name:'coord'}).getPointInRadianOfR( pit.middle , ring.radius )
              me.sprite.addChild(new Circle({
                  context:{
                      x : point.x,
                      y : point.y,
                      r : me.pit.radius,
                      fillStyle: "#ccc",
                      strokeStyle: "red",
                      lineWidth: 1,
                      globalAlpha:0.3
                  }
              }));
              */
              //测试占位情况代码end-----------------------------------------------     
            }
          }
        });

        ring.max = _count;
        allplanetsMax += _count; //坑位做次随机乱序

        ring.pits = _.shuffle(ring.pits);
      }); //allplanetsMax有了后作为分明， 可以给每个ring去分摊 planet 了


      var preAllCount = 0;

      _.each(_rings, function (ring, i) {
        if (preAllCount >= planets.length) {
          return false;
        }
        var num = Math.ceil(ring.max / allplanetsMax * planets.length);
        num = Math.min(ring.max, num);
        ring.planets = planets.slice(preAllCount, preAllCount + num);

        if (i == _rings.length - 1) {
          ring.planets = planets.slice(preAllCount);
        }
        preAllCount += num; //给每个萝卜分配一个坑位

        _.each(ring.planets, function (planet, ii) {
          if (ii >= ring.pits.length) {
            //如果萝卜已经比这个ring上面的坑要多，就要扔掉， 没办法的
            return;
          }

          var pits = _.filter(ring.pits, function (pit) {
            return !pit.hasRadish;
          });

          var targetPit = pits[parseInt(Math.random() * pits.length)];
          targetPit.hasRadish = true;
          planet.pit = targetPit;
        });
      });

      return _rings;
    }
  }, {
    key: "_getDiffRadian",
    value: function _getDiffRadian(_start, _to) {
      var _adiff = _to - _start;

      if (_to < _start) {
        _adiff = (_to + Math.PI * 2 - _start) % (Math.PI * 2);
      }

      return _adiff;
    } //索引区间分段法 待实现

  }, {
    key: "_setRings_indexRange",
    value: function _setRings_indexRange() {} //值区间分段法
    //todo:这样确实就很可能数据集中在两段中间没有 待实现

  }, {
    key: "_setRings_valRange",
    value: function _setRings_valRange() {}
  }, {
    key: "draw",
    value: function draw() {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      _.each(this._rings, function (ring, i) {
        var _ringCtx = {
          rotation: 0
        };

        if (ring.arcs.length == 1 && ring.arcs[0][0].radian == 0 && ring.arcs[0][1].radian == Math.PI * 2) {
          //如果这个是一个整个的内圆，那么就做个随机的旋转
          _ringCtx.rotation = parseInt(Math.random() * 360);
        }

        var _ringSp = new _canvax["default"].Display.Sprite({
          context: _ringCtx
        });

        _.each(ring.planets, function (p, ii) {
          if (!p.pit) {
            //如果这个萝卜没有足够的坑位可以放，很遗憾，只能扔掉了
            return;
          }

          var point = _coord.getPointInRadianOfR(p.pit.middle, ring.radius);

          var r = me._getRProp(me.node.radius, i, ii, p); //计算该萝卜在坑位（pit）中围绕pit的圆心可以随机移动的范围（r）


          var _transR = me.node.maxRadius - r; //然后围绕pit的圆心随机找一个点位，重新设置Point


          var _randomTransR = parseInt(Math.random() * _transR);

          var _randomAngle = parseInt(Math.random() * 360);

          var _randomRadian = _randomAngle * Math.PI / 180;

          if (_randomTransR != 0) {
            //说明还是在圆心， 就没必要重新计算point
            point.x += Math.sin(_randomRadian) * _randomTransR;
            point.y += Math.cos(_randomRadian) * _randomTransR;
          }
          var node = me.node;

          if (p.selected) {
            node = me.node.select;
          }

          var _fillStyle = me._getProp(me.node.fillStyle, p);

          var _strokeStyle = me._getProp(node.strokeStyle, p);

          var _lineAlpha = me._getProp(node.strokeAlpha, p);

          var _lineWidth = me._getProp(node.lineWidth, p);

          var circleCtx = {
            x: point.x,
            y: point.y,
            r: r,
            fillStyle: _fillStyle,
            lineWidth: _lineWidth,
            strokeStyle: _strokeStyle,
            strokeAlpha: _lineAlpha,
            cursor: "pointer"
          }; //设置好p上面的fillStyle 和 strokeStyle

          p.color = p.fillStyle = _fillStyle;
          p.strokeStyle = _strokeStyle;
          p.iRing = i;
          p.iPlanet = ii;

          var _circle = new Circle({
            hoverClone: false,
            context: circleCtx
          });

          _circle.on(event.types.get(), function (e) {
            e.eventInfo = {
              title: null,
              trigger: 'this.node',
              //me.node,
              nodes: [this.nodeData]
            };

            if (this.nodeData.label) {
              e.eventInfo.title = this.nodeData.label;
            }

            if (me.node.focus.enabled) {
              if (e.type == "mouseover") {
                me.focusAt(this.nodeData);
              }

              if (e.type == "mouseout") {
                me.unfocusAt(this.nodeData);
              }
            }

            if (me.node.select.enabled && me.node.select.triggerEventType.indexOf(e.type) > -1) {
              //如果开启了图表的选中交互
              //TODO:这里不能
              var onbefore = me.node.select.onbefore;
              var onend = me.node.select.onend;

              if (!onbefore || typeof onbefore == 'function' && onbefore.apply(me, [this.nodeData]) !== false) {
                if (this.nodeData.selected) {
                  //说明已经选中了
                  me.unselectAt(this.nodeData);
                } else {
                  me.selectAt(this.nodeData);
                }

                onend && typeof onend == 'function' && onend.apply(me, [this.nodeData]);
              }
            }

            me.app.fire(e.type, e);
          }); //互相用属性引用起来


          _circle.nodeData = p;
          p.nodeElement = _circle;
          _circle.ringInd = i;
          _circle.planetIndInRing = ii;

          _ringSp.addChild(_circle); //如果有开启入场动画


          if (me._graphs.animation) {
            var _r = _circle.context.r;
            var _globalAlpha = _circle.context.globalAlpha;
            _circle.context.r = 1;
            _circle.context.globalAlpha = 0.1;

            _circle.animate({
              r: _r,
              globalAlpha: _globalAlpha
            }, {
              delay: Math.round(Math.random() * 1500),
              onComplete: function onComplete() {
                //这个时候再把label现实出来
                _circle.labelElement && (_circle.labelElement.context.visible = true);

                var _cloneNode = _circle.clone();

                _ringSp.addChildAt(_cloneNode, 0);

                _cloneNode.animate({
                  r: _r + 10,
                  globalAlpha: 0
                }, {
                  onComplete: function onComplete() {
                    _cloneNode.destroy();
                  }
                });
              }
            });
          }
          //绘制实心圆上面的文案
          //x,y 默认安装圆心定位，也就是position == 'center'

          var _labelCtx = {
            x: point.x,
            y: point.y,
            //point.y + r +3
            fontSize: me.label.fontSize,
            textAlign: me.label.textAlign,
            textBaseline: me.label.verticalAlign,
            fillStyle: me.label.fontColor,
            rotation: -_ringCtx.rotation,
            rotateOrigin: {
              x: 0,
              y: 0 //-(r + 3)

            }
          };

          var _label = new _canvax["default"].Display.Text(p.label, {
            context: _labelCtx
          });

          var _labelWidth = _label.getTextWidth();

          var _labelHeight = _label.getTextHeight();

          if (_labelWidth > r * 2) {
            _labelCtx.fontSize = me.label.fontSize - 3;
          }
          //只能用function的形式用户自定义实现
          //现在已经实现了center,bottom,auto，但是也还是先留着吧，也不碍事

          if (_.isFunction(me.label.position)) {
            var _pos = me.label.position({
              node: _circle,
              circleR: r,
              circleCenter: {
                x: point.x,
                y: point.y
              },
              textWidth: _labelWidth,
              textHeight: _labelHeight
            });

            _labelCtx.rotation = -_ringCtx.rotation;
            _labelCtx.rotateOrigin = {
              x: -(_pos.x - _labelCtx.x),
              y: -(_pos.y - _labelCtx.y)
            };
            _labelCtx.x = _pos.x;
            _labelCtx.y = _pos.y;
          }

          if (me.label.position == 'auto') {
            if (_labelWidth > r * 2) {
              setPositionToBottom();
            }
          }

          if (me.label.position == 'bottom') {
            setPositionToBottom();
          }

          function setPositionToBottom() {
            _labelCtx.y = point.y + r + 3; //_labelCtx.textBaseline = "top";

            _labelCtx.rotation = -_ringCtx.rotation;
            _labelCtx.rotateOrigin = {
              x: 0,
              y: -(r + _labelHeight * 0.7)
            };
          }
          _labelCtx.x += me.label.offsetX;
          _labelCtx.y += me.label.offsetY; //TODO:这里其实应该是直接可以修改 _label.context. 属性的
          //但是这里版本的canvax有问题。先重新创建文本对象吧

          _label = new _canvax["default"].Display.Text(p.label, {
            context: _labelCtx
          }); //互相用属性引用起来

          _circle.labelElement = _label;
          _label.nodeData = p;
          p.labelElement = _label;

          if (me._graphs.animation) {
            _label.context.visible = false;
          }

          _ringSp.addChild(_label);
        });

        me.sprite.addChild(_ringSp);
      });
    }
  }, {
    key: "_getRProp",
    value: function _getRProp(r, ringInd, iNode, nodeData) {
      var me = this;

      if (_.isString(r) && _.indexOf(me.dataFrame.fields, r) > -1) {
        if (this.__rValMax == undefined && this.__rValMax == undefined) {
          this.__rValMax = 0;
          this.__rValMin = 0;

          _.each(me.planets, function (planet) {
            me.__rValMax = Math.max(me.__rValMax, planet.rowData[r]);
            me.__rValMin = Math.min(me.__rValMin, planet.rowData[r]);
          });
        }
        var rVal = nodeData.rowData[r];
        return me.node.minRadius + (rVal - this.__rValMin) / (this.__rValMax - this.__rValMin) * (me.node.maxRadius - me.node.minRadius);
      }
      return me._getProp(r, nodeData);
    }
  }, {
    key: "_getProp",
    value: function _getProp(p, nodeData) {
      var iGroup = this.iGroup;

      if (_.isFunction(p)) {
        return p.apply(this, [nodeData, iGroup]); //return p( nodeData );
      }
      return p;
    }
  }, {
    key: "getPlanetAt",
    value: function getPlanetAt(target) {
      var planet = target;

      if (_.isNumber(target)) {
        _.each(this.planets, function (_planet) {
          if (_planet.rowData.__index__ == target) {
            planet = _planet;
            return false;
          }
        });
      }
      return planet;
    } //这里的ind是原始的__index__

  }, {
    key: "selectAt",
    value: function selectAt(ind) {
      if (!this.node.select.enabled) return;
      var planet = this.getPlanetAt(ind);
      planet.selected = true; //可能这个数据没有显示的，就没有nodeElement

      if (planet.nodeElement) {
        planet.nodeElement.context.lineWidth = this._getProp(this.node.select.lineWidth, planet);
        planet.nodeElement.context.strokeStyle = this._getProp(this.node.select.strokeStyle, planet);
        planet.nodeElement.context.strokeAlpha = this._getProp(this.node.select.strokeAlpha, planet);
      }

      for (var i = 0; i < this.selectInds.length; i++) {
        if (ind === this.selectInds[i]) {
          this.selectInds.splice(i--, 1);
          break;
        }
      }
    } //这里的ind是原始的__index__

  }, {
    key: "unselectAt",
    value: function unselectAt(ind) {
      if (!this.node.select.enabled) return;
      var planet = this.getPlanetAt(ind);
      planet.selected = false;

      if (planet.nodeElement) {
        planet.nodeElement.context.lineWidth = this._getProp(this.node.lineWidth, planet);
        planet.nodeElement.context.strokeAlpha = this._getProp(this.node.strokeAlpha, planet);
      }
      this.selectInds.push(ind);
    }
  }, {
    key: "getSelectedNodes",
    value: function getSelectedNodes() {
      return _.filter(this.planets, function (planet) {
        return planet.selected;
      });
    }
  }, {
    key: "focusAt",
    value: function focusAt(ind) {
      if (!this.node.focus.enabled) return;
      var planet = this.getPlanetAt(ind);
      if (planet.selected) return;
      planet.focused = true;

      if (planet.nodeElement) {
        planet.nodeElement.context.lineWidth = this._getProp(this.node.focus.lineWidth, planet);
        planet.nodeElement.context.strokeStyle = this._getProp(this.node.focus.strokeStyle, planet);
        planet.nodeElement.context.strokeAlpha = this._getProp(this.node.focus.strokeAlpha, planet);
      }
    }
  }, {
    key: "unfocusAt",
    value: function unfocusAt(ind) {
      if (!this.node.focus.enabled) return;
      var planet = this.getPlanetAt(ind);
      if (planet.selected) return;
      planet.focused = false;

      if (planet.nodeElement) {
        planet.nodeElement.context.lineWidth = this._getProp(this.node.lineWidth, planet);
        planet.nodeElement.context.strokeAlpha = this._getProp(this.node.strokeAlpha, planet);
      }
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        sort: {
          detail: '排序',
          "default": 'desc'
        },
        sortField: {
          detail: '用来排序的字段',
          "default": 'null'
        },
        node: {
          detail: '单个数据节点图形配置',
          propertys: {
            maxRadius: {
              detail: '最大半径',
              "default": 30
            },
            minRadius: {
              detail: '最小半径',
              "default": 5
            },
            radius: {
              detail: '半径',
              "default": 15,
              documentation: '也可以是个function,也可以配置{field:"pv"}来设置字段， 自动计算r'
            },
            lineWidth: {
              detail: '描边线宽',
              "default": 1
            },
            strokeStyle: {
              detail: '描边颜色',
              "default": '#ffffff'
            },
            fillStyle: {
              detail: '图形填充色',
              "default": '#f2fbfb'
            },
            strokeAlpha: {
              detail: '边框透明度',
              "default": 0.6
            },
            focus: {
              detail: 'hover态设置',
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": true
                },
                strokeAlpha: {
                  detail: 'hover时候边框透明度',
                  "default": 0.7
                },
                lineWidth: {
                  detail: 'hover时候边框大小',
                  "default": 2
                },
                strokeStyle: {
                  detail: 'hover时候边框颜色',
                  "default": '#fff'
                }
              }
            },
            select: {
              detail: '选中态设置',
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": false
                },
                strokeAlpha: {
                  detail: '选中时候边框透明度',
                  "default": 1
                },
                lineWidth: {
                  detail: '选中时候边框大小',
                  "default": 2
                },
                strokeStyle: {
                  detail: '选中时候边框颜色',
                  "default": '#fff'
                },
                triggerEventType: {
                  detail: '触发事件',
                  "default": 'click,tap'
                },
                onbefore: {
                  detail: '执行select处理函数的前处理函数，返回false则取消执行select',
                  "default": null
                },
                onend: {
                  detail: '执行select处理函数的后处理函数',
                  "default": null
                }
              }
            }
          }
        },
        label: {
          detail: '文本设置',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": true
            },
            fontColor: {
              detail: '文本颜色',
              "default": '#666666'
            },
            fontSize: {
              detail: '文本字体大小',
              "default": 13
            },
            textAlign: {
              detail: '水平对齐方式',
              "default": 'center'
            },
            verticalAlign: {
              detail: '基线对齐方式',
              "default": 'middle'
            },
            position: {
              detail: '文本布局位置',
              "default": 'center'
            },
            offsetX: {
              detail: 'x方向偏移量',
              "default": 0
            },
            offsetY: {
              detail: 'y方向偏移量',
              "default": 0
            }
          }
        }
      };
    }
  }]);
  return PlanetGroup;
}();

exports["default"] = PlanetGroup;
});

unwrapExports(group$1);

var planet = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(graphs);

var _group = interopRequireDefault(group$1);

var _dataSection = interopRequireDefault(dataSection_1);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Text = _canvax["default"].Display.Text;
var Circle = _canvax["default"].Shapes.Circle;
var Line = _canvax["default"].Shapes.Line;
var Rect = _canvax["default"].Shapes.Rect;
var Sector = _canvax["default"].Shapes.Sector;

var PlanetGraphs = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(PlanetGraphs, _GraphsBase);

  var _super = _createSuper(PlanetGraphs);

  function PlanetGraphs(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, PlanetGraphs);
    _this = _super.call(this, opt, app);
    _this.type = "planet";
    _this.groupDataFrames = [];
    _this.groupField = null;
    _this._ringGroups = []; //groupField对应的 group 对象
    //planet自己得grid，不用polar的grid

    _this.grid = {
      rings: {
        _section: []
      }
    };

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(PlanetGraphs.defaultProps()), opt);

    if (_this.center.radius == 0 || !_this.center.enabled) {
      _this.center.radius = 0;
      _this.center.margin = 0;
      _this.center.enabled = false;
    }
    _this.__scanIngCurOration = 0;

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(PlanetGraphs, [{
    key: "init",
    value: function init() {
      this.gridSp = new _canvax["default"].Display.Sprite({
        id: "gridSp"
      });
      this.groupSp = new _canvax["default"].Display.Sprite({
        id: "groupSp"
      });
      this.scanSp = new _canvax["default"].Display.Sprite({
        id: "scanSp"
      });
      this.centerSp = new _canvax["default"].Display.Sprite({
        id: "centerSp"
      });
      this.sprite.addChild(this.gridSp);
      this.sprite.addChild(this.groupSp);
      this.sprite.addChild(this.scanSp);
      this.sprite.addChild(this.centerSp);
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {});

      _.extend(true, this, opt);

      this._dataGroupHandle();

      this._drawGroups();

      this._drawBack();

      this._drawBewrite();

      this._drawCenter();

      this._drawScan();

      this.fire("complete");
    }
  }, {
    key: "_getMaxR",
    value: function _getMaxR() {
      var _circleMaxR;

      if (this.graphs && this.graphs.group && this.graphs.group.circle) {
        _circleMaxR = this.graphs.group.circle.maxRadius;
      }

      if (_circleMaxR == undefined) {
        _circleMaxR = 30;
      }
      return _circleMaxR;
    }
  }, {
    key: "_drawGroups",
    value: function _drawGroups() {
      var me = this;
      var groupRStart = this.center.radius + this.center.margin;
      var maxRadius = me.app.getComponent({
        name: 'coord'
      }).getMaxDisToViewOfOrigin() - me.center.radius - me.center.margin;

      var _circleMaxR = this._getMaxR();

      _.each(this.groupDataFrames, function (df, i) {
        var toR = groupRStart + maxRadius * (df.length / me.dataFrame.length);

        var _g = new _group["default"](_.extend(true, {
          iGroup: i,
          groupLen: me.groupDataFrames.length,
          rRange: {
            start: groupRStart,
            to: toR
          },
          width: me.width - _circleMaxR * 2,
          height: me.height - _circleMaxR * 2,
          selectInds: me.selectInds
        }, me._opt), df, me);

        groupRStart = _g.rRange.to;

        me._ringGroups.push(_g);

        me.grid.rings._section.push({
          radius: _g.rRange.to
        });
      });

      _.each(me._ringGroups, function (_g) {
        me.sprite.addChild(_g.sprite);
      });
    }
  }, {
    key: "_drawCenter",
    value: function _drawCenter() {
      var me = this;

      if (this.center.enabled) {
        //绘制中心实心圆
        this._center = new Circle({
          hoverClone: false,
          context: {
            x: this.origin.x,
            y: this.origin.y,
            fillStyle: this.center.fillStyle,
            r: this.center.radius,
            cursor: this.center.cursor
          }
        }); //绘制实心圆上面的文案

        this._centerTxt = new Text(this.center.text, {
          context: {
            x: this.origin.x,
            y: this.origin.y,
            fontSize: this.center.fontSize,
            textAlign: "center",
            textBaseline: "middle",
            fillStyle: this.center.fontColor
          }
        }); //给圆点添加事件

        this._center.on(event.types.get(), function (e) {
          e.eventInfo = {
            title: me.center.text,
            trigger: 'this.center',
            //me.center,
            nodes: [me.center]
          };

          if (me.center['onclick']) {
            if (e.type == 'mousedown') {
              me._center.context.r += 2;
            }

            if (e.type == 'mouseup') {
              me._center.context.r -= 2;
            }
          }
          me.app.fire(e.type, e);
        });

        this.centerSp.addChild(this._center);
        this.centerSp.addChild(this._centerTxt);
      }
    }
  }, {
    key: "_drawBack",
    value: function _drawBack() {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      if (me.grid.rings._section.length == 1) {
        //如果只有一个，那么就强制添加到3个
        var _diffR = (me.grid.rings._section[0].radius - me.center.radius) / me.grid.rings.count;

        me.grid.rings._section = [];

        for (var i = 0; i < me.grid.rings.count; i++) {
          me.grid.rings._section.push({
            radius: me.center.radius + _diffR * (i + 1)
          });
        }
      } else {
        me.grid.rings.count = me.grid.rings._section.length;
      }

      for (var _i = me.grid.rings._section.length - 1; _i >= 0; _i--) {
        var _scale = me.grid.rings._section[_i];
        me.gridSp.addChild(new Circle({
          context: {
            x: _coord.origin.x,
            y: _coord.origin.y,
            r: _scale.radius,
            lineWidth: me._getBackProp(me.grid.rings.lineWidth, _i),
            strokeStyle: me._getBackProp(me.grid.rings.strokeStyle, _i),
            fillStyle: me._getBackProp(me.grid.rings.fillStyle, _i)
          }
        }));
      }

      if (me.grid.rays.count > 1) {
        var cx = _coord.origin.x;
        var cy = _coord.origin.y;
        var itemAng = 360 / me.grid.rays.count;

        var _r = _coord.getMaxDisToViewOfOrigin(); //Math.max( me.w, me.h );


        if (me.grid.rings._section.length) {
          _r = me.grid.rings._section.slice(-1)[0].radius;
        }

        for (var _i2 = 0, l = me.grid.rays.count; _i2 < l; _i2++) {
          var radian = itemAng * _i2 / 180 * Math.PI;

          var tx = cx + _r * Math.cos(radian);

          var ty = cy + _r * Math.sin(radian);

          me.gridSp.addChild(new Line({
            context: {
              start: {
                x: cx,
                y: cy
              },
              end: {
                x: tx,
                y: ty
              },
              lineWidth: me._getBackProp(me.grid.rays.lineWidth, _i2),
              strokeStyle: me._getBackProp(me.grid.rays.strokeStyle, _i2),
              globalAlpha: me.grid.rays.globalAlpha
            }
          }));
        }
      }

      var _clipRect = new Rect({
        name: "clipRect",
        context: {
          x: _coord.origin.x - me.app.width / 2,
          y: _coord.origin.y - me.height / 2,
          width: me.app.width,
          height: me.height
        }
      });

      me.gridSp.clipTo(_clipRect); //TODO：理论上下面这句应该可以神略了才行

      me.sprite.addChild(_clipRect);
    }
  }, {
    key: "_getBackProp",
    value: function _getBackProp(p, i) {
      //let iGroup = i;
      var res = null;

      if (_.isFunction(p)) {
        res = p.apply(this, [{
          //iGroup : iGroup,
          scaleInd: i,
          count: this.grid.rings._section.length,
          groups: this._ringGroups,
          graphs: this
        }]);
      }

      if (_.isString(p) || _.isNumber(p)) {
        res = p;
      }

      if (_.isArray(p)) {
        res = p[i];
      }
      return res;
    }
  }, {
    key: "_drawBewrite",
    value: function _drawBewrite() {
      var me = this; //如果开启了描述中线

      if (me.bewrite.enabled) {
        var _draw = function _draw(direction, _txt, _powerTxt, _weakTxt) {
          //先绘制右边的
          _powerTxt.context.x = direction * me.center.radius + direction * 20;

          _bewriteSp.addChild(_powerTxt);

          _bewriteSp.addChild(new Line({
            context: {
              lineType: 'dashed',
              start: {
                x: _powerTxt.context.x,
                y: 0
              },
              end: {
                x: direction * (_txt ? _graphR / 2 - _txtWidth / 2 : _graphR),
                y: 0
              },
              lineWidth: 1,
              strokeStyle: "#ccc"
            }
          }));

          if (_txt) {
            _txt.context.x = direction * (_graphR / 2);

            _bewriteSp.addChild(_txt);

            _bewriteSp.addChild(new Line({
              context: {
                lineType: 'dashed',
                start: {
                  x: direction * (_graphR / 2 + _txtWidth / 2),
                  y: 0
                },
                end: {
                  x: direction * _graphR,
                  y: 0
                },
                lineWidth: 1,
                strokeStyle: "#ccc"
              }
            }));
          }
          _weakTxt.context.x = direction * _graphR;

          _bewriteSp.addChild(_weakTxt);
        };

        var _txt, _txtWidth, _powerTxt, _weakTxt;

        if (me.bewrite.text) {
          _txt = new _canvax["default"].Display.Text(me.bewrite.text, {
            context: {
              fillStyle: me.bewrite.fontColor,
              fontSize: me.bewrite.fontSize,
              textBaseline: "middle",
              textAlign: "center"
            }
          });
          _txtWidth = _txt.getTextWidth();
        }
        _powerTxt = new _canvax["default"].Display.Text("强", {
          context: {
            fillStyle: me.bewrite.fontColor,
            fontSize: me.bewrite.fontSize,
            textBaseline: "middle",
            textAlign: "center"
          }
        });
        _weakTxt = new _canvax["default"].Display.Text("弱", {
          context: {
            fillStyle: me.bewrite.fontColor,
            fontSize: me.bewrite.fontSize,
            textBaseline: "middle",
            textAlign: "center"
          }
        });

        var _bewriteSp = new _canvax["default"].Display.Sprite({
          context: {
            x: this.origin.x,
            y: this.origin.y
          }
        });

        me.sprite.addChild(_bewriteSp);

        var _graphR = me.width / 2;

        _draw(1, _txt.clone(), _powerTxt.clone(), _weakTxt.clone());

        _draw(-1, _txt.clone(), _powerTxt.clone(), _weakTxt.clone());
      }
    }
  }, {
    key: "scan",
    value: function scan() {
      var me = this;
      this._scanAnim && this._scanAnim.stop();

      var _scanSp = me._getScanSp(); //开始动画


      if (me.__scanIngCurOration == 360) {
        _scanSp.context.rotation = 0;
      }
      me._scanAnim = _scanSp.animate({
        rotation: 360,
        globalAlpha: 1
      }, {
        duration: 1000 * ((360 - me.__scanIngCurOration) / 360),
        onUpdate: function onUpdate(e) {
          me.__scanIngCurOration = e.rotation;
        },
        onComplete: function onComplete() {
          _scanSp.context.rotation = 0;
          me._scanAnim = _scanSp.animate({
            rotation: 360
          }, {
            duration: 1000,
            repeat: 1000,
            //一般repeat不到1000
            onUpdate: function onUpdate(e) {
              me.__scanIngCurOration = e.rotation;
            }
          });
        }
      });
    }
  }, {
    key: "_drawScan",
    value: function _drawScan(callback) {
      var me = this;

      if (me.scan.enabled) {
        var _scanSp = me._getScanSp(); //开始动画


        if (me.__scanIngCurOration == 360) {
          _scanSp.context.rotation = 0;
        }
        me._scanAnim && me._scanAnim.stop();
        me._scanAnim = _scanSp.animate({
          rotation: 360,
          globalAlpha: 1
        }, {
          duration: 1000 * ((360 - me.__scanIngCurOration) / 360),
          onUpdate: function onUpdate(e) {
            me.__scanIngCurOration = e.rotation;
          },
          onComplete: function onComplete() {
            _scanSp.context.rotation = 0;
            me._scanAnim = _scanSp.animate({
              rotation: 360
            }, {
              duration: 1000,
              repeat: me.scan.repeat - 2,
              onUpdate: function onUpdate(e) {
                me.__scanIngCurOration = e.rotation;
              },
              onComplete: function onComplete() {
                _scanSp.context.rotation = 0;
                me._scanAnim = _scanSp.animate({
                  rotation: 360,
                  globalAlpha: 0
                }, {
                  duration: 1000,
                  onUpdate: function onUpdate(e) {
                    me.__scanIngCurOration = e.rotation;
                  },
                  onComplete: function onComplete() {
                    _scanSp.destroy();

                    me.__scanSp = null;
                    delete me.__scanSp;
                    me.__scanIngCurOration = 0;
                    callback && callback();
                  }
                });
              }
            });
          }
        });
      }
    }
  }, {
    key: "_getScanSp",
    value: function _getScanSp() {
      var me = this; //先准备scan元素

      var _scanSp = me.__scanSp;

      if (!_scanSp) {
        _scanSp = new _canvax["default"].Display.Sprite({
          context: {
            x: this.origin.x,
            y: this.origin.y,
            globalAlpha: 0,
            rotation: me.__scanIngCurOration
          }
        });
        me.scanSp.addChild(_scanSp);
        me.__scanSp = _scanSp;
        var r = me.scan.r || me.height / 2 - 10;
        var fillStyle = me.scan.fillStyle || me.center.fillStyle; //如果开启了扫描效果

        var count = me.scan.angle;

        for (var i = 0, l = count; i < l; i++) {
          var node = new Sector({
            context: {
              r: r,
              fillStyle: fillStyle,
              clockwise: true,
              startAngle: 360 - i,
              endAngle: 359 - i,
              globalAlpha: me.scan.alpha - me.scan.alpha / count * i
            }
          });

          _scanSp.addChild(node);
        }

        var _line = new Line({
          context: {
            end: {
              x: r,
              y: 0
            },
            lineWidth: 1,
            strokeStyle: fillStyle
          }
        });

        _scanSp.addChild(_line);
      }

      return _scanSp;
    }
  }, {
    key: "_dataGroupHandle",
    value: function _dataGroupHandle() {
      var groupFieldInd = _.indexOf(this.dataFrame.fields, this.groupField);

      if (groupFieldInd >= 0) {
        //有分组字段，就还要对dataFrame中的数据分下组，然后给到 groupDataFrames
        var titles = this.dataFrame.org[0];
        var _dmap = {}; //以分组的字段值做为key

        _.each(this.dataFrame.org, function (row, i) {
          if (i) {
            //从i==1 行开始，因为第一行是titles
            if (!_dmap[row[groupFieldInd]]) {
              //如果没有记录，先创建
              _dmap[row[groupFieldInd]] = [_.clone(titles)];
            }

            _dmap[row[groupFieldInd]].push(row);
          }
        });

        for (var r in _dmap) {
          this.groupDataFrames.push((0, _dataSection["default"])(_dmap[r]));
        }
      } else {
        //如果分组字段不存在，则认为数据不需要分组，直接全部作为 group 的一个子集合
        this.groupDataFrames.push(this.dataFrame);
      }
    } //graphs方法

  }, {
    key: "show",
    value: function show(field, trigger) {
      this.getAgreeNodeData(trigger, function (data) {
        data.nodeElement && (data.nodeElement.context.visible = true);
        data.labelElement && (data.labelElement.context.visible = true);
      });
    }
  }, {
    key: "hide",
    value: function hide(field, trigger) {
      this.getAgreeNodeData(trigger, function (data) {
        data.nodeElement && (data.nodeElement.context.visible = false);
        data.labelElement && (data.labelElement.context.visible = false);
      });
    }
  }, {
    key: "getAgreeNodeData",
    value: function getAgreeNodeData(trigger, callback) {
      _.each(this._ringGroups, function (_g) {
        _.each(_g._rings, function (ring) {
          _.each(ring.planets, function (data) {
            var rowData = data.rowData;

            if (trigger.params.name == rowData[trigger.params.field]) {
              //这个数据符合
              //data.nodeElement.context.visible = false;
              //data.labelElement.context.visible = false;
              callback && callback(data);
            }
          });
        });
      });
    } //获取所有有效的在布局中的nodeData

  }, {
    key: "getLayoutNodes",
    value: function getLayoutNodes() {
      var nodes = [];

      _.each(this._ringGroups, function (rg) {
        _.each(rg.planets, function (node) {
          if (node.pit) {
            nodes.push(node);
          }
        });
      });

      return nodes;
    } //获取所有无效的在不在布局的nodeData

  }, {
    key: "getInvalidNodes",
    value: function getInvalidNodes() {
      var nodes = [];

      _.each(this._ringGroups, function (rg) {
        _.each(rg.planets, function (node) {
          if (!node.pit) {
            nodes.push(node);
          }
        });
      });

      return nodes;
    } //ind 对应源数据中的index

  }, {
    key: "selectAt",
    value: function selectAt(ind) {
      var me = this;

      _.each(me._ringGroups, function (_g) {
        _g.selectAt(ind);
      });
    } //selectAll

  }, {
    key: "selectAll",
    value: function selectAll() {
      var me = this;

      _.each(me.dataFrame.getFieldData("__index__"), function (_ind) {
        me.selectAt(_ind);
      });
    } //ind 对应源数据中的index

  }, {
    key: "unselectAt",
    value: function unselectAt(ind) {
      var me = this;

      _.each(me._ringGroups, function (_g) {
        _g.unselectAt(ind);
      });
    } //unselectAll

  }, {
    key: "unselectAll",
    value: function unselectAll() {
      var me = this;

      _.each(me.dataFrame.getFieldData("__index__"), function (_ind) {
        me.unselectAt(_ind);
      });
    } //获取所有的节点数据

  }, {
    key: "getSelectedNodes",
    value: function getSelectedNodes() {
      var arr = [];

      _.each(this._ringGroups, function (_g) {
        arr = arr.concat(_g.getSelectedNodes());
      });

      return arr;
    } //获取所有的节点数据对应的原始数据行

  }, {
    key: "getSelectedRowList",
    value: function getSelectedRowList() {
      var arr = [];

      _.each(this._ringGroups, function (_g) {
        var rows = [];

        _.each(_g.getSelectedNodes(), function (nodeData) {
          rows.push(nodeData.rowData);
        });

        arr = arr.concat(rows);
      });

      return arr;
    }
  }, {
    key: "getNodesAt",
    value: function getNodesAt() {}
  }, {
    key: "resetData",
    value: function resetData(dataFrame) {
      this.clean();
      this.dataFrame = dataFrame;

      this._dataGroupHandle();

      this._drawGroups();

      this._drawScan();
    }
  }, {
    key: "clean",
    value: function clean() {
      var me = this;
      me.groupDataFrames = [];

      _.each(me._ringGroups, function (_g) {
        _g.sprite.destroy();
      });

      me._ringGroups = [];
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: '字段设置',
          "default": null
        },
        center: {
          detail: '中心点设置',
          propertys: {
            enabled: {
              detail: '是否显示中心',
              "default": true
            },
            text: {
              detail: '中心区域文本',
              "default": 'center'
            },
            radius: {
              detail: '中心圆半径',
              "default": 30
            },
            fillStyle: {
              detail: '中心背景色',
              "default": '#70629e'
            },
            fontSize: {
              detail: '中心字体大小',
              "default": 15
            },
            fontColor: {
              detail: '中心字体颜色',
              "default": '#ffffff'
            },
            margin: {
              detail: '中区区域和外围可绘图区域距离',
              "default": 20
            },
            cursor: {
              detail: '中心节点的鼠标手势',
              "default": 'default'
            }
          }
        },
        selectInds: {
          detail: '选中的数据索引',
          "default": []
        },
        grid: {
          detail: '星系图自己的grid',
          propertys: {
            rings: {
              detail: '环配置',
              propertys: {
                fillStyle: {
                  detail: '背景色',
                  "default": null
                },
                strokeStyle: {
                  detail: '环线色',
                  "default": null
                },
                lineWidth: {
                  detail: '环线宽',
                  "default": 1
                },
                count: {
                  detail: '分几环',
                  "default": 3
                }
              }
            },
            rays: {
              detail: '射线配置',
              propertys: {
                count: {
                  detail: '射线数量',
                  "default": 0
                },
                globalAlpha: {
                  detail: '线透明度',
                  "default": 0.4
                },
                strokeStyle: {
                  detail: '线色',
                  "default": '#10519D'
                },
                lineWidth: {
                  detail: '线宽',
                  "default": 1
                }
              }
            }
          }
        },
        bewrite: {
          detail: 'planet的趋势描述',
          propertys: {
            enabled: {
              detail: '是否开启趋势描述',
              "default": false
            },
            text: {
              detail: '描述文本',
              "default": null
            },
            fontColor: {
              detail: 'fontColor',
              "default": '#999'
            },
            fontSize: {
              detail: 'fontSize',
              "default": 12
            }
          }
        },
        scan: {
          detail: '扫描效果',
          propertys: {
            enabled: {
              detail: '是否开启扫描效果',
              "default": false
            },
            fillStyle: {
              detail: '扫描效果颜色',
              "default": null //默认取 me._graphs.center.fillStyle

            },
            alpha: {
              detail: '起始透明度',
              "default": 0.6
            },
            angle: {
              detail: '扫描效果的覆盖角度',
              "default": 90
            },
            r: {
              detail: '扫描效果覆盖的半径',
              "default": null
            },
            repeat: {
              detail: '扫描次数',
              "default": 3
            }
          }
        },
        _props: [_group["default"]]
      };
    }
  }]);
  return PlanetGraphs;
}(_index["default"]);

_index["default"].registerComponent(PlanetGraphs, 'graphs', 'planet');

var _default = PlanetGraphs;
exports["default"] = _default;
});

unwrapExports(planet);

var funnel = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(graphs);





var _numeral = interopRequireDefault(numeral);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Text = _canvax["default"].Display.Text;
var Polygon = _canvax["default"].Shapes.Polygon;

var FunnelGraphs = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(FunnelGraphs, _GraphsBase);

  var _super = _createSuper(FunnelGraphs);

  function FunnelGraphs(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, FunnelGraphs);
    _this = _super.call(this, opt, app);
    _this.type = "funnel";
    _this.dataOrg = []; //this.dataFrame.getFieldData( this.field )

    _this.data = []; //layoutData list , default is empty Array

    _this.maxValue = null;
    _this.minValue = null;

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(FunnelGraphs.defaultProps()), opt);

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(FunnelGraphs, [{
    key: "init",
    value: function init() {
      if (!this.node.maxFillStyle) {
        this.node.maxFillStyle = this.app.getTheme(0);
      }

      this._nodesp = new _canvax["default"].Display.Sprite({
        id: "nodeSp"
      });
      this._textsp = new _canvax["default"].Display.Sprite({
        id: "textsp"
      });
      this.sprite.addChild(this._nodesp);
      this.sprite.addChild(this._textsp);
    }
  }, {
    key: "_computerAttr",
    value: function _computerAttr() {
      if (this.field) {
        this.dataOrg = this.dataFrame.getFieldData(this.field);
      }
      this.maxValue = _.max(this.dataOrg);
      this.minValue = _.min(this.dataOrg); //计算一些基础属性，比如maxNodeWidth等， 加入外面没有设置

      if (this.node.maxWidth == null) {
        this.node.maxWidth = parseInt(this.width * 1);
      }

      if (this.node.minWidth == null) {
        if (this.maxValue == this.minValue) {
          this.node.minWidth = this.node.maxValue;
        } else {
          this.node.minWidth = parseInt(this.node.maxWidth * (this.minValue / this.maxValue)); //this.node.minWidth = parseInt( this.node.maxWidth * 1/this.dataOrg.length );
        }
      }

      if (this.node.spireWidth == null) {
        this.node.spireWidth = this.node.minWidth;
      }

      if (!this.node.height) {
        this.node.height = parseInt(this.height / this.dataOrg.length);
      }
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {}); //第二个data参数去掉，直接trimgraphs获取最新的data

      _.extend(true, this, opt); //let me = this;
      //let animate = me.animation && !opt.resize;


      this._computerAttr();

      this.data = this._trimGraphs();

      this._drawGraphs();

      this.sprite.context.x = this.origin.x + this.width / 2;
      this.sprite.context.y = this.origin.y;
      this.fire("complete");
    }
  }, {
    key: "_trimGraphs",
    value: function _trimGraphs() {
      if (!this.field) return;
      var me = this; //let dataOrg = _.clone( this.dataOrg );

      var layoutData = [];

      var _coord = this.app.getCoord();

      _.each(this.dataOrg, function (num, i) {
        var rowData = me.dataFrame.getRowDataAt(i);
        var ld = {
          type: "funnel",
          field: me.field,
          rowData: rowData,
          value: num,
          name: me.nameField ? rowData[me.nameField] : i + 1,
          width: me._getNodeWidth(num),
          color: '',
          //me.app.getTheme(i),//默认从皮肤中获取
          cursor: "pointer",
          //下面得都在layoutData的循环中计算
          label: '',
          middlePoint: null,
          iNode: -1,
          points: []
        };
        ld.color = me._getProp(me.node, 'fillStyle', ld);
        layoutData.push(ld);
      });

      if (this.sort) {
        layoutData = layoutData.sort(function (a, b) {
          if (me.sort == "desc") {
            return b.value - a.value;
          } else {
            return a.value - b.value;
          }
        });
      }

      _.each(layoutData, function (ld, i) {
        ld.iNode = i; //ld.label = me.label.format( ld.value , ld );

        var value = ld.value;

        if (me.label.format) {
          if (_.isFunction(me.label.format)) {
            var _formatc = me.label.format.apply(me, [value, ld]);

            if (_formatc !== undefined || _formatc !== null) {
              value = _formatc;
            }
          }

          if (typeof me.label.format == 'string') {
            value = (0, _numeral["default"])(value).format(me.label.format);
          }
        } else {
          //否则用fieldConfig上面的
          var fieldConfig = _coord.getFieldConfig(me.field);

          if (fieldConfig) {
            value = fieldConfig.getFormatValue(value);
          }
        }

        ld.label = value;
      });

      _.each(layoutData, function (ld, i) {
        ld.points = me._getPoints(ld, layoutData[i + 1], layoutData[i - 1]);
        ld.middlePoint = {
          x: 0,
          y: (ld.iNode + 0.5) * me.node.height
        };
      });

      return layoutData;
    }
  }, {
    key: "_getNodeWidth",
    value: function _getNodeWidth(num) {
      var width = this.node.maxWidth;

      if (this.maxValue != this.minValue) {
        width = parseInt(this.node.minWidth + (this.node.maxWidth - this.node.minWidth) / (this.maxValue - this.minValue) * (num - this.minValue));
      }
      return width;
    }
  }, {
    key: "_getPoints",
    value: function _getPoints(layoutData, nextLayoutData, preLayoutData) {
      var points = [];
      var topY = layoutData.iNode * this.node.height;
      var bottomY = topY + this.node.height;

      if (this.sort !== "asc") {
        points.push([-layoutData.width / 2, topY]); //左上

        points.push([layoutData.width / 2, topY]); //右上
        //let bottomWidth = this.node.minWidth;
        //if( nextLayoutData ){

        var bottomWidth = nextLayoutData ? nextLayoutData.width : layoutData.width; //};

        if (!nextLayoutData && this.node.spireWidth != null && this.maxValue != this.minValue) {
          //说明最后一个节点
          bottomWidth = Math.min(this.node.spireWidth, bottomWidth);
        }

        points.push([bottomWidth / 2, bottomY]); //右下

        points.push([-bottomWidth / 2, bottomY]); //左下
      } else {
        //正金字塔结构的话，是从最上面一个 data 的 top 取min开始
        //let topWidth = this.node.minWidth;
        //if( preLayoutData ){
        var topWidth = preLayoutData ? preLayoutData.width : layoutData.width; //};

        if (!preLayoutData && this.node.spireWidth != null && this.maxValue != this.minValue) {
          //说明最后一个节点
          topWidth = Math.min(this.node.spireWidth, topWidth);
        }

        points.push([-topWidth / 2, topY]); //左上

        points.push([topWidth / 2, topY]); //右上

        points.push([layoutData.width / 2, bottomY]); //右下

        points.push([-layoutData.width / 2, bottomY]); //左下
      }

      return points;
    }
  }, {
    key: "_drawGraphs",
    value: function _drawGraphs() {
      var me = this;

      var _coord = this.app.getCoord();

      var fieldConfig = _coord.getFieldConfig(me.field);

      var title = fieldConfig.name || this.field;

      _.each(this.data, function (ld) {
        //let fillStyle   = this._getProp(this.node, "fillStyle", geoGraph);
        var fillAlpha = me._getProp(me.node, "fillAlpha", ld);

        var strokeStyle = me._getProp(me.node, "strokeStyle", ld);

        var strokeAlpha = me._getProp(me.node, "strokeAlpha", ld);

        var lineWidth = me._getProp(me.node, "lineWidth", ld);

        var lineType = me._getProp(me.node, "lineType", ld);

        var _polygon = new Polygon({
          id: "funel_item_" + ld.iNode,
          hoverClone: false,
          context: {
            pointList: ld.points,
            fillStyle: ld.color,
            cursor: ld.cursor,
            fillAlpha: fillAlpha,
            strokeStyle: strokeStyle,
            strokeAlpha: strokeAlpha,
            lineWidth: lineWidth,
            lineType: lineType
          }
        });

        ld.nodeElement = _polygon;

        me._nodesp.addChild(_polygon);

        _polygon.nodeData = ld;

        _polygon.on(event.types.get(), function (e) {
          e.eventInfo = {
            trigger: 'this.node',
            title: title,
            nodes: [this.nodeData]
          };

          if (e.type == 'mouseover') {
            me.focusAt(this.nodeData.iNode);
          }

          if (e.type == 'mouseout') {
            !this.nodeData.selected && me.unfocusAt(this.nodeData.iNode);
          }

          me.app.fire(e.type, e);
        });

        var textAlign = "center";
        var textPoint = {
          x: ld.middlePoint.x,
          y: ld.middlePoint.y
        };

        if (me.label.textAlign == "left") {
          textPoint.x = ld.points[0][0] - (ld.points[0][0] - ld.points[3][0]) / 2;
          textPoint.x -= 15;
          textAlign = "right";
        }

        if (me.label.textAlign == "right") {
          textPoint.x = ld.points[1][0] - (ld.points[1][0] - ld.points[2][0]) / 2;
          textPoint.x += 15;
          textAlign = "left";
        }
        ld.textPoint = textPoint;

        var _text = new Text(ld.label, {
          context: {
            x: textPoint.x,
            y: textPoint.y,
            fontSize: me.label.fontSize,
            fillStyle: me.label.textAlign == "center" ? me.label.fontColor : ld.color,
            strokeStyle: me.label.strokeStyle,
            lineWidth: me.label.lineWidth,
            textAlign: textAlign,
            textBaseline: me.label.textBaseline
          }
        });

        me._textsp.addChild(_text);

        me.node.drawEnd(ld);
      });
    }
  }, {
    key: "focusAt",
    value: function focusAt(iNode) {
      var _el = this._nodesp.getChildById('funel_item_' + iNode);

      var nodeData = _el.nodeData;

      if (_el) {
        var _el$context = _el.context,
            fillStyle = _el$context.fillStyle,
            fillAlpha = _el$context.fillAlpha,
            strokeStyle = _el$context.strokeStyle,
            strokeAlpha = _el$context.strokeAlpha;
        _el._default = {
          fillStyle: fillStyle,
          fillAlpha: fillAlpha,
          strokeStyle: strokeStyle,
          strokeAlpha: strokeAlpha
        };
        var focusFillStyle = this._getProp(this.node.focus, "fillStyle", nodeData) || fillStyle;
        var focusFillAlpha = this._getProp(this.node.focus, "fillAlpha", nodeData) || fillAlpha;
        var focusStrokeStyle = this._getProp(this.node.focus, "strokeStyle", nodeData) || strokeStyle;
        var focusStrokeAlpha = this._getProp(this.node.focus, "strokeAlpha", nodeData) || strokeAlpha;

        var focusLineWidth = this._getProp(this.node.focus, "lineWidth", nodeData);

        var focusLineType = this._getProp(this.node.focus, "lineType", nodeData);

        _el.context.fillStyle = focusFillStyle;
        _el.context.fillAlpha = focusFillAlpha;
        _el.context.strokeStyle = focusStrokeStyle;
        _el.context.strokeAlpha = focusStrokeAlpha;
        _el.context.lineWidth = focusLineWidth;
        _el.context.lineType = focusLineType;
      }
    }
  }, {
    key: "unfocusAt",
    value: function unfocusAt(iNode) {
      var _el = this._nodesp.getChildById('funel_item_' + iNode);

      if (_el) {
        var _el$_default = _el._default,
            fillStyle = _el$_default.fillStyle,
            fillAlpha = _el$_default.fillAlpha,
            strokeStyle = _el$_default.strokeStyle,
            strokeAlpha = _el$_default.strokeAlpha,
            lineType = _el$_default.lineType,
            lineWidth = _el$_default.lineWidth;
        _el.context.fillStyle = fillStyle;
        _el.context.fillAlpha = fillAlpha;
        _el.context.strokeStyle = strokeStyle;
        _el.context.strokeAlpha = strokeAlpha;
        _el.context.lineWidth = lineWidth;
        _el.context.lineType = lineType;
      }
    }
  }, {
    key: "_getProp",
    value: function _getProp(propPath, type, nodeData) {
      var configValue = propPath[type];
      var value;

      if (_.isFunction(configValue)) {
        value = configValue.apply(this, [nodeData, this.dataFrame]);
      } else {
        value = configValue;
      }

      if (type == "fillStyle") {
        var rowData = nodeData.rowData;

        if (rowData) {
          if (rowData[type] !== undefined) {
            value = rowData[type];
          } else {
            var val = rowData[this.field];

            if (!isNaN(val) && val != '') {
              var alpha = (val - this.minValue) / (this.maxValue - this.minValue) * (this.node.fillAlpha - this.node.minFillAlpha) + this.node.minFillAlpha;

              if (isNaN(alpha)) {
                //所有的数值都相同的时候，alpha会是NaN
                alpha = 1;
              }
              value = (0, color.colorRgba)(this.node.maxFillStyle, parseFloat(alpha.toFixed(2)));
            }
          }
        }
      }

      return value;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: '字段配置',
          "default": null
        },
        nameFiled: {
          detail: 'field字段每行数据对应的name名称字段配置',
          "default": null
        },
        sort: {
          detail: '排序规则',
          "default": null
        },
        node: {
          detail: '单个元素图形配置',
          propertys: {
            margin: {
              detail: 'node节点之间的间距',
              "default": 2
            },
            maxWidth: {
              detail: '最大的元素宽',
              "default": null
            },
            minWidth: {
              detail: '最小的元素宽',
              "default": null
            },
            spireWidth: {
              detail: '漏斗的塔尖的宽度，默认等于minWidth',
              documentation: '如果想要实现全三角的效果，可以设置为0',
              "default": null
            },
            height: {
              detail: '高',
              "default": 0,
              documentation: '漏斗单元高，如果options没有设定， 就会被自动计算为 this.height/dataOrg.length'
            },
            drawEnd: {
              detail: '单个节点绘制完毕处理函数',
              "default": function _default() {}
            },
            fillStyle: {
              detail: '单个区块背景色',
              "default": null //'#fff' //从themeColor获取默认 , 默认为空就会没有颜色的区块不会有事件点击

            },
            fillAlpha: {
              detail: '单个区块透明度',
              "default": 1
            },
            maxFillStyle: {
              detail: '单个区块数值最大的颜色值',
              "default": null
            },
            maxFillAlpha: {
              detail: '单个区块最大透明度',
              "default": 1
            },
            minFillAlpha: {
              detail: '单个区块最小透明度',
              "default": 0.5
            },
            strokeStyle: {
              detail: '单个区块描边颜色',
              "default": null
            },
            strokeAlpha: {
              detail: '单个区块描边透明度',
              "default": 1
            },
            lineWidth: {
              detail: '单个区块描边线宽',
              "default": 0
            },
            lineType: {
              detail: '区块描边样式',
              "default": 'solid'
            },
            focus: {
              detail: "单个区块hover态设置",
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": true
                },
                fillStyle: {
                  detail: 'hover态单个区块背景色',
                  "default": null //从themeColor获取默认

                },
                fillAlpha: {
                  detail: 'hover态单个区块透明度',
                  "default": 0.95
                },
                strokeStyle: {
                  detail: 'hover态单个区块描边颜色',
                  "default": null //默认获取themeColor

                },
                strokeAlpha: {
                  detail: 'hover态单个区块描边透明度',
                  "default": null //默认获取themeColor

                },
                lineWidth: {
                  detail: 'hover态单个区块描边线宽',
                  "default": null
                },
                lineType: {
                  detail: 'hover态区块描边样式',
                  "default": null
                }
              }
            },
            select: {
              detail: "单个区块选中态设置",
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": false
                },
                fillStyle: {
                  detail: '选中态单个区块背景色',
                  "default": null //从themeColor获取默认

                },
                fillAlpha: {
                  detail: '选中态单个区块透明度',
                  "default": 1
                },
                strokeStyle: {
                  detail: '选中态单个区块描边颜色',
                  "default": null
                },
                strokeAlpha: {
                  detail: '选中态单个区块描边颜色',
                  "default": null
                },
                lineWidth: {
                  detail: '选中态单个区块描边线宽',
                  "default": null
                },
                lineType: {
                  detail: '选中态区块描边样式',
                  "default": null
                }
              }
            }
          }
        },
        label: {
          detail: '文本配置',
          propertys: {
            enabled: {
              detail: '是否开启文本',
              "default": true
            },
            textAlign: {
              detail: '文本布局位置(left,center,right)',
              "default": 'center'
            },
            textBaseline: {
              detail: '文本基线对齐方式',
              "default": 'middle'
            },
            format: {
              detail: '文本格式化处理函数',
              "default": null
            },
            fontSize: {
              detail: '文本字体大小',
              "default": 13
            },
            fontColor: {
              detail: '文本颜色',
              "default": '#ffffff',
              documentation: 'align为center的时候的颜色，align为其他属性时候取node的颜色'
            },
            strokeStyle: {
              detail: '文本描边色',
              "default": '#fff'
            },
            lineWidth: {
              detail: '文本描边宽',
              "default": 0
            }
          }
        }
      };
    }
  }]);
  return FunnelGraphs;
}(_index["default"]);

_index["default"].registerComponent(FunnelGraphs, 'graphs', 'funnel');

var _default2 = FunnelGraphs;
exports["default"] = _default2;
});

unwrapExports(funnel);

var fmin = createCommonjsModule(function (module, exports) {
(function (global, factory) {
     factory(exports) ;
}(commonjsGlobal, function (exports) {
    /** finds the zeros of a function, given two starting points (which must
     * have opposite signs */
    function bisect(f, a, b, parameters) {
        parameters = parameters || {};
        var maxIterations = parameters.maxIterations || 100,
            tolerance = parameters.tolerance || 1e-10,
            fA = f(a),
            fB = f(b),
            delta = b - a;

        if (fA * fB > 0) {
            throw "Initial bisect points must have opposite signs";
        }

        if (fA === 0) return a;
        if (fB === 0) return b;

        for (var i = 0; i < maxIterations; ++i) {
            delta /= 2;
            var mid = a + delta,
                fMid = f(mid);

            if (fMid * fA >= 0) {
                a = mid;
            }

            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {
                return mid;
            }
        }
        return a + delta;
    }

    // need some basic operations on vectors, rather than adding a dependency,
    // just define here
    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }
    function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }

    function dot(a, b) {
        var ret = 0;
        for (var i = 0; i < a.length; ++i) {
            ret += a[i] * b[i];
        }
        return ret;
    }

    function norm2(a)  {
        return Math.sqrt(dot(a, a));
    }

    function scale(ret, value, c) {
        for (var i = 0; i < value.length; ++i) {
            ret[i] = value[i] * c;
        }
    }

    function weightedSum(ret, w1, v1, w2, v2) {
        for (var j = 0; j < ret.length; ++j) {
            ret[j] = w1 * v1[j] + w2 * v2[j];
        }
    }

    /** minimizes a function using the downhill simplex method */
    function nelderMead(f, x0, parameters) {
        parameters = parameters || {};

        var maxIterations = parameters.maxIterations || x0.length * 200,
            nonZeroDelta = parameters.nonZeroDelta || 1.05,
            zeroDelta = parameters.zeroDelta || 0.001,
            minErrorDelta = parameters.minErrorDelta || 1e-6,
            minTolerance = parameters.minErrorDelta || 1e-5,
            rho = (parameters.rho !== undefined) ? parameters.rho : 1,
            chi = (parameters.chi !== undefined) ? parameters.chi : 2,
            psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,
            sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,
            maxDiff;

        // initialize simplex.
        var N = x0.length,
            simplex = new Array(N + 1);
        simplex[0] = x0;
        simplex[0].fx = f(x0);
        simplex[0].id = 0;
        for (var i = 0; i < N; ++i) {
            var point = x0.slice();
            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;
            simplex[i+1] = point;
            simplex[i+1].fx = f(point);
            simplex[i+1].id = i+1;
        }

        function updateSimplex(value) {
            for (var i = 0; i < value.length; i++) {
                simplex[N][i] = value[i];
            }
            simplex[N].fx = value.fx;
        }

        var sortOrder = function(a, b) { return a.fx - b.fx; };

        var centroid = x0.slice(),
            reflected = x0.slice(),
            contracted = x0.slice(),
            expanded = x0.slice();

        for (var iteration = 0; iteration < maxIterations; ++iteration) {
            simplex.sort(sortOrder);

            if (parameters.history) {
                // copy the simplex (since later iterations will mutate) and
                // sort it to have a consistent order between iterations
                var sortedSimplex = simplex.map(function (x) {
                    var state = x.slice();
                    state.fx = x.fx;
                    state.id = x.id;
                    return state;
                });
                sortedSimplex.sort(function(a,b) { return a.id - b.id; });

                parameters.history.push({x: simplex[0].slice(),
                                         fx: simplex[0].fx,
                                         simplex: sortedSimplex});
            }

            maxDiff = 0;
            for (i = 0; i < N; ++i) {
                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
            }

            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&
                (maxDiff < minTolerance)) {
                break;
            }

            // compute the centroid of all but the worst point in the simplex
            for (i = 0; i < N; ++i) {
                centroid[i] = 0;
                for (var j = 0; j < N; ++j) {
                    centroid[i] += simplex[j][i];
                }
                centroid[i] /= N;
            }

            // reflect the worst point past the centroid  and compute loss at reflected
            // point
            var worst = simplex[N];
            weightedSum(reflected, 1+rho, centroid, -rho, worst);
            reflected.fx = f(reflected);

            // if the reflected point is the best seen, then possibly expand
            if (reflected.fx < simplex[0].fx) {
                weightedSum(expanded, 1+chi, centroid, -chi, worst);
                expanded.fx = f(expanded);
                if (expanded.fx < reflected.fx) {
                    updateSimplex(expanded);
                }  else {
                    updateSimplex(reflected);
                }
            }

            // if the reflected point is worse than the second worst, we need to
            // contract
            else if (reflected.fx >= simplex[N-1].fx) {
                var shouldReduce = false;

                if (reflected.fx > worst.fx) {
                    // do an inside contraction
                    weightedSum(contracted, 1+psi, centroid, -psi, worst);
                    contracted.fx = f(contracted);
                    if (contracted.fx < worst.fx) {
                        updateSimplex(contracted);
                    } else {
                        shouldReduce = true;
                    }
                } else {
                    // do an outside contraction
                    weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);
                    contracted.fx = f(contracted);
                    if (contracted.fx < reflected.fx) {
                        updateSimplex(contracted);
                    } else {
                        shouldReduce = true;
                    }
                }

                if (shouldReduce) {
                    // if we don't contract here, we're done
                    if (sigma >= 1) break;

                    // do a reduction
                    for (i = 1; i < simplex.length; ++i) {
                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
                        simplex[i].fx = f(simplex[i]);
                    }
                }
            } else {
                updateSimplex(reflected);
            }
        }

        simplex.sort(sortOrder);
        return {fx : simplex[0].fx,
                x : simplex[0]};
    }

    /// searches along line 'pk' for a point that satifies the wolfe conditions
    /// See 'Numerical Optimization' by Nocedal and Wright p59-60
    /// f : objective function
    /// pk : search direction
    /// current: object containing current gradient/loss
    /// next: output: contains next gradient/loss
    /// returns a: step size taken
    function wolfeLineSearch(f, pk, current, next, a, c1, c2) {
        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),
            phi = phi0, phi_old = phi0,
            phiPrime = phiPrime0,
            a0 = 0;

        a = a || 1;
        c1 = c1 || 1e-6;
        c2 = c2 || 0.1;

        function zoom(a_lo, a_high, phi_lo) {
            for (var iteration = 0; iteration < 16; ++iteration) {
                a = (a_lo + a_high)/2;
                weightedSum(next.x, 1.0, current.x, a, pk);
                phi = next.fx = f(next.x, next.fxprime);
                phiPrime = dot(next.fxprime, pk);

                if ((phi > (phi0 + c1 * a * phiPrime0)) ||
                    (phi >= phi_lo)) {
                    a_high = a;

                } else  {
                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
                        return a;
                    }

                    if (phiPrime * (a_high - a_lo) >=0) {
                        a_high = a_lo;
                    }

                    a_lo = a;
                    phi_lo = phi;
                }
            }

            return 0;
        }

        for (var iteration = 0; iteration < 10; ++iteration) {
            weightedSum(next.x, 1.0, current.x, a, pk);
            phi = next.fx = f(next.x, next.fxprime);
            phiPrime = dot(next.fxprime, pk);
            if ((phi > (phi0 + c1 * a * phiPrime0)) ||
                (iteration && (phi >= phi_old))) {
                return zoom(a0, a, phi_old);
            }

            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
                return a;
            }

            if (phiPrime >= 0 ) {
                return zoom(a, a0, phi);
            }

            phi_old = phi;
            a0 = a;
            a *= 2;
        }

        return a;
    }

    function conjugateGradient(f, initial, params) {
        // allocate all memory up front here, keep out of the loop for perfomance
        // reasons
        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            yk = initial.slice(),
            pk, temp,
            a = 1,
            maxIterations;

        params = params || {};
        maxIterations = params.maxIterations || initial.length * 20;

        current.fx = f(current.x, current.fxprime);
        pk = current.fxprime.slice();
        scale(pk, current.fxprime,-1);

        for (var i = 0; i < maxIterations; ++i) {
            a = wolfeLineSearch(f, pk, current, next, a);

            // todo: history in wrong spot?
            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice(),
                                     alpha: a});
            }

            if (!a) {
                // faiiled to find point that satifies wolfe conditions.
                // reset direction for next iteration
                scale(pk, current.fxprime, -1);

            } else {
                // update direction using Polak–Ribiere CG method
                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);

                var delta_k = dot(current.fxprime, current.fxprime),
                    beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);

                weightedSum(pk, beta_k, pk, -1, next.fxprime);

                temp = current;
                current = next;
                next = temp;
            }

            if (norm2(current.fxprime) <= 1e-5) {
                break;
            }
        }

        if (params.history) {
            params.history.push({x: current.x.slice(),
                                 fx: current.fx,
                                 fxprime: current.fxprime.slice(),
                                 alpha: a});
        }

        return current;
    }

    function gradientDescent(f, initial, params) {
        params = params || {};
        var maxIterations = params.maxIterations || initial.length * 100,
            learnRate = params.learnRate || 0.001,
            current = {x: initial.slice(), fx: 0, fxprime: initial.slice()};

        for (var i = 0; i < maxIterations; ++i) {
            current.fx = f(current.x, current.fxprime);
            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice()});
            }

            weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);
            if (norm2(current.fxprime) <= 1e-5) {
                break;
            }
        }

        return current;
    }

    function gradientDescentLineSearch(f, initial, params) {
        params = params || {};
        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            maxIterations = params.maxIterations || initial.length * 100,
            learnRate = params.learnRate || 1,
            pk = initial.slice(),
            c1 = params.c1 || 1e-3,
            c2 = params.c2 || 0.1,
            temp,
            functionCalls = [];

        if (params.history) {
            // wrap the function call to track linesearch samples
            var inner = f;
            f = function(x, fxprime) {
                functionCalls.push(x.slice());
                return inner(x, fxprime);
            };
        }

        current.fx = f(current.x, current.fxprime);
        for (var i = 0; i < maxIterations; ++i) {
            scale(pk, current.fxprime, -1);
            learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);

            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice(),
                                     functionCalls: functionCalls,
                                     learnRate: learnRate,
                                     alpha: learnRate});
                functionCalls = [];
            }


            temp = current;
            current = next;
            next = temp;

            if ((learnRate === 0) || (norm2(current.fxprime) < 1e-5)) break;
        }

        return current;
    }

    exports.bisect = bisect;
    exports.nelderMead = nelderMead;
    exports.conjugateGradient = conjugateGradient;
    exports.gradientDescent = gradientDescent;
    exports.gradientDescentLineSearch = gradientDescentLineSearch;
    exports.zeros = zeros;
    exports.zerosM = zerosM;
    exports.norm2 = norm2;
    exports.weightedSum = weightedSum;
    exports.scale = scale;

}));
});

var circleintersection = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circleArea = circleArea;
exports.circleCircleIntersection = circleCircleIntersection;
exports.circleOverlap = circleOverlap;
exports.containedInCircles = containedInCircles;
exports.distance = distance;
exports.getCenter = getCenter;
exports.intersectionArea = intersectionArea;
var SMALL = 1e-10;
/** Returns the intersection area of a bunch of circles (where each circle
 is an object having an x,y and radius property) */

function intersectionArea(circles, stats) {
  // get all the intersection points of the circles
  var intersectionPoints = getIntersectionPoints(circles); // filter out points that aren't included in all the circles

  var innerPoints = intersectionPoints.filter(function (p) {
    return containedInCircles(p, circles);
  });
  var arcArea = 0,
      polygonArea = 0,
      arcs = [],
      i; // if we have intersection points that are within all the circles,
  // then figure out the area contained by them

  if (innerPoints.length > 1) {
    // sort the points by angle from the center of the polygon, which lets
    // us just iterate over points to get the edges
    var center = getCenter(innerPoints);

    for (i = 0; i < innerPoints.length; ++i) {
      var p = innerPoints[i];
      p.angle = Math.atan2(p.x - center.x, p.y - center.y);
    }

    innerPoints.sort(function (a, b) {
      return b.angle - a.angle;
    }); // iterate over all points, get arc between the points
    // and update the areas

    var p2 = innerPoints[innerPoints.length - 1];

    for (i = 0; i < innerPoints.length; ++i) {
      var p1 = innerPoints[i]; // polygon area updates easily ...

      polygonArea += (p2.x + p1.x) * (p1.y - p2.y); // updating the arc area is a little more involved

      var midPoint = {
        x: (p1.x + p2.x) / 2,
        y: (p1.y + p2.y) / 2
      },
          arc = null;

      for (var j = 0; j < p1.parentIndex.length; ++j) {
        if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
          // figure out the angle halfway between the two points
          // on the current circle
          var circle = circles[p1.parentIndex[j]],
              a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),
              a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);
          var angleDiff = a2 - a1;

          if (angleDiff < 0) {
            angleDiff += 2 * Math.PI;
          } // and use that angle to figure out the width of the
          // arc


          var a = a2 - angleDiff / 2,
              width = distance(midPoint, {
            x: circle.x + circle.radius * Math.sin(a),
            y: circle.y + circle.radius * Math.cos(a)
          }); // clamp the width to the largest is can actually be
          // (sometimes slightly overflows because of FP errors)

          if (width > circle.radius * 2) {
            width = circle.radius * 2;
          } // pick the circle whose arc has the smallest width


          if (arc === null || arc.width > width) {
            arc = {
              circle: circle,
              width: width,
              p1: p1,
              p2: p2
            };
          }
        }
      }

      if (arc !== null) {
        arcs.push(arc);
        arcArea += circleArea(arc.circle.radius, arc.width);
        p2 = p1;
      }
    }
  } else {
    // no intersection points, is either disjoint - or is completely
    // overlapped. figure out which by examining the smallest circle
    var smallest = circles[0];

    for (i = 1; i < circles.length; ++i) {
      if (circles[i].radius < smallest.radius) {
        smallest = circles[i];
      }
    } // make sure the smallest circle is completely contained in all
    // the other circles


    var disjoint = false;

    for (i = 0; i < circles.length; ++i) {
      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
        disjoint = true;
        break;
      }
    }

    if (disjoint) {
      arcArea = polygonArea = 0;
    } else {
      arcArea = smallest.radius * smallest.radius * Math.PI;
      arcs.push({
        circle: smallest,
        p1: {
          x: smallest.x,
          y: smallest.y + smallest.radius
        },
        p2: {
          x: smallest.x - SMALL,
          y: smallest.y + smallest.radius
        },
        width: smallest.radius * 2
      });
    }
  }

  polygonArea /= 2;

  if (stats) {
    stats.area = arcArea + polygonArea;
    stats.arcArea = arcArea;
    stats.polygonArea = polygonArea;
    stats.arcs = arcs;
    stats.innerPoints = innerPoints;
    stats.intersectionPoints = intersectionPoints;
  }

  return arcArea + polygonArea;
}
/** returns whether a point is contained by all of a list of circles */


function containedInCircles(point, circles) {
  for (var i = 0; i < circles.length; ++i) {
    if (distance(point, circles[i]) > circles[i].radius + SMALL) {
      return false;
    }
  }

  return true;
}
/** Gets all intersection points between a bunch of circles */


function getIntersectionPoints(circles) {
  var ret = [];

  for (var i = 0; i < circles.length; ++i) {
    for (var j = i + 1; j < circles.length; ++j) {
      var intersect = circleCircleIntersection(circles[i], circles[j]);

      for (var k = 0; k < intersect.length; ++k) {
        var p = intersect[k];
        p.parentIndex = [i, j];
        ret.push(p);
      }
    }
  }

  return ret;
}
/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */


function circleArea(r, width) {
  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
}
/** euclidean distance between two points */


function distance(p1, p2) {
  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
/** Returns the overlap area of two circles of radius r1 and r2 - that
have their centers separated by distance d. Simpler faster
circle intersection for only two circles */


function circleOverlap(r1, r2, d) {
  // no overlap
  if (d >= r1 + r2) {
    return 0;
  } // completely overlapped


  if (d <= Math.abs(r1 - r2)) {
    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
  }

  var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),
      w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
  return circleArea(r1, w1) + circleArea(r2, w2);
}
/** Given two circles (containing a x/y/radius attributes),
returns the intersecting points if possible.
note: doesn't handle cases where there are infinitely many
intersection points (circles are equivalent):, or only one intersection point*/


function circleCircleIntersection(p1, p2) {
  var d = distance(p1, p2),
      r1 = p1.radius,
      r2 = p2.radius; // if to far away, or self contained - can't be done

  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {
    return [];
  }

  var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),
      h = Math.sqrt(r1 * r1 - a * a),
      x0 = p1.x + a * (p2.x - p1.x) / d,
      y0 = p1.y + a * (p2.y - p1.y) / d,
      rx = -(p2.y - p1.y) * (h / d),
      ry = -(p2.x - p1.x) * (h / d);
  return [{
    x: x0 + rx,
    y: y0 - ry
  }, {
    x: x0 - rx,
    y: y0 + ry
  }];
}
/** Returns the center of a bunch of points */


function getCenter(points) {
  var center = {
    x: 0,
    y: 0
  };

  for (var i = 0; i < points.length; ++i) {
    center.x += points[i].x;
    center.y += points[i].y;
  }

  center.x /= points.length;
  center.y /= points.length;
  return center;
}
});

unwrapExports(circleintersection);
var circleintersection_1 = circleintersection.circleArea;
var circleintersection_2 = circleintersection.circleCircleIntersection;
var circleintersection_3 = circleintersection.circleOverlap;
var circleintersection_4 = circleintersection.containedInCircles;
var circleintersection_5 = circleintersection.distance;
var circleintersection_6 = circleintersection.getCenter;
var circleintersection_7 = circleintersection.intersectionArea;

var layout = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bestInitialLayout = bestInitialLayout;
exports.constrainedMDSLayout = constrainedMDSLayout;
exports.disjointCluster = disjointCluster;
exports.distanceFromIntersectArea = distanceFromIntersectArea;
exports.getDistanceMatrices = getDistanceMatrices;
exports.greedyLayout = greedyLayout;
exports.lossFunction = lossFunction;
exports.normalizeSolution = normalizeSolution;
exports.scaleSolution = scaleSolution;
exports.venn = venn;





//算法来源 https://www.benfrederickson.com/venn-diagrams-with-d3.js/

/** given a list of set objects, and their corresponding overlaps.
updates the (x, y, radius) attribute on each set such that their positions
roughly correspond to the desired overlaps */
function venn(areas, parameters) {
  parameters = parameters || {};
  parameters.maxIterations = parameters.maxIterations || 500;
  var initialLayout = parameters.initialLayout || bestInitialLayout;
  var loss = parameters.lossFunction || lossFunction; // add in missing pairwise areas as having 0 size

  areas = addMissingAreas(areas); // initial layout is done greedily

  var circles = initialLayout(areas, parameters); // transform x/y coordinates to a vector to optimize

  var initial = [],
      setids = [],
      setid;

  for (setid in circles) {
    if (circles.hasOwnProperty(setid)) {
      initial.push(circles[setid].x);
      initial.push(circles[setid].y);
      setids.push(setid);
    }
  } // optimize initial layout from our loss function
  var solution = (0, fmin.nelderMead)(function (values) {
    var current = {};

    for (var i = 0; i < setids.length; ++i) {
      var setid = setids[i];
      current[setid] = {
        x: values[2 * i],
        y: values[2 * i + 1],
        radius: circles[setid].radius // size : circles[setid].size

      };
    }

    return loss(current, areas);
  }, initial, parameters); // transform solution vector back to x/y points

  var positions = solution.x;

  for (var i = 0; i < setids.length; ++i) {
    setid = setids[i];
    circles[setid].x = positions[2 * i];
    circles[setid].y = positions[2 * i + 1];
  }

  return circles;
}

var SMALL = 1e-10;
/** Returns the distance necessary for two circles of radius r1 + r2 to
have the overlap area 'overlap' */

function distanceFromIntersectArea(r1, r2, overlap) {
  // handle complete overlapped circles
  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL) {
    return Math.abs(r1 - r2);
  }

  return (0, fmin.bisect)(function (distance) {
    return (0, circleintersection.circleOverlap)(r1, r2, distance) - overlap;
  }, 0, r1 + r2);
}
/** Missing pair-wise intersection area data can cause problems:
 treating as an unknown means that sets will be laid out overlapping,
 which isn't what people expect. To reflect that we want disjoint sets
 here, set the overlap to 0 for all missing pairwise set intersections */


function addMissingAreas(areas) {
  areas = areas.slice(); // two circle intersections that aren't defined

  var ids = [],
      pairs = {},
      i,
      j,
      a,
      b;

  for (i = 0; i < areas.length; ++i) {
    var area = areas[i];

    if (area.sets.length == 1) {
      ids.push(area.sets[0]);
    } else if (area.sets.length == 2) {
      a = area.sets[0];
      b = area.sets[1];
      pairs[[a, b]] = true;
      pairs[[b, a]] = true;
    }
  }

  ids.sort(function (a, b) {
    return a > b;
  });

  for (i = 0; i < ids.length; ++i) {
    a = ids[i];

    for (j = i + 1; j < ids.length; ++j) {
      b = ids[j];

      if (!([a, b] in pairs)) {
        areas.push({
          'sets': [a, b],
          'size': 0
        });
      }
    }
  }

  return areas;
} /// Returns two matrices, one of the euclidean distances between the sets
/// and the other indicating if there are subset or disjoint set relationships


function getDistanceMatrices(areas, sets, setids) {
  // initialize an empty distance matrix between all the points
  var distances = (0, fmin.zerosM)(sets.length, sets.length),
      constraints = (0, fmin.zerosM)(sets.length, sets.length); // compute required distances between all the sets such that
  // the areas match

  areas.filter(function (x) {
    return x.sets.length == 2;
  }).map(function (current) {
    var left = setids[current.sets[0]],
        right = setids[current.sets[1]],
        r1 = Math.sqrt(sets[left].size / Math.PI),
        r2 = Math.sqrt(sets[right].size / Math.PI),
        distance = distanceFromIntersectArea(r1, r2, current.size);
    distances[left][right] = distances[right][left] = distance; // also update constraints to indicate if its a subset or disjoint
    // relationship

    var c = 0;

    if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {
      c = 1;
    } else if (current.size <= 1e-10) {
      c = -1;
    }

    constraints[left][right] = constraints[right][left] = c;
  });
  return {
    distances: distances,
    constraints: constraints
  };
} /// computes the gradient and loss simulatenously for our constrained MDS optimizer


function constrainedMDSGradient(x, fxprime, distances, constraints) {
  var loss = 0,
      i;

  for (i = 0; i < fxprime.length; ++i) {
    fxprime[i] = 0;
  }

  for (i = 0; i < distances.length; ++i) {
    var xi = x[2 * i],
        yi = x[2 * i + 1];

    for (var j = i + 1; j < distances.length; ++j) {
      var xj = x[2 * j],
          yj = x[2 * j + 1],
          dij = distances[i][j],
          constraint = constraints[i][j];
      var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),
          distance = Math.sqrt(squaredDistance),
          delta = squaredDistance - dij * dij;

      if (constraint > 0 && distance <= dij || constraint < 0 && distance >= dij) {
        continue;
      }

      loss += 2 * delta * delta;
      fxprime[2 * i] += 4 * delta * (xi - xj);
      fxprime[2 * i + 1] += 4 * delta * (yi - yj);
      fxprime[2 * j] += 4 * delta * (xj - xi);
      fxprime[2 * j + 1] += 4 * delta * (yj - yi);
    }
  }

  return loss;
} /// takes the best working variant of either constrained MDS or greedy


function bestInitialLayout(areas, params) {
  var initial = greedyLayout(areas, params);
  var loss = params.lossFunction || lossFunction; // greedylayout is sufficient for all 2/3 circle cases. try out
  // constrained MDS for higher order problems, take its output
  // if it outperforms. (greedy is aesthetically better on 2/3 circles
  // since it axis aligns)

  if (areas.length >= 8) {
    var constrained = constrainedMDSLayout(areas, params),
        constrainedLoss = loss(constrained, areas),
        greedyLoss = loss(initial, areas);

    if (constrainedLoss + 1e-8 < greedyLoss) {
      initial = constrained;
    }
  }

  return initial;
} /// use the constrained MDS variant to generate an initial layout


function constrainedMDSLayout(areas, params) {
  params = params || {};
  var restarts = params.restarts || 10; // bidirectionally map sets to a rowid  (so we can create a matrix)

  var sets = [],
      setids = {},
      i;

  for (i = 0; i < areas.length; ++i) {
    var area = areas[i];

    if (area.sets.length == 1) {
      setids[area.sets[0]] = sets.length;
      sets.push(area);
    }
  }

  var matrices = getDistanceMatrices(areas, sets, setids),
      distances = matrices.distances,
      constraints = matrices.constraints; // keep distances bounded, things get messed up otherwise.
  // TODO: proper preconditioner?

  var norm = (0, fmin.norm2)(distances.map(fmin.norm2)) / distances.length;
  distances = distances.map(function (row) {
    return row.map(function (value) {
      return value / norm;
    });
  });

  var obj = function obj(x, fxprime) {
    return constrainedMDSGradient(x, fxprime, distances, constraints);
  };

  var best, current;

  for (i = 0; i < restarts; ++i) {
    var initial = (0, fmin.zeros)(distances.length * 2).map(Math.random);
    current = (0, fmin.conjugateGradient)(obj, initial, params);

    if (!best || current.fx < best.fx) {
      best = current;
    }
  }

  var positions = best.x; // translate rows back to (x,y,radius) coordinates

  var circles = {};

  for (i = 0; i < sets.length; ++i) {
    var set = sets[i];
    circles[set.sets[0]] = {
      x: positions[2 * i] * norm,
      y: positions[2 * i + 1] * norm,
      radius: Math.sqrt(set.size / Math.PI)
    };
  }

  if (params.history) {
    for (i = 0; i < params.history.length; ++i) {
      (0, fmin.scale)(params.history[i].x, norm);
    }
  }

  return circles;
}
/** Lays out a Venn diagram greedily, going from most overlapped sets to
least overlapped, attempting to position each new set such that the
overlapping areas to already positioned sets are basically right */


function greedyLayout(areas, params) {
  var loss = params && params.lossFunction ? params.lossFunction : lossFunction; // define a circle for each set

  var circles = {},
      setOverlaps = {},
      set;

  for (var i = 0; i < areas.length; ++i) {
    var area = areas[i];

    if (area.sets.length == 1) {
      set = area.sets[0];
      circles[set] = {
        x: 1e10,
        y: 1e10,
        rowid: circles.length,
        size: area.size,
        radius: Math.sqrt(area.size / Math.PI)
      };
      setOverlaps[set] = [];
    }
  }

  areas = areas.filter(function (a) {
    return a.sets.length == 2;
  }); // map each set to a list of all the other sets that overlap it

  for (i = 0; i < areas.length; ++i) {
    var current = areas[i];
    var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;
    var left = current.sets[0],
        right = current.sets[1]; // completely overlapped circles shouldn't be positioned early here

    if (current.size + SMALL >= Math.min(circles[left].size, circles[right].size)) {
      weight = 0;
    }

    setOverlaps[left].push({
      set: right,
      size: current.size,
      weight: weight
    });
    setOverlaps[right].push({
      set: left,
      size: current.size,
      weight: weight
    });
  } // get list of most overlapped sets


  var mostOverlapped = [];

  for (set in setOverlaps) {
    if (setOverlaps.hasOwnProperty(set)) {
      var size = 0;

      for (i = 0; i < setOverlaps[set].length; ++i) {
        size += setOverlaps[set][i].size * setOverlaps[set][i].weight;
      }

      mostOverlapped.push({
        set: set,
        size: size
      });
    }
  } // sort by size desc


  function sortOrder(a, b) {
    return b.size - a.size;
  }

  mostOverlapped.sort(sortOrder); // keep track of what sets have been laid out

  var positioned = {};

  function isPositioned(element) {
    return element.set in positioned;
  } // adds a point to the output


  function positionSet(point, index) {
    circles[index].x = point.x;
    circles[index].y = point.y;
    positioned[index] = true;
  } // add most overlapped set at (0,0)


  positionSet({
    x: 0,
    y: 0
  }, mostOverlapped[0].set); // get distances between all points. TODO, necessary?
  // answer: probably not
  // var distances = venn.getDistanceMatrices(circles, areas).distances;

  for (i = 1; i < mostOverlapped.length; ++i) {
    var setIndex = mostOverlapped[i].set,
        overlap = setOverlaps[setIndex].filter(isPositioned);
    set = circles[setIndex];
    overlap.sort(sortOrder);

    if (overlap.length === 0) {
      // this shouldn't happen anymore with addMissingAreas
      throw "ERROR: missing pairwise overlap information";
    }

    var points = [];

    for (var j = 0; j < overlap.length; ++j) {
      // get appropriate distance from most overlapped already added set
      var p1 = circles[overlap[j].set],
          d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size); // sample positions at 90 degrees for maximum aesthetics

      points.push({
        x: p1.x + d1,
        y: p1.y
      });
      points.push({
        x: p1.x - d1,
        y: p1.y
      });
      points.push({
        y: p1.y + d1,
        x: p1.x
      });
      points.push({
        y: p1.y - d1,
        x: p1.x
      }); // if we have at least 2 overlaps, then figure out where the
      // set should be positioned analytically and try those too

      for (var k = j + 1; k < overlap.length; ++k) {
        var p2 = circles[overlap[k].set],
            d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);
        var extraPoints = (0, circleintersection.circleCircleIntersection)({
          x: p1.x,
          y: p1.y,
          radius: d1
        }, {
          x: p2.x,
          y: p2.y,
          radius: d2
        });

        for (var l = 0; l < extraPoints.length; ++l) {
          points.push(extraPoints[l]);
        }
      }
    } // we have some candidate positions for the set, examine loss
    // at each position to figure out where to put it at


    var bestLoss = 1e50,
        bestPoint = points[0];

    for (j = 0; j < points.length; ++j) {
      circles[setIndex].x = points[j].x;
      circles[setIndex].y = points[j].y;
      var localLoss = loss(circles, areas);

      if (localLoss < bestLoss) {
        bestLoss = localLoss;
        bestPoint = points[j];
      }
    }

    positionSet(bestPoint, setIndex);
  }

  return circles;
}
/** Given a bunch of sets, and the desired overlaps between these sets - computes
the distance from the actual overlaps to the desired overlaps. Note that
this method ignores overlaps of more than 2 circles */


function lossFunction(sets, overlaps) {
  var output = 0;

  function getCircles(indices) {
    return indices.map(function (i) {
      return sets[i];
    });
  }

  for (var i = 0; i < overlaps.length; ++i) {
    var area = overlaps[i],
        overlap;

    if (area.sets.length == 1) {
      continue;
    } else if (area.sets.length == 2) {
      var left = sets[area.sets[0]],
          right = sets[area.sets[1]];
      overlap = (0, circleintersection.circleOverlap)(left.radius, right.radius, (0, circleintersection.distance)(left, right));
    } else {
      overlap = (0, circleintersection.intersectionArea)(getCircles(area.sets));
    }

    var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;
    output += weight * (overlap - area.size) * (overlap - area.size);
  }

  return output;
} // orientates a bunch of circles to point in orientation


function orientateCircles(circles, orientation, orientationOrder) {
  if (orientationOrder === null) {
    circles.sort(function (a, b) {
      return b.radius - a.radius;
    });
  } else {
    circles.sort(orientationOrder);
  }

  var i; // shift circles so largest circle is at (0, 0)

  if (circles.length > 0) {
    var largestX = circles[0].x,
        largestY = circles[0].y;

    for (i = 0; i < circles.length; ++i) {
      circles[i].x -= largestX;
      circles[i].y -= largestY;
    }
  }

  if (circles.length == 2) {
    // if the second circle is a subset of the first, arrange so that
    // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120
    var dist = (0, circleintersection.distance)(circles[0], circles[1]);

    if (dist < Math.abs(circles[1].radius - circles[0].radius)) {
      circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;
      circles[1].y = circles[0].y;
    }
  } // rotate circles so that second largest is at an angle of 'orientation'
  // from largest


  if (circles.length > 1) {
    var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation,
        c = Math.cos(rotation),
        s = Math.sin(rotation),
        x,
        y;

    for (i = 0; i < circles.length; ++i) {
      x = circles[i].x;
      y = circles[i].y;
      circles[i].x = c * x - s * y;
      circles[i].y = s * x + c * y;
    }
  } // mirror solution if third solution is above plane specified by
  // first two circles


  if (circles.length > 2) {
    var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;

    while (angle < 0) {
      angle += 2 * Math.PI;
    }

    while (angle > 2 * Math.PI) {
      angle -= 2 * Math.PI;
    }

    if (angle > Math.PI) {
      var slope = circles[1].y / (1e-10 + circles[1].x);

      for (i = 0; i < circles.length; ++i) {
        var d = (circles[i].x + slope * circles[i].y) / (1 + slope * slope);
        circles[i].x = 2 * d - circles[i].x;
        circles[i].y = 2 * d * slope - circles[i].y;
      }
    }
  }
}

function disjointCluster(circles) {
  // union-find clustering to get disjoint sets
  circles.map(function (circle) {
    circle.parent = circle;
  }); // path compression step in union find

  function find(circle) {
    if (circle.parent !== circle) {
      circle.parent = find(circle.parent);
    }

    return circle.parent;
  }

  function union(x, y) {
    var xRoot = find(x),
        yRoot = find(y);
    xRoot.parent = yRoot;
  } // get the union of all overlapping sets


  for (var i = 0; i < circles.length; ++i) {
    for (var j = i + 1; j < circles.length; ++j) {
      var maxDistance = circles[i].radius + circles[j].radius;

      if ((0, circleintersection.distance)(circles[i], circles[j]) + 1e-10 < maxDistance) {
        union(circles[j], circles[i]);
      }
    }
  } // find all the disjoint clusters and group them together


  var disjointClusters = {},
      setid;

  for (i = 0; i < circles.length; ++i) {
    setid = find(circles[i]).parent.setid;

    if (!(setid in disjointClusters)) {
      disjointClusters[setid] = [];
    }

    disjointClusters[setid].push(circles[i]);
  } // cleanup bookkeeping


  circles.map(function (circle) {
    delete circle.parent;
  }); // return in more usable form

  var ret = [];

  for (setid in disjointClusters) {
    if (disjointClusters.hasOwnProperty(setid)) {
      ret.push(disjointClusters[setid]);
    }
  }

  return ret;
}

function getBoundingBox(circles) {
  var minMax = function minMax(d) {
    var hi = Math.max.apply(null, circles.map(function (c) {
      return c[d] + c.radius;
    })),
        lo = Math.min.apply(null, circles.map(function (c) {
      return c[d] - c.radius;
    }));
    return {
      max: hi,
      min: lo
    };
  };

  return {
    xRange: minMax('x'),
    yRange: minMax('y')
  };
}

function normalizeSolution(solution, orientation, orientationOrder) {
  if (orientation === null) {
    orientation = Math.PI / 2;
  } // work with a list instead of a dictionary, and take a copy so we
  // don't mutate input


  var circles = [],
      i,
      setid;

  for (setid in solution) {
    if (solution.hasOwnProperty(setid)) {
      var previous = solution[setid];
      circles.push({
        x: previous.x,
        y: previous.y,
        radius: previous.radius,
        setid: setid
      });
    }
  } // get all the disjoint clusters


  var clusters = disjointCluster(circles); // orientate all disjoint sets, get sizes

  for (i = 0; i < clusters.length; ++i) {
    orientateCircles(clusters[i], orientation, orientationOrder);
    var bounds = getBoundingBox(clusters[i]);
    clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);
    clusters[i].bounds = bounds;
  }

  clusters.sort(function (a, b) {
    return b.size - a.size;
  }); // orientate the largest at 0,0, and get the bounds

  circles = clusters[0];
  var returnBounds = circles.bounds;
  var spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;

  function addCluster(cluster, right, bottom) {
    if (!cluster) return;
    var bounds = cluster.bounds,
        xOffset,
        yOffset,
        centreing;

    if (right) {
      xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;
    } else {
      xOffset = returnBounds.xRange.max - bounds.xRange.max;
      centreing = (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;
      if (centreing < 0) xOffset += centreing;
    }

    if (bottom) {
      yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;
    } else {
      yOffset = returnBounds.yRange.max - bounds.yRange.max;
      centreing = (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;
      if (centreing < 0) yOffset += centreing;
    }

    for (var j = 0; j < cluster.length; ++j) {
      cluster[j].x += xOffset;
      cluster[j].y += yOffset;
      circles.push(cluster[j]);
    }
  }

  var index = 1;

  while (index < clusters.length) {
    addCluster(clusters[index], true, false);
    addCluster(clusters[index + 1], false, true);
    addCluster(clusters[index + 2], true, true);
    index += 3; // have one cluster (in top left). lay out next three relative
    // to it in a grid

    returnBounds = getBoundingBox(circles);
  } // convert back to solution form


  var ret = {};

  for (i = 0; i < circles.length; ++i) {
    ret[circles[i].setid] = circles[i];
  }

  return ret;
}
/** Scales a solution from venn.venn or venn.greedyLayout such that it fits in
a rectangle of width/height - with padding around the borders. also
centers the diagram in the available space at the same time */


function scaleSolution(solution, width, height, padding) {
  var circles = [],
      setids = [];

  for (var setid in solution) {
    if (solution.hasOwnProperty(setid)) {
      setids.push(setid);
      circles.push(solution[setid]);
    }
  }

  width -= 2 * padding;
  height -= 2 * padding;
  var bounds = getBoundingBox(circles),
      xRange = bounds.xRange,
      yRange = bounds.yRange;

  if (xRange.max == xRange.min || yRange.max == yRange.min) {
    return solution;
  }

  var xScaling = width / (xRange.max - xRange.min),
      yScaling = height / (yRange.max - yRange.min),
      scaling = Math.min(yScaling, xScaling),
      // while we're at it, center the diagram too
  xOffset = (width - (xRange.max - xRange.min) * scaling) / 2,
      yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
  var scaled = {};

  for (var i = 0; i < circles.length; ++i) {
    var circle = circles[i];
    scaled[setids[i]] = {
      radius: scaling * circle.radius,
      x: padding + xOffset + (circle.x - xRange.min) * scaling,
      y: padding + yOffset + (circle.y - yRange.min) * scaling
    };
  }

  return scaled;
}
});

unwrapExports(layout);
var layout_1 = layout.bestInitialLayout;
var layout_2 = layout.constrainedMDSLayout;
var layout_3 = layout.disjointCluster;
var layout_4 = layout.distanceFromIntersectArea;
var layout_5 = layout.getDistanceMatrices;
var layout_6 = layout.greedyLayout;
var layout_7 = layout.lossFunction;
var layout_8 = layout.normalizeSolution;
var layout_9 = layout.scaleSolution;
var layout_10 = layout.venn;

var venn = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(graphs);









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Text = _canvax["default"].Display.Text;
var Path = _canvax["default"].Shapes.Path;
var Circle = _canvax["default"].Shapes.Circle;

var VennGraphs = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(VennGraphs, _GraphsBase);

  var _super = _createSuper(VennGraphs);

  function VennGraphs(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, VennGraphs);
    _this = _super.call(this, opt, app);
    _this.type = "venn";
    _this.vennData = null;

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(VennGraphs.defaultProps()), opt); //_trimGraphs后，计算出来本次data的一些属性


    _this._dataCircleLen = 0;
    _this._dataLabelLen = 0;
    _this._dataPathLen = 0;

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(VennGraphs, [{
    key: "init",
    value: function init() {
      this.venn_circles = new _canvax["default"].Display.Sprite({
        id: "venn_circles"
      });
      this.sprite.addChild(this.venn_circles);
      this.venn_paths = new _canvax["default"].Display.Sprite({
        id: "venn_paths"
      });
      this.sprite.addChild(this.venn_paths);
      this.venn_labels = new _canvax["default"].Display.Sprite({
        id: "venn_labels"
      });
      this.sprite.addChild(this.venn_labels);
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {});

      _.extend(true, this, opt);

      this.data = this._trimGraphs();

      this._widget();

      this.sprite.context.x = this.app.padding.left;
      this.sprite.context.y = this.app.padding.top;
      this.fire("complete");
    }
  }, {
    key: "resetData",
    value: function resetData(dataFrame) {
      this.dataFrame = dataFrame;
      this.data = this._trimGraphs();

      this._widget();
    }
  }, {
    key: "_trimGraphs",
    value: function _trimGraphs() {
      var me = this;

      var data = me._vennData();

      var layoutFunction = layout.venn;
      var loss = layout.lossFunction;
      var orientation = Math.PI / 2;
      var orientationOrder = null;
      var circles = {};
      var textCentres = {};
      this._dataCircleLen = 0;
      this._dataLabelLen = 0;
      this._dataPathLen = 0;

      if (data.length > 0) {
        var solution = layoutFunction(data, {
          lossFunction: loss
        });

        {
          solution = (0, layout.normalizeSolution)(solution, orientation, orientationOrder);
        }
        //所以就传0

        circles = (0, layout.scaleSolution)(solution, this.width, this.height, 0);
        textCentres = computeTextCentres(circles, data);
      }
      var circleInd = 0;
      var pathInd = 0;

      _.each(data, function (d) {
        if (d.label) {
          if (d.sets.length > 1 && !me.label.showInter) ; else {
            d.labelPosition = textCentres[d.nodeId];
            me._dataLabelLen++;
          }
        }

        if (d.sets.length > 1) {
          var _path = intersectionAreaPath(d.sets.map(function (set) {
            return circles[set];
          }));

          d.shape = {
            type: 'path',
            path: _path,
            pathInd: pathInd++
          };
          me._dataPathLen++;
        } else if (d.sets.length == 1) {
          d.shape = _.extend({
            type: 'circle',
            circleInd: circleInd++
          }, circles[d.nodeId]);
          me._dataCircleLen++;
        }
      });

      return data;
    }
  }, {
    key: "_vennData",
    value: function _vennData() {
      var data = [];
      var me = this;

      for (var i = 0, l = this.dataFrame.length; i < l; i++) {
        var rowData = me.dataFrame.getRowDataAt(i);
        var obj = {
          type: "venn",
          field: me.field,
          iNode: i,
          nodeId: null,
          rowData: rowData,
          sets: null,
          //size和value是同一个值，size是 vennLayout 需要用到的属性
          //value是 chartx中和其他图表的值属性保持统一，比如tips中就会读取value
          size: null,
          value: null,
          //这两个在绘制的时候赋值
          fillStyle: null,
          strokeStyle: null,
          label: null,
          labelPosition: null
        };

        for (var p in rowData) {
          var val = rowData[p];

          if (p == me.keyField) {
            if (_.isString(val)) {
              val = val.split(/[,|]/);
            }
            obj.sets = val;
            obj.nodeId = val.join();

            if (!me.label.field) {
              //如果没有设置label的field
              //那么就默认获取keyField
              obj.label = val.join();
            }
          }

          if (p == me.field) {
            obj.size = val;
            obj.value = val;
          }

          if (p == me.label.field) {
            obj.label = val;
          }
        }

        data.push(obj);
      }
      return data;
    }
  }, {
    key: "_getStyle",
    value: function _getStyle(style, ind, nodeData, defColor) {
      var color;

      if (_.isString(style)) {
        color = style;
      }

      if (_.isFunction(style)) {
        color = style(nodeData);
      }

      if (!color && ind != undefined) {
        color = this.app.getTheme(ind);
      }

      if (!color && defColor != undefined) {
        color = defColor;
      }

      return color;
    }
  }, {
    key: "_widget",
    value: function _widget() {
      var me = this; //那么有多余的元素要去除掉 begin

      if (me.venn_circles.children.length > me._dataCircleLen) {
        for (var i = me._dataCircleLen; i < me.venn_circles.children.length; i++) {
          me.venn_circles.getChildAt(i--).destroy();
        }
      }

      if (me.venn_paths.children.length > me._dataPathLen) {
        for (var _i = me._dataPathLen; _i < me.venn_paths.children.length; _i++) {
          me.venn_paths.getChildAt(_i--).destroy();
        }
      }

      if (me.venn_labels.children.length > me._dataLabelLen) {
        for (var _i2 = me._dataLabelLen; _i2 < me.venn_labels.children.length; _i2++) {
          me.venn_labels.getChildAt(_i2--).destroy();
        }
      }

      var circleInd = 0;
      var pathInd = 0;
      var labelInd = 0;

      _.each(this.data, function (nodeData) {
        var shape = nodeData.shape;

        var _shape;

        var isNewShape = true;

        if (shape) {
          var context;

          if (shape.type == 'circle') {
            var fillStyle = me._getStyle(me.node.fillStyle, shape.circleInd, nodeData);

            var strokeStyle = me._getStyle(me.node.strokeStyle, shape.circleInd, nodeData);

            nodeData.fillStyle = fillStyle;
            nodeData.strokeStyle = strokeStyle;
            context = {
              x: shape.x,
              y: shape.y,
              r: shape.radius,
              fillStyle: fillStyle,
              fillAlpha: me.node.fillAlpha,
              lineWidth: me.node.lineWidth,
              strokeStyle: strokeStyle,
              strokeAlpha: me.node.strokeAlpha
            };
            _shape = me.venn_circles.getChildAt(circleInd++);

            if (!_shape) {
              _shape = new Circle({
                pointChkPriority: false,
                hoverClone: false,
                context: context
              });
              me.venn_circles.addChild(_shape);
            } else {
              isNewShape = false;

              _shape.animate(context);
            }
          }

          if (nodeData.shape.type == 'path') {
            context = {
              path: shape.path,
              fillStyle: "#ffffff",
              fillAlpha: 0,
              //me.node.fillAlpha,
              lineWidth: me.node.lineWidth,
              strokeStyle: "#ffffff",
              strokeAlpha: 0 //me.node.strokeAlpha

            };
            _shape = me.venn_paths.getChildAt(pathInd++);

            if (!_shape) {
              _shape = new Path({
                pointChkPriority: false,
                context: context
              });
              me.venn_paths.addChild(_shape);
            } else {
              isNewShape = false;
              _shape.context.path = shape.path; //_shape.animate( context )
            }
          }
          _shape.nodeData = nodeData;
          nodeData._node = _shape;
          me.node.focus.enabled && _shape.hover(function () {
            me.focusAt(this.nodeData.iNode);
          }, function () {
            !this.nodeData.selected && me.unfocusAt(this.nodeData.iNode);
          }); //新创建的元素才需要绑定事件，因为复用的原件已经绑定过事件了

          if (isNewShape) {
            _shape.on(event.types.get(), function (e) {
              e.eventInfo = {
                trigger: 'this.node',
                //me.node,
                title: null,
                nodes: [this.nodeData]
              }; //fire到root上面去的是为了让root去处理tips

              me.app.fire(e.type, e);
            });
          }
        }

        if (nodeData.label && me.label.enabled) {
          var fontColor = me._getStyle(me.label.fontColor, shape.circleInd, nodeData, "#999");

          var fontSize = me.label.fontSize;

          if (nodeData.sets.length > 1) {
            if (!me.label.showInter) {
              fontSize = 0;
            } else {
              fontSize -= 2;
            }
          }

          if (fontSize) {
            var _textContext = {
              x: nodeData.labelPosition.x,
              y: nodeData.labelPosition.y,
              fontSize: fontSize,
              //fontFamily: me.label.fontFamily,
              textBaseline: "middle",
              textAlign: "center",
              fontWeight: me.label.fontWeight,
              fillStyle: fontColor
            };

            var _txt = me.venn_labels.getChildAt(labelInd++);

            if (!_txt) {
              _txt = new Text(nodeData.label, {
                context: _textContext
              });
              me.venn_labels.addChild(_txt);
            } else {
              _txt.resetText(nodeData.label);

              _txt.animate(_textContext);
            }
          }
        }
      });
    }
  }, {
    key: "focusAt",
    value: function focusAt(ind) {
      var nodeData = this.data[ind];
      if (!this.node.focus.enabled || nodeData.focused) return;
      var nctx = nodeData._node.context; //nctx.strokeAlpha += 0.5;

      if (nodeData.sets.length > 1) {
        //path
        nctx.strokeAlpha = 1;
      } else {
        //circle
        nctx.strokeAlpha = this.node.focus.strokeAlpha;
      }

      nodeData.focused = true;
    }
  }, {
    key: "unfocusAt",
    value: function unfocusAt(ind) {
      var nodeData = this.data[ind];
      if (!this.node.focus.enabled || !nodeData.focused) return;
      var nctx = nodeData._node.context; //nctx.strokeAlpha = 0.5;

      nctx.strokeAlpha = this.node.strokeAlpha;
      nodeData.focused = false;
    }
  }, {
    key: "selectAt",
    value: function selectAt(ind) {
      var nodeData = this.data[ind];
      if (!this.node.select.enabled || nodeData.selected) return;
      var nctx = nodeData._node.context;
      nctx.lineWidth = this.node.select.lineWidth;
      nctx.strokeAlpha = this.node.select.strokeAlpha;
      nctx.strokeStyle = this.node.select.strokeStyle;
      nodeData.selected = true;
    }
  }, {
    key: "unselectAt",
    value: function unselectAt(ind) {
      var nodeData = this.data[ind];
      if (!this.node.select.enabled || !nodeData.selected) return;
      var nctx = nodeData._node.context;
      nctx.strokeStyle = this.node.strokeStyle;
      nodeData.selected = false;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: 'value字段',
          "default": 'value'
        },
        keyField: {
          detail: 'key字段',
          "default": 'name'
        },
        node: {
          detail: '单个节点配置',
          propertys: {
            strokeStyle: {
              detail: '边框颜色',
              "default": null
            },
            lineWidth: {
              detail: '边框大小',
              "default": 2
            },
            strokeAlpha: {
              detail: '边框透明度',
              "default": 0
            },
            fillStyle: {
              detail: '背景色',
              "default": null
            },
            fillAlpha: {
              detail: '背景透明度',
              "default": 0.25
            },
            focus: {
              detail: 'hover设置',
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": true
                },
                strokeAlpha: {
                  detail: '边框透明度',
                  "default": 0.3
                }
              }
            },
            select: {
              detail: '选中设置',
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": true
                },
                lineWidth: {
                  detail: '描边宽度',
                  "default": 2
                },
                strokeStyle: {
                  detail: '描边颜色',
                  "default": '#666666'
                }
              }
            }
          }
        },
        label: {
          detail: '文本设置',
          propertys: {
            field: {
              detail: '获取文本的字段',
              "default": null
            },
            fontSize: {
              detail: '字体大小',
              "default": 14
            },
            fontColor: {
              detail: '文本颜色',
              "default": null
            },
            fontWeight: {
              detail: 'fontWeight',
              "default": 'normal'
            },
            showInter: {
              detail: '是否显示相交部分的文本',
              "default": true
            }
          }
        }
      };
    }
  }, {
    key: "polyfill",
    value: function polyfill(opt) {
      if (opt.valueField) {
        //20220304 所有的graph都统一一个field
        opt.field = opt.valueField;
        delete opt.valueField;
      }

      return opt;
    }
  }]);
  return VennGraphs;
}(_index["default"]); //venn computeTextCentres 需要的相关代码 begin


function getOverlappingCircles(circles) {
  var ret = {},
      circleids = [];

  for (var circleid in circles) {
    circleids.push(circleid);
    ret[circleid] = [];
  }

  for (var i = 0; i < circleids.length; i++) {
    var a = circles[circleids[i]];

    for (var j = i + 1; j < circleids.length; ++j) {
      var b = circles[circleids[j]],
          d = (0, circleintersection.distance)(a, b);

      if (d + b.radius <= a.radius + 1e-10) {
        ret[circleids[j]].push(circleids[i]);
      } else if (d + a.radius <= b.radius + 1e-10) {
        ret[circleids[i]].push(circleids[j]);
      }
    }
  }

  return ret;
}

function computeTextCentres(circles, areas) {
  var ret = {},
      overlapped = getOverlappingCircles(circles);

  for (var i = 0; i < areas.length; ++i) {
    var area = areas[i].sets,
        areaids = {},
        exclude = {};

    for (var j = 0; j < area.length; ++j) {
      areaids[area[j]] = true;
      var overlaps = overlapped[area[j]];

      for (var k = 0; k < overlaps.length; ++k) {
        exclude[overlaps[k]] = true;
      }
    }

    var interior = [],
        exterior = [];

    for (var setid in circles) {
      if (setid in areaids) {
        interior.push(circles[setid]);
      } else if (!(setid in exclude)) {
        exterior.push(circles[setid]);
      }
    }

    var centre = computeTextCentre(interior, exterior);
    ret[area] = centre;

    if (centre.disjoint && areas[i].size > 0) ;
  }

  return ret;
}

function computeTextCentre(interior, exterior) {
  var points = [],
      i;

  for (i = 0; i < interior.length; ++i) {
    var c = interior[i];
    points.push({
      x: c.x,
      y: c.y
    });
    points.push({
      x: c.x + c.radius / 2,
      y: c.y
    });
    points.push({
      x: c.x - c.radius / 2,
      y: c.y
    });
    points.push({
      x: c.x,
      y: c.y + c.radius / 2
    });
    points.push({
      x: c.x,
      y: c.y - c.radius / 2
    });
  }

  var initial = points[0],
      margin = circleMargin(points[0], interior, exterior);

  for (i = 1; i < points.length; ++i) {
    var m = circleMargin(points[i], interior, exterior);

    if (m >= margin) {
      initial = points[i];
      margin = m;
    }
  } // maximize the margin numerically


  var solution = (0, fmin.nelderMead)(function (p) {
    return -1 * circleMargin({
      x: p[0],
      y: p[1]
    }, interior, exterior);
  }, [initial.x, initial.y], {
    maxIterations: 500,
    minErrorDelta: 1e-10
  }).x;
  var ret = {
    x: solution[0],
    y: solution[1]
  }; // check solution, fallback as needed (happens if fully overlapped
  // etc)

  var valid = true;

  for (i = 0; i < interior.length; ++i) {
    if ((0, circleintersection.distance)(ret, interior[i]) > interior[i].radius) {
      valid = false;
      break;
    }
  }

  for (i = 0; i < exterior.length; ++i) {
    if ((0, circleintersection.distance)(ret, exterior[i]) < exterior[i].radius) {
      valid = false;
      break;
    }
  }

  if (!valid) {
    if (interior.length == 1) {
      ret = {
        x: interior[0].x,
        y: interior[0].y
      };
    } else {
      var areaStats = {};
      (0, circleintersection.intersectionArea)(interior, areaStats);

      if (areaStats.arcs.length === 0) {
        ret = {
          'x': 0,
          'y': -1000,
          disjoint: true
        };
      } else if (areaStats.arcs.length == 1) {
        ret = {
          'x': areaStats.arcs[0].circle.x,
          'y': areaStats.arcs[0].circle.y
        };
      } else if (exterior.length) {
        // try again without other circles
        ret = computeTextCentre(interior, []);
      } else {
        // take average of all the points in the intersection
        // polygon. this should basically never happen
        // and has some issues:
        // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777
        ret = (0, circleintersection.getCenter)(areaStats.arcs.map(function (a) {
          return a.p1;
        }));
      }
    }
  }

  return ret;
}

function circleMargin(current, interior, exterior) {
  var margin = interior[0].radius - (0, circleintersection.distance)(interior[0], current),
      i,
      m;

  for (i = 1; i < interior.length; ++i) {
    m = interior[i].radius - (0, circleintersection.distance)(interior[i], current);

    if (m <= margin) {
      margin = m;
    }
  }

  for (i = 0; i < exterior.length; ++i) {
    m = (0, circleintersection.distance)(exterior[i], current) - exterior[i].radius;

    if (m <= margin) {
      margin = m;
    }
  }

  return margin;
}

function circlePath(x, y, r) {
  var ret = [];
  ret.push("\nM", x, y);
  ret.push("\nm", -r, 0);
  ret.push("\na", r, r, 0, 1, 0, r * 2, 0);
  ret.push("\na", r, r, 0, 1, 0, -r * 2, 0);
  return ret.join(" ");
}
/** returns a svg path of the intersection area of a bunch of circles */


function intersectionAreaPath(circles) {
  var stats = {};
  (0, circleintersection.intersectionArea)(circles, stats);
  var arcs = stats.arcs;

  if (arcs.length === 0) {
    return "M 0 0";
  } else if (arcs.length == 1) {
    var circle = arcs[0].circle;
    return circlePath(circle.x, circle.y, circle.radius);
  } else {
    // draw path around arcs
    var ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];

    for (var i = 0; i < arcs.length; ++i) {
      var arc = arcs[i],
          r = arc.circle.radius,
          wide = arc.width > r;
      ret.push("\nA", r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
    }

    return ret.join(" ") + " z";
  }
} //venn computeTextCentres 需要的相关代码 end


_index["default"].registerComponent(VennGraphs, 'graphs', 'venn');

var _default = VennGraphs;
exports["default"] = _default;
});

unwrapExports(venn);

var rebind = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

function _rebind(target, source, method) {
  return function () {
    var value = method.apply(source, arguments);
    return value === source ? target : value;
  };
}

function _default(target, source) {
  var i = 1,
      n = arguments.length,
      method;

  while (++i < n) {
    target[method = arguments[i]] = _rebind(target, source, source[method]);
  }

  return target;
}
});

unwrapExports(rebind);

var arrays = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = {
  merge: function merge(arrays) {
    var n = arrays.length,
        m,
        i = -1,
        j = 0,
        merged,
        array;

    while (++i < n) {
      j += arrays[i].length;
    }

    merged = new Array(j);

    while (--n >= 0) {
      array = arrays[n];
      m = array.length;

      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }

    return merged;
  }
};
exports["default"] = _default;
});

unwrapExports(arrays);

var hierarchy = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _rebind = interopRequireDefault(rebind);

var _arrays = interopRequireDefault(arrays);

/**
 * 修改优化了下面 node._value的代码部分
 * 可以手动给中间节点添加value大于children的value总和的值
 * 这样，就会有流失的效果
 */
var Hierarchy = function Hierarchy() {
  var sort = layout_hierarchySort,
      children = layout_hierarchyChildren,
      value = layout_hierarchyValue;

  function hierarchy(app) {
    var stack = [app],
        nodes = [],
        node;
    app.depth = 0;

    while ((node = stack.pop()) != null) {
      nodes.push(node);

      if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
        var n, childs, child;

        while (--n >= 0) {
          stack.push(child = childs[n]);
          child.parent = node;
          child.depth = node.depth + 1;
        }

        if (value) {
          var _value = +value.call(hierarchy, node, node.depth);

          if (_value && !isNaN(_value)) {
            node._value = _value;
          }
        }
        if (value) node.value = 0;
        node.children = childs;
      } else {
        if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
        delete node.children;
      }
    }

    Hierarchy.layout_hierarchyVisitAfter(app, function (node) {
      var childs, parent;
      if (sort && (childs = node.children)) childs.sort(sort);
      if (value && (parent = node.parent)) parent.value += node.value;

      if (node._value && node._value > node.value) {
        node.value = node._value;
      }
      delete node._value;
    });
    return nodes;
  }

  hierarchy.sort = function (x) {
    if (!arguments.length) return sort;
    sort = x;
    return hierarchy;
  };

  hierarchy.children = function (x) {
    if (!arguments.length) return children;
    children = x;
    return hierarchy;
  };

  hierarchy.value = function (x) {
    if (!arguments.length) return value;
    value = x;
    return hierarchy;
  }; // Re-evaluates the `value` property for the specified hierarchy.


  hierarchy.revalue = function (app) {
    if (value) {
      Hierarchy.layout_hierarchyVisitBefore(app, function (node) {
        if (node.children) node.value = 0;
      });
      Hierarchy.layout_hierarchyVisitAfter(app, function (node) {
        var parent;
        if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
        if (parent = node.parent) parent.value += node.value;

        if (node._value && node._value > node.value) {
          node.value = node._value;
        }
        delete node._value;
      });
    }

    return app;
  };

  return hierarchy;
};

Hierarchy.layout_hierarchyRebind = function (object, hierarchy) {
  (0, _rebind["default"])(object, hierarchy, "sort", "children", "value");
  object.nodes = object;
  object.links = layout_hierarchyLinks;
  return object;
};

Hierarchy.layout_hierarchyVisitBefore = function (node, callback) {
  var nodes = [node];

  while ((node = nodes.pop()) != null) {
    callback(node);

    if ((children = node.children) && (n = children.length)) {
      var n, children;

      while (--n >= 0) {
        nodes.push(children[n]);
      }
    }
  }
};

Hierarchy.layout_hierarchyVisitAfter = function (node, callback) {
  var nodes = [node],
      nodes2 = [];

  while ((node = nodes.pop()) != null) {
    nodes2.push(node);

    if ((children = node.children) && (n = children.length)) {
      var i = -1,
          n,
          children;

      while (++i < n) {
        nodes.push(children[i]);
      }
    }
  }

  while ((node = nodes2.pop()) != null) {
    callback(node);
  }
};

function layout_hierarchyChildren(d) {
  return d.children;
}

function layout_hierarchyValue(d) {
  return d.value;
}

function layout_hierarchySort(a, b) {
  return b.value - a.value;
}

function layout_hierarchyLinks(nodes) {
  return _arrays["default"].merge(nodes.map(function (parent) {
    return (parent.children || []).map(function (child) {
      return {
        source: parent,
        target: child
      };
    });
  }));
}

var _default = Hierarchy;
exports["default"] = _default;
});

unwrapExports(hierarchy);

var partition = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

var _hierarchy = interopRequireDefault(hierarchy);

function _default() {
  var hierarchy = (0, _hierarchy["default"])(),
      size = [1, 1];

  function position(node, x, dx, dy) {
    var children = node.children;
    node.x = x;
    node.y = node.depth * dy;
    node.dx = dx;
    node.dy = dy;

    if (children && (n = children.length)) {
      var i = -1,
          n,
          c,
          d;
      dx = node.value ? dx / node.value : 0;

      while (++i < n) {
        position(c = children[i], x, d = c.value * dx, dy);
        x += d;
      }
    }
  }

  function depth(node) {
    var children = node.children,
        d = 0;

    if (children && (n = children.length)) {
      var i = -1,
          n;

      while (++i < n) {
        d = Math.max(d, depth(children[i]));
      }
    }

    return 1 + d;
  }

  function partition(d, i) {
    var nodes = hierarchy.call(this, d, i);
    position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
    return nodes;
  }

  partition.size = function (x) {
    if (!arguments.length) return size;
    size = x;
    return partition;
  };

  return _hierarchy["default"].layout_hierarchyRebind(partition, hierarchy);
}
});

unwrapExports(partition);

var sunburst = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(graphs);

var _partition = interopRequireDefault(partition);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Sector = _canvax["default"].Shapes.Sector;

var sunburstGraphs = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(sunburstGraphs, _GraphsBase);

  var _super = _createSuper(sunburstGraphs);

  function sunburstGraphs(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, sunburstGraphs);
    _this = _super.call(this, opt, app);
    _this.type = "sunburst";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(sunburstGraphs.defaultProps()), opt);

    _this.data = []; //布局算法布局后的数据

    _this.dataGroup = []; //data数据按照深度的分组

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(sunburstGraphs, [{
    key: "init",
    value: function init() {}
  }, {
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {});

      _.extend(true, this, opt);

      this.data = this._trimGraphs();
      this.dataGroup = this._getDataGroupOfDepth();

      this._widget();

      this.sprite.context.x = this.width / 2 + this.origin.x;
      this.sprite.context.y = this.height / 2 + this.origin.y;
      this.fire("complete");
    }
  }, {
    key: "_trimGraphs",
    value: function _trimGraphs() {
      var _this2 = this;

      var me = this;
      var radius = parseInt(Math.min(this.width, this.height) / 2);
      var partition = (0, _partition["default"])().sort(null).size([2 * Math.PI, radius * radius]).value(function (d) {
        //return 1; 
        return d[me.field]; //d.size
      }); //安装深度分组

      var _treeData = this._tansTreeData();

      this.data = partition(_treeData, 0);
      this.data.forEach(function (item) {
        item.field = _this2.field;
      });
      return this.data;
    }
  }, {
    key: "_getDataGroupOfDepth",
    value: function _getDataGroupOfDepth() {
      var map = {};

      _.each(this.data, function (d) {
        map[d.depth] = [];
      });

      _.each(this.data, function (d) {
        map[d.depth].push(d);
      });

      var arr = [];

      for (var p in map) {
        arr.push(map[p]);
      }

      return arr;
    }
  }, {
    key: "_tansTreeData",
    value: function _tansTreeData() {
      var dataFrame = this.dataFrame;
      var treeData = {};
      var keyData = dataFrame.getFieldData(this.keyField);
      var valueData = dataFrame.getFieldData(this.field);
      var parentData = dataFrame.getFieldData(this.parentKeyField); //用parentField去找index

      function findChild(obj, parent, ki) {
        var parentKey = parent ? parent.name : undefined;

        for (var i = ki || 0; i < parentData.length; i++) {
          var key = parentData[i];

          if (!key && key !== 0) {
            key = undefined;
          }

          if (parentKey === key) {
            obj.name = keyData[i];
            obj.iNode = i;
            var value = valueData[i];

            if (!!value || value === 0) {
              obj.value = value;
            }

            _.each(parentData, function (key, ki) {
              if (key === obj.name) {
                //这个是obj的children
                if (!obj.children) {
                  obj.children = [];
                }
                var child = {};
                findChild(child, obj, ki);
                obj.children.push(child);
              }
            });

            break;
          }
        }
      }
      findChild(treeData);
      return treeData;
    }
  }, {
    key: "_widget",
    value: function _widget() {
      var me = this;

      _.each(this.dataGroup, function (group, g) {
        _.each(group, function (layoutData, i) {
          if (!layoutData.depth) {
            //最中间的大圆隐藏
            return;
          }
          var r = Math.sqrt(layoutData.y + layoutData.dy);
          var sectorContext = {
            r0: Math.sqrt(layoutData.y),
            r: Math.sqrt(layoutData.y) + 2,
            startAngle: layoutData.x * 180 / Math.PI,
            endAngle: (layoutData.x + layoutData.dx) * 180 / Math.PI,
            //secc.endAngle,
            fillStyle: layoutData.color || me.app.getTheme(layoutData.iNode),
            strokeStyle: me.node.strokeStyle,
            lineWidth: me.node.lineWidth,
            globalAlpha: 0
          };
          var sector = new Sector({
            id: "sector_" + g + "_" + i,
            context: sectorContext
          });
          sector.layoutData = layoutData;
          layoutData.sector = sector;
          layoutData.group = group; //所在的group

          me.sprite.addChild(sector);
          sector.hover(function () {
            me._focus(layoutData, group);
          }, function () {
            me._unfocus(layoutData, group);
          });
          sector.on(event.types.get(), function (e) {
            //fire到root上面去的是为了让root去处理tips
            e.eventInfo = {
              trigger: 'this.node',
              //me.node,
              iNode: layoutData.iNode
            };
            me.app.fire(e.type, e);
          });

          if (g <= 1) {
            sector.context.r = r;
            sector.context.globalAlpha = 1;
          } else {
            //从第二组开始，延时动画出现
            setTimeout(function () {
              if (!sector.context) {
                //这个时候可能图表已经被销毁了
                return;
              }

              sector.context.globalAlpha = 1;
              sector.animate({
                r: r
              }, {
                duration: 350
              });
            }, 350 * (g - 1));
          }
        });
      });
    }
  }, {
    key: "getNodesAt",
    value: function getNodesAt(iNode) {
      var nodes = [];

      if (iNode !== undefined) {
        var node = _.find(this.data, function (item) {
          return item.iNode == iNode;
        }); //type给到tips用主要


        node.type = 'sunburst';
        node && nodes.push(node);
      }
      return nodes;
    }
  }, {
    key: "_focus",
    value: function _focus(layoutData, group) {
      var me = this;

      _.each(group, function (d) {
        if (d !== layoutData) {
          d.sector.context.globalAlpha = me.node.blurAlpha;

          me._focusChildren(d, function (child) {
            child.sector.context.globalAlpha = me.node.blurAlpha;
          });
        }
      });

      me._focusParent(layoutData);
    }
  }, {
    key: "_unfocus",
    value: function _unfocus() {
      _.each(this.data, function (d) {
        d.sector && (d.sector.context.globalAlpha = 1);
      });
    }
  }, {
    key: "_focusChildren",
    value: function _focusChildren(d, callback) {
      var me = this;

      if (d.children && d.children.length) {
        _.each(d.children, function (child) {
          callback(child);

          me._focusChildren(child, callback);
        });
      }
    }
  }, {
    key: "_focusParent",
    value: function _focusParent(layoutData) {
      var me = this;

      if (layoutData.parent && layoutData.parent.sector && layoutData.parent.group) {
        _.each(layoutData.parent.group, function (d) {
          if (d === layoutData.parent) {
            d.sector.context.globalAlpha = 1;

            me._focusParent(layoutData.parent);
          } else {
            d.sector.context.globalAlpha = me.node.blurAlpha;
          }
        });
      }
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        keyField: {
          detail: 'key字段',
          "default": ''
        },
        field: {
          detail: 'value字段',
          "default": ''
        },
        parentKeyField: {
          detail: 'parent字段',
          "default": ''
        },
        node: {
          detail: '单个节点图形设置',
          propertys: {
            strokeStyle: {
              detail: '描边色',
              "default": '#ffffff'
            },
            lineWidth: {
              detail: '描边线宽',
              "default": 1
            },
            strokeAlpha: {
              detail: '描边边框透明度',
              "default": 1
            },
            fillStyle: {
              detail: '背景色',
              "default": null
            },
            fillAlpha: {
              detail: '背景透明度',
              "default": 1
            },
            blurAlpha: {
              detail: '非激活状态透明度',
              documentation: '比如选中其中一项，其他不先关的要降低透明度',
              "default": 0.4
            }
          }
        }
      };
    }
  }, {
    key: "polyfill",
    value: function polyfill(opt) {
      return opt;
    }
  }]);
  return sunburstGraphs;
}(_index["default"]);

_index["default"].registerComponent(sunburstGraphs, 'graphs', 'sunburst');

var _default = sunburstGraphs;
exports["default"] = _default;
});

unwrapExports(sunburst);

var sankey = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;



function _default() {
  var sankey = {},
      nodeWidth = 24,
      nodePadding = 8,
      size = [1, 1],
      nodes = [],
      sort = function sort(a, b) {
    return a.y - b.y;
  },
      // sort = function(a, b) {
  //     return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  // },
  links = [];

  sankey.nodeWidth = function (_) {
    if (!arguments.length) return nodeWidth;
    nodeWidth = +_;
    return sankey;
  };

  sankey.nodeSort = function (_) {
    if (!arguments.length) return sort;
    sort = _;
    return sankey;
  };

  sankey.nodePadding = function (_) {
    if (!arguments.length) return nodePadding;
    nodePadding = +_;
    return sankey;
  };

  sankey.nodes = function (_) {
    if (!arguments.length) return nodes;
    nodes = _;
    return sankey;
  };

  sankey.links = function (_) {
    if (!arguments.length) return links;
    links = _;
    return sankey;
  };

  sankey.size = function (_) {
    if (!arguments.length) return size;
    size = _;
    return sankey;
  };

  sankey.layout = function (iterations) {
    computeNodeLinks();
    computeNodeValues();
    computeNodeBreadths();
    computeNodeDepths(iterations);
    computeLinkDepths();
    return sankey;
  };

  sankey.relayout = function () {
    computeLinkDepths();
    return sankey;
  }; //d3


  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function (t) {
      return a * (1 - t) + b * t;
    };
  }

  sankey.link = function () {
    var curvature = .5;

    function link(d) {
      var x0 = d.source.x + d.source.dx,
          x1 = d.target.x,
          xi = d3_interpolateNumber(x0, x1),
          x2 = xi(curvature),
          x3 = xi(1 - curvature),
          //y0 = d.source.y + d.sy + d.dy / 2,
      //y1 = d.target.y + d.ty + d.dy / 2;
      y0 = d.source.y + d.sy,
          y1 = d.target.y + d.ty;
      var dy = d.dy;

      if (dy < 1) {
        dy = 1;
      }
      var path = "M" + x0 + "," + y0 + "C" + x2 + "," + y0 + " " + x3 + "," + y1 + " " + x1 + "," + y1;
      path += "v" + dy;
      path += "C" + x3 + "," + (y1 + dy) + " " + x2 + "," + (y0 + dy) + " " + x0 + "," + (y0 + dy);
      path += "v" + -dy + "z";
      return path;
    }

    link.curvature = function (_) {
      if (!arguments.length) return curvature;
      curvature = +_;
      return link;
    };

    return link;
  }; // Populate the sourceLinks and targetLinks for each node.
  // Also, if the source and target are not objects, assume they are indices.


  function computeNodeLinks() {
    nodes.forEach(function (node) {
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    links.forEach(function (link) {
      var source = link.source,
          target = link.target;
      if (typeof source === "number") source = link.source = nodes[link.source];
      if (typeof target === "number") target = link.target = nodes[link.target];
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    });
  }

  function d3_sum(e, t) {
    var n = 0,
        r = e.length,
        i,
        s = -1;
    if (arguments.length === 1) while (++s < r) {
      isNaN(i = +e[s]) || (n += i);
    } else while (++s < r) {
      isNaN(i = +t.call(e, e[s], s)) || (n += i);
    }
    return n;
  }

  function d3_min(e, t) {
    var n = -1,
        r = e.length,
        i,
        s;

    if (arguments.length === 1) {
      while (++n < r && ((i = e[n]) == null || i != i)) {
        i = undefined;
      }

      while (++n < r) {
        (s = e[n]) != null && i > s && (i = s);
      }
    } else {
      while (++n < r && ((i = t.call(e, e[n], n)) == null || i != i)) {
        i = undefined;
      }

      while (++n < r) {
        (s = t.call(e, e[n], n)) != null && i > s && (i = s);
      }
    }

    return i;
  }


  function computeNodeValues() {
    nodes.forEach(function (node) {
      node.value = Math.max(d3_sum(node.sourceLinks, value), d3_sum(node.targetLinks, value));
    });
  } // Iteratively assign the breadth (x-position) for each node.
  // Nodes are assigned the maximum breadth of incoming neighbors plus one;
  // nodes with no incoming links are assigned breadth zero, while
  // nodes with no outgoing links are assigned the maximum breadth.


  function computeNodeBreadths() {
    var remainingNodes = nodes,
        nextNodes,
        x = 0;

    while (remainingNodes.length) {
      nextNodes = [];
      remainingNodes.forEach(function (node) {
        node.x = x;
        node.dx = nodeWidth;
        node.sourceLinks.forEach(function (link) {
          if (nextNodes.indexOf(link.target) < 0) {
            nextNodes.push(link.target);
          }
        });
      });
      remainingNodes = nextNodes;
      ++x;
    } //


    moveSinksRight(x);
    scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));
  }

  function moveSinksRight(x) {
    nodes.forEach(function (node) {
      if (!node.sourceLinks.length) {
        node.x = x - 1;
      }
    });
  }

  function scaleNodeBreadths(kx) {
    nodes.forEach(function (node) {
      node.x *= kx;
    });
  } //d3 core


  function d3_class(ctor, properties) {
    if (Object.defineProperty) {
      for (var key in properties) {
        //TODO:d3这里不支持ie，要想办法解决
        Object.defineProperty(ctor.prototype, key, {
          value: properties[key],
          enumerable: false
        });
      }
    } else {
      //ie解决方案
      Canvax._.extend(ctor.prototype, properties);
    }
  }

  var d3_nest = function d3_nest() {
    var nest = {},
        keys = [],
        sortKeys = [],
        sortValues,
        rollup;

    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1,
          n = array.length,
          key = keys[depth++],
          keyValue,
          object,
          setter,
          valuesByKey = new d3_Map(),
          values;

      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [object]);
        }
      }

      if (mapType) {
        object = mapType();

        setter = function setter(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};

        setter = function setter(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }

      valuesByKey.forEach(setter);
      return object;
    }

    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [],
          sortKey = sortKeys[depth++];
      map.forEach(function (key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function (a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }

    nest.map = function (array, mapType) {
      return map(mapType, array, 0);
    };

    nest.entries = function (array) {
      return entries(map(d3_map, array, 0), 0);
    };

    nest.key = function (d) {
      keys.push(d);
      return nest;
    }; // Specifies the order for the most-recently specified key.
    // Note: only applies to entries. Map keys are unordered!


    nest.sortKeys = function (order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    }; // Specifies the order for leaf values.
    // Applies to both maps and entries array.


    nest.sortValues = function (order) {
      sortValues = order;
      return nest;
    };

    nest.rollup = function (f) {
      rollup = f;
      return nest;
    };

    return nest;
  };

  var d3_map = function d3_map(object, f) {
    var map = new d3_Map();

    if (object instanceof d3_Map) {
      object.forEach(function (key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1,
          n = object.length,
          o;
      if (arguments.length === 1) while (++i < n) {
        map.set(i, object[i]);
      } else while (++i < n) {
        map.set(f.call(object, o = object[i], i), o);
      }
    } else {
      for (var key in object) {
        map.set(key, object[key]);
      }
    }

    return map;
  };

  function d3_Map() {
    this._ = Object.create(null);
  }

  var d3_map_proto = "__proto__",
      d3_map_zero = "\0";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function get(key) {
      return this._[d3_map_escape(key)];
    },
    set: function set(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function values() {
      var values = [];

      for (var key in this._) {
        values.push(this._[key]);
      }

      return values;
    },
    entries: function entries() {
      var entries = [];

      for (var key in this._) {
        entries.push({
          key: d3_map_unescape(key),
          value: this._[key]
        });
      }

      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function forEach(f) {
      for (var key in this._) {
        f.call(this, d3_map_unescape(key), this._[key]);
      }
    }
  });

  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }

  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }

  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }

  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }

  function d3_map_keys() {
    var keys = [];

    for (var key in this._) {
      keys.push(d3_map_unescape(key));
    }

    return keys;
  }

  function d3_map_size() {
    var size = 0;

    for (var key in this._) {
      ++size;
    }

    return size;
  }

  function d3_map_empty() {
    for (var key in this._) {
      return false;
    }

    return true;
  }

  function d3_sortKey(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function computeNodeDepths(iterations) {
    var nodesByBreadth = d3_nest().key(function (d) {
      return d.x;
    }).sortKeys(d3_sortKey).entries(nodes).map(function (d) {
      return d.values;
    }); //

    initializeNodeDepth();
    resolveCollisions();

    for (var alpha = 1; iterations > 0; --iterations) {
      relaxRightToLeft(alpha *= .99);
      resolveCollisions();
      relaxLeftToRight(alpha);
      resolveCollisions();
    }

    function initializeNodeDepth() {
      var ky = d3_min(nodesByBreadth, function (nodes) {
        return (size[1] - (nodes.length - 1) * nodePadding) / d3_sum(nodes, value);
      });
      nodesByBreadth.forEach(function (nodes) {
        nodes.forEach(function (node, i) {
          node.y = i;
          node.dy = node.value * ky;
        });
      });
      links.forEach(function (link) {
        link.dy = link.value * ky;
      });
    }

    function relaxLeftToRight(alpha) {
      nodesByBreadth.forEach(function (nodes, breadth) {
        nodes.forEach(function (node) {
          if (node.targetLinks.length) {
            var y = d3_sum(node.targetLinks, weightedSource) / d3_sum(node.targetLinks, value);
            node.y += (y - center(node)) * alpha;
          }
        });
      });

      function weightedSource(link) {
        return center(link.source) * link.value;
      }
    }

    function relaxRightToLeft(alpha) {
      nodesByBreadth.slice().reverse().forEach(function (nodes) {
        nodes.forEach(function (node) {
          if (node.sourceLinks.length) {
            var y = d3_sum(node.sourceLinks, weightedTarget) / d3_sum(node.sourceLinks, value);
            node.y += (y - center(node)) * alpha;
          }
        });
      });

      function weightedTarget(link) {
        return center(link.target) * link.value;
      }
    }

    function resolveCollisions() {
      nodesByBreadth.forEach(function (nodes) {
        var node,
            dy,
            y0 = 0,
            n = nodes.length,
            i; // Push any overlapping nodes down.

        sort && nodes.sort(sort);

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dy = y0 - node.y;
          if (dy > 0) node.y += dy;
          y0 = node.y + node.dy + nodePadding;
        } // If the bottommost node goes outside the bounds, push it back up.


        dy = y0 - nodePadding - size[1];

        if (dy > 0) {
          y0 = node.y -= dy; // Push any overlapping nodes back up.

          for (i = n - 2; i >= 0; --i) {
            node = nodes[i];
            dy = node.y + node.dy + nodePadding - y0;
            if (dy > 0) node.y -= dy;
            y0 = node.y;
          }
        }
      });
    }
  }

  function computeLinkDepths() {
    nodes.forEach(function (node) {
      node.sourceLinks.sort(ascendingTargetDepth);
      node.targetLinks.sort(ascendingSourceDepth);
    });
    nodes.forEach(function (node) {
      var sy = 0,
          ty = 0;
      node.sourceLinks.forEach(function (link) {
        link.sy = sy;
        sy += link.dy;
      });
      node.targetLinks.forEach(function (link) {
        link.ty = ty;
        ty += link.dy;
      });
    });

    function ascendingSourceDepth(a, b) {
      return a.source.y - b.source.y;
    }

    function ascendingTargetDepth(a, b) {
      return a.target.y - b.target.y;
    }
  }

  function center(node) {
    return node.y + node.dy / 2;
  }

  function value(link) {
    return link.value;
  }

  return sankey;
}
});

unwrapExports(sankey);

var sankey$1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(graphs);

var _index2 = interopRequireDefault(sankey);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Path = _canvax["default"].Shapes.Path;
var Rect = _canvax["default"].Shapes.Rect;

var sankeyGraphs = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(sankeyGraphs, _GraphsBase);

  var _super = _createSuper(sankeyGraphs);

  function sankeyGraphs(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, sankeyGraphs);
    _this = _super.call(this, opt, app);
    _this.type = "sankey";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(sankeyGraphs.defaultProps()), opt);

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(sankeyGraphs, [{
    key: "init",
    value: function init() {
      this._links = new _canvax["default"].Display.Sprite();
      this._nodes = new _canvax["default"].Display.Sprite();
      this._labels = new _canvax["default"].Display.Sprite();
      this.sprite.addChild(this._links);
      this.sprite.addChild(this._nodes);
      this.sprite.addChild(this._labels);
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {});

      _.extend(true, this, opt);

      this.data = this._trimGraphs();

      this._widget();

      this.sprite.context.x = this.origin.x;
      this.sprite.context.y = this.origin.y;
      this.fire("complete");
    }
  }, {
    key: "_trimGraphs",
    value: function _trimGraphs() {
      var me = this;
      var nodes = [];
      var links = [];
      var keyDatas = me.dataFrame.getFieldData(me.keyField);
      var valueDatas = me.dataFrame.getFieldData(me.field);
      var parentFields = me.dataFrame.getFieldData(me.parentField);
      var nodeMap = {}; //name:ind

      _.each(keyDatas, function (key, i) {
        var nodeNames = [];

        if (me.parentField) {
          nodeNames.push(parentFields[i]);
        }
        nodeNames = nodeNames.concat(key.split(/[|]/));

        _.each(nodeNames, function (name) {
          if (nodeMap[name] === undefined) {
            nodeMap[name] = nodes.length;
            nodes.push({
              name: name
            });
          }
        });
      });

      _.each(keyDatas, function (key, i) {
        //let nodeNames = key.split(/[,|]/);
        var nodeNames = [];

        if (me.parentField) {
          nodeNames.push(parentFields[i]);
        }
        nodeNames = nodeNames.concat(key.split(/[|]/));

        if (nodeNames.length == 2) {
          links.push({
            source: nodeMap[nodeNames[0]],
            target: nodeMap[nodeNames[1]],
            value: valueDatas[i]
          });
        }
      });

      return (0, _index2["default"])().nodeWidth(this.node.width).nodePadding(this.node.padding).nodeSort(this.node.sort).size([this.width, this.height]).nodes(nodes).links(links).layout(16);
    }
  }, {
    key: "_widget",
    value: function _widget() {
      this._drawNodes();

      this._drawLinks();

      this._drawLabels();
    }
  }, {
    key: "_getColor",
    value: function _getColor(style, node, ind) {
      var me = this;
      var color = style;

      if (_.isArray(color)) {
        color = color[ind];
      }

      if (_.isFunction(color)) {
        color = color(node);
      }

      if (!color) {
        color = me.app.getTheme(ind);
      }

      return color;
    }
  }, {
    key: "_drawNodes",
    value: function _drawNodes() {
      var nodes = this.data.nodes();
      var me = this;

      _.each(nodes, function (node, i) {
        node.field = me.field;

        var nodeColor = me._getColor(me.node.fillStyle, node, i);

        var nodeElement = new Rect({
          xyToInt: false,
          context: {
            x: node.x,
            y: node.y,
            width: me.data.nodeWidth(),
            height: Math.max(node.dy, 1),
            fillStyle: nodeColor
          }
        });
        nodeElement.data = node;

        me._nodes.addChild(nodeElement);
      });
    }
  }, {
    key: "_drawLinks",
    value: function _drawLinks() {
      var links = this.data.links();
      var me = this;

      _.each(links, function (link, i) {
        var linkColor = me._getColor(me.line.strokeStyle, link, i);

        var d = me.data.link()(link);

        var _path = new Path({
          xyToInt: false,
          context: {
            path: d,
            fillStyle: linkColor,
            //lineWidth: Math.max(1, link.dy),
            globalAlpha: me.line.alpha,
            cursor: "pointer"
          }
        });

        _path.__glpha = me.line.alpha;
        _path.link = link;

        _path.on(event.types.get(), function (e) {
          if (me.line.focus.enabled) {
            if (e.type == 'mouseover') {
              this.__glpha += 0.1;
            }

            if (e.type == 'mouseout') {
              this.__glpha -= 0.1;
            }
          }
          var linkData = this.link; //type给tips用

          linkData.type = "sankey";
          link.field = me.field;
          link.__no__name = true;
          e.eventInfo = {
            trigger: 'this.node',
            //me.node,
            title: linkData.source.name + " <span style='display:inline-block;margin-left:4px;position:relative;top:-0.5px;font-size:16px;left:-3px;'>></span> " + linkData.target.name,
            nodes: [linkData]
          }; //fire到root上面去的是为了让root去处理tips

          me.app.fire(e.type, e);
        });

        me._links.addChild(_path);
      });
    }
  }, {
    key: "_drawLabels",
    value: function _drawLabels() {
      var nodes = this.data.nodes();
      var me = this;

      _.each(nodes, function (node) {
        var textAlign = me.label.textAlign;
        var x = node.x + me.data.nodeWidth() + 4;
        /*
        if( x > me.width/2 ){
            x  = node.x - 4;
            textAlign = 'right';
        } else {
            x += 4;
        };
        */

        var y = node.y + Math.max(node.dy / 2, 1);
        var txt = me.label.format ? me.label.format(node.name, node) : node.name;
        var label = new _canvax["default"].Display.Text(txt, {
          context: {
            x: x,
            y: y,
            fillStyle: me.label.fontColor,
            fontSize: me.label.fontSize,
            textAlign: textAlign,
            textBaseline: me.label.verticalAlign
          }
        });

        me._labels.addChild(label);

        if (label.getTextWidth() + x > me.width) {
          label.context.x = node.x - 4;
          label.context.textAlign = 'right';
        }
      });
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        keyField: {
          detail: 'key字段',
          "default": null
        },
        field: {
          detail: 'value字段',
          "default": 'value'
        },
        parentField: {
          detail: 'parent字段',
          "default": null
        },
        node: {
          detail: 'node',
          propertys: {
            width: {
              detail: '节点宽',
              "default": 18
            },
            padding: {
              detail: '节点间距',
              "default": 10
            },
            sort: {
              detail: '节点排序字段',
              "default": function _default(a, b) {
                return a.y - b.y;
              }
            },
            fillStyle: {
              detail: '节点背景色',
              "default": null
            }
          }
        },
        line: {
          detail: '线设置',
          propertys: {
            strokeStyle: {
              detail: '线颜色',
              "default": 'blue'
            },
            alpha: {
              detail: '线透明度',
              "default": 0.3
            },
            focus: {
              detail: '图形的hover设置',
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": true
                }
              }
            }
          }
        },
        label: {
          detail: '文本设置',
          propertys: {
            fontColor: {
              detail: '文本颜色',
              "default": '#666666'
            },
            fontSize: {
              detail: '文本字体大小',
              "default": 12
            },
            textAlign: {
              detail: '水平对齐方式',
              "default": 'left'
            },
            verticalAlign: {
              detail: '垂直对齐方式',
              "default": 'middle'
            },
            format: {
              detail: '文本格式函数',
              "default": null
            }
          }
        }
      };
    }
  }, {
    key: "polyfill",
    value: function polyfill(opt) {
      if (opt.valueField) {
        //20220304 所有的graph都统一一个field
        opt.field = opt.valueField;
        delete opt.valueField;
      }

      return opt;
    }
  }]);
  return sankeyGraphs;
}(_index["default"]);

_index["default"].registerComponent(sankeyGraphs, 'graphs', 'sankey');

var _default2 = sankeyGraphs;
exports["default"] = _default2;
});

unwrapExports(sankey$1);

var progress = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = interopRequireDefault(defineProperty$1);

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(graphs);





function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._; // https://zhuanlan.zhihu.com/p/271906562
// https://www.cnblogs.com/guojikun/p/10663487.html

var Progress = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(Progress, _GraphsBase);

  var _super = _createSuper(Progress);

  function Progress(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, Progress);
    _this = _super.call(this, opt, app);
    _this.type = "progress";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(Progress.defaultProps()), opt);

    _this.bgNodeData = null; //背景的nodeData数据，和data里面的结构保持一致

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(Progress, [{
    key: "init",
    value: function init() {}
  }, {
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {});
      var me = this;

      _.extend(true, this, opt);

      me.grow(function (process) {
        me.data = me._trimGraphs(process);

        me._widget();
      });
      this.sprite.context.x = this.origin.x;
      this.sprite.context.y = this.origin.y;
      this.fire("complete");
    }
  }, {
    key: "_trimGraphs",
    value: function _trimGraphs(scale) {
      var me = this;

      if (scale == undefined) {
        scale = 1;
      }

      var _coord = this.app.getComponent({
        name: 'coord'
      }); //用来计算下面的hLen


      this.enabledField = _coord.filterEnabledFields(this.field); //整个的

      var _startAngle = me.startAngle || _coord.startAngle;

      var _allAngle = me.allAngle || _coord.allAngle; //let _endAngle = startAngle + allAngle;


      this.bgNodeData = this._getNodeData(_startAngle, _allAngle);
      this.bgNodeData.fillStyle = this._getStyle(this.bgNodeData, this.bgColor);
      var data = {};

      _.each(this.enabledField, function (field) {
        var dataOrg = me.dataFrame.getFieldData(field);
        var nodeDatas = [];

        _.each(dataOrg, function (val, i) {
          val *= scale;
          var preNodeData = nodeDatas.slice(-1)[0];
          var startAngle = preNodeData ? preNodeData.endAngle : _startAngle;
          var allAngle = _allAngle * (val / 100);

          var nodeData = me._getNodeData(startAngle, allAngle, field, val, i);

          nodeData.fillStyle = me._getStyle(nodeData, me.node.fillStyle);
          nodeDatas.push(nodeData);
        });

        data[field] = nodeDatas;
      });

      return data;
    }
  }, {
    key: "_getNodeData",
    value: function _getNodeData(startAngle, allAngle, field, val, i) {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      var middleAngle = startAngle + Math.min(allAngle, 180);
      var endAngle = startAngle + allAngle;
      var startRadian = Math.PI * startAngle / 180; //起始弧度

      var middleRadian = Math.PI * middleAngle / 180;
      var endRadian = Math.PI * endAngle / 180; //终点弧度

      var outRadius = me.radius || _coord.radius;
      var innerRadius = outRadius - me.node.width;

      var startOutPoint = _coord.getPointInRadianOfR(startRadian, outRadius);

      var middleOutPoint = _coord.getPointInRadianOfR(middleRadian, outRadius);

      var endOutPoint = _coord.getPointInRadianOfR(endRadian, outRadius);

      var startInnerPoint = _coord.getPointInRadianOfR(startRadian, innerRadius);

      var middleInnerPoint = _coord.getPointInRadianOfR(middleRadian, innerRadius);

      var endInnerPoint = _coord.getPointInRadianOfR(endRadian, innerRadius);

      var nodeData = {
        field: field,
        value: val,
        text: val,
        //value format后的数据
        iNode: i,
        allAngle: allAngle,
        startAngle: startAngle,
        middleAngle: middleAngle,
        endAngle: endAngle,
        startRadian: startRadian,
        middleRadian: middleRadian,
        endRadian: endRadian,
        outRadius: outRadius,
        innerRadius: innerRadius,
        startOutPoint: startOutPoint,
        middleOutPoint: middleOutPoint,
        endOutPoint: endOutPoint,
        startInnerPoint: startInnerPoint,
        middleInnerPoint: middleInnerPoint,
        endInnerPoint: endInnerPoint,
        rowData: me.dataFrame.getRowDataAt(i),
        fillStyle: null
      };

      if (field) {
        if (me.label.format) {
          if (_.isFunction(me.label.format)) {
            nodeData.text = me.label.format.apply(this, [val, nodeData]);
          }
        } else {
          //否则用fieldConfig上面的
          var _coord2 = me.app.getComponent({
            name: 'coord'
          });

          var fieldConfig = _coord2.getFieldConfig(field);

          if (fieldConfig) {
            nodeData.text = fieldConfig.getFormatValue(nodeData.value);
          } else {
            nodeData.text = nodeData.value.toFixed(this.label.fixNum);
          }
        }
      }
      return nodeData;
    }
  }, {
    key: "_widget",
    value: function _widget() {
      var me = this;

      if (me.bgEnabled) {
        var bgPathStr = me._getPathStr(this.bgNodeData);

        if (me._bgPathElement) {
          me._bgPathElement.context.path = bgPathStr;
        } else {
          me._bgPathElement = new _canvax["default"].Shapes.Path({
            context: {
              path: bgPathStr
            }
          });
          me.sprite.addChild(me._bgPathElement);
        }
        me._bgPathElement.context.lineWidth = this.node.width;
        me._bgPathElement.context.strokeStyle = this.bgNodeData.fillStyle;
      }

      _.each(this.data, function (nodeDatas) {
        _.each(nodeDatas, function (nodeData, i) {
          var pathStr = me._getBarPathStr1(nodeData);

          var elId = "progress_bar_" + nodeData.field + "_" + i;
          var pathElement = me.sprite.getChildById(elId);

          if (pathElement) {
            pathElement.context.path = pathStr;
          } else {
            pathElement = new _canvax["default"].Shapes.Path({
              id: elId,
              context: {
                path: pathStr
              }
            });
            me.sprite.addChild(pathElement);
          }
          pathElement.context.lineWidth = me.node.width;
          var style = nodeData.fillStyle;
          var allColors = [];

          if (style && style.lineargradient) {
            var start = _objectSpread({}, style.lineargradient[0]);

            var end = _objectSpread({}, style.lineargradient.slice(-1)[0]);

            var lineargradient = [start, end];

            if (nodeData.endAngle > nodeData.middleAngle) {
              //超过了180度的话要绘制第二条
              allColors = (0, color.gradient)(style.lineargradient[0].color, style.lineargradient.slice(-1)[0].color, parseInt(nodeData.allAngle / 10));
              end.color = allColors[17];
            } //let newLineargradient = 
            // let _style = me.ctx.createLinearGradient( nodeData.startOutPoint.x ,nodeData.startOutPoint.y, nodeData.middleOutPoint.x, nodeData.middleOutPoint.y );
            // _.each( lineargradient , function( item ){
            //     _style.addColorStop( item.position , item.color);
            // });


            style = {
              lineargradient: lineargradient,
              points: [nodeData.startOutPoint.x, nodeData.startOutPoint.y, nodeData.middleOutPoint.x, nodeData.middleOutPoint.y]
            };
          }
          pathElement.context.strokeStyle = style;

          if (nodeData.endAngle > nodeData.middleAngle) {
            //超过了180度的话要绘制第二条
            var _pathStr = me._getBarPathStr2(nodeData);

            var _elId = "progress_bar_" + nodeData.field + "_" + i + "_2";

            var _pathElement = me.sprite.getChildById(_elId);

            if (_pathElement) {
              _pathElement.context.path = _pathStr;
            } else {
              _pathElement = new _canvax["default"].Shapes.Path({
                id: _elId,
                context: {
                  path: _pathStr
                }
              });
              me.sprite.addChild(_pathElement);
            }
            _pathElement.context.lineWidth = me.node.width;
            var _style = nodeData.fillStyle;

            if (_style && _style.lineargradient) {
              var _start = _objectSpread({}, _style.lineargradient[0]);

              _start.color = allColors[17];

              var _end = _objectSpread({}, _style.lineargradient.slice(-1)[0]);

              var _lineargradient = [_start, _end]; // let _style = me.ctx.createLinearGradient( nodeData.middleOutPoint.x ,nodeData.middleOutPoint.y, nodeData.endOutPoint.x, nodeData.endOutPoint.y );
              // _.each( lineargradient , function( item ){
              //     _style.addColorStop( item.position , item.color);
              // });
              // style = _style;

              _style = {
                lineargradient: _lineargradient,
                points: [nodeData.middleOutPoint.x, nodeData.middleOutPoint.y, nodeData.endOutPoint.x, nodeData.endOutPoint.y]
              };
            }
            _pathElement.context.strokeStyle = _style;
          }

          if (me.label.enabled) {
            var labelSpId = "progress_label_" + nodeData.field + "_sprite_" + i;
            var labelSpElement = me.sprite.getChildById(labelSpId);

            if (labelSpElement) ; else {
              labelSpElement = new _canvax["default"].Display.Sprite({
                id: labelSpId
              });
              me.sprite.addChild(labelSpElement);
            }
            labelSpElement.context.x = me.label.offsetX - 6; //%好会占一部分位置 所以往左边偏移6

            labelSpElement.context.y = me.label.offsetY;
            var labelCtx = {
              fillStyle: me.label.fontColor || nodeData.fillStyle,
              fontSize: me.label.fontSize,
              lineWidth: me.label.lineWidth,
              strokeStyle: me.label.strokeStyle,
              textAlign: me.label.textAlign,
              textBaseline: me.label.verticalAlign,
              rotation: me.label.rotation
            };
            var labelId = "progress_label_" + nodeData.field + "_" + i;
            var labelElement = labelSpElement.getChildById(labelId);

            if (labelElement) {
              labelElement.resetText(nodeData.text);

              _.extend(labelElement.context, labelCtx);
            } else {
              labelElement = new _canvax["default"].Display.Text(nodeData.text, {
                id: labelId,
                context: labelCtx
              });
              labelSpElement.addChild(labelElement);
            }
            var labelSymbolId = "progress_label_" + nodeData.field + "_symbol_" + i;
            var labelSymbolElement = labelSpElement.getChildById(labelSymbolId);
            var lebelSymbolCxt = {
              x: labelElement.getTextWidth() / 2 + 2,
              y: 3,
              fillStyle: me.label.unitColor || me.label.fontColor || nodeData.fillStyle,
              fontSize: me.label.unitFontSize,
              textAlign: "left",
              textBaseline: me.label.verticalAlign
            };

            if (labelSymbolElement) {
              _.extend(labelSymbolElement.context, lebelSymbolCxt);
            } else {
              var unitText = me.label.unit;
              labelSymbolElement = new _canvax["default"].Display.Text(unitText, {
                id: labelSymbolId,
                context: lebelSymbolCxt
              });
              labelSpElement.addChild(labelSymbolElement);
            }
          }
        });
      });
    }
  }, {
    key: "_getPathStr",
    value: function _getPathStr(nodeData) {
      var pathStr = "M" + nodeData.startOutPoint.x + " " + nodeData.startOutPoint.y;
      pathStr += "A" + nodeData.outRadius + " " + nodeData.outRadius + " 0 0 1 " + nodeData.middleOutPoint.x + " " + nodeData.middleOutPoint.y;
      pathStr += "A" + nodeData.outRadius + " " + nodeData.outRadius + " 0 0 1 " + nodeData.endOutPoint.x + " " + nodeData.endOutPoint.y; // let actionType = "L";
      // if( nodeData.allAngle % 360 == 0 ){
      //     //actionType = "M" 
      // };
      // pathStr += actionType+nodeData.endInnerPoint.x+" "+nodeData.endInnerPoint.y;
      // pathStr += "A"+nodeData.innerRadius+" "+nodeData.innerRadius+" 0 0 0 " + nodeData.middleInnerPoint.x + " "+ nodeData.middleInnerPoint.y;
      // pathStr += "A"+nodeData.innerRadius+" "+nodeData.innerRadius+" 0 0 0 " + nodeData.startInnerPoint.x + " "+ nodeData.startInnerPoint.y;
      // pathStr += "Z";

      return pathStr;
    }
  }, {
    key: "_getBarPathStr1",
    value: function _getBarPathStr1(nodeData) {
      var pathStr = "M" + nodeData.startOutPoint.x + " " + nodeData.startOutPoint.y;
      pathStr += "A" + nodeData.outRadius + " " + nodeData.outRadius + " 0 0 1 " + nodeData.middleOutPoint.x + " " + nodeData.middleOutPoint.y; //pathStr += "A"+nodeData.outRadius+" "+nodeData.outRadius+" 0 0 1 " + nodeData.endOutPoint.x + " "+ nodeData.endOutPoint.y;

      return pathStr;
    }
  }, {
    key: "_getBarPathStr2",
    value: function _getBarPathStr2(nodeData) {
      var pathStr = "M" + nodeData.middleOutPoint.x + " " + nodeData.middleOutPoint.y; //pathStr += "A"+nodeData.outRadius+" "+nodeData.outRadius+" 0 0 1 " + nodeData.middleOutPoint.x + " "+ nodeData.middleOutPoint.y;

      pathStr += "A" + nodeData.outRadius + " " + nodeData.outRadius + " 0 0 1 " + nodeData.endOutPoint.x + " " + nodeData.endOutPoint.y;
      return pathStr;
    }
  }, {
    key: "_getStyle",
    value: function _getStyle(nodeData, prop, def) {

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      var fieldConfig = _coord.getFieldConfig(nodeData.field);

      def = def || (fieldConfig ? fieldConfig.color : "#171717");
      var style = prop;

      if (prop) {
        if (_.isString(prop)) {
          style = prop;
        }

        if (_.isArray(prop)) {
          style = prop[nodeData.iNode];
        }

        if (_.isFunction(prop)) {
          style = prop.apply(this, arguments);
        }
      }

      if (!style) {
        style = def;
      }

      return style;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: '字段配置',
          "default": null
        },
        aniEasing: 'Quintic.Out',
        node: {
          detail: '进度条设置',
          propertys: {
            width: {
              detail: '进度条的宽度',
              "default": 16
            },
            fillStyle: {
              detail: '进度条的填充色',
              documentation: '可以是单个颜色，也可以是数组，也可以是一个函数,也可以是个lineargradient',
              "default": null
            }
          }
        },
        label: {
          detail: '进度值文本',
          propertys: {
            enabled: {
              detail: '是否启用label',
              "default": 'true'
            },
            unit: {
              detail: '单位值，默认%',
              "default": '%'
            },
            unitColor: {
              detail: '单位值的颜色',
              "default": null
            },
            unitFontSize: {
              detail: '单位值的大小',
              "default": 14
            },
            fontColor: {
              detail: 'label颜色',
              "default": null //默认同node.fillStyle

            },
            fontSize: {
              detail: 'label文本大小',
              "default": 26
            },
            fixNum: {
              detail: 'toFixed的位数',
              "default": 2
            },
            format: {
              detail: 'label格式化处理函数',
              "default": null
            },
            lineWidth: {
              detail: 'label文本描边线宽',
              "default": null
            },
            strokeStyle: {
              detail: 'label描边颜色',
              "default": null
            },
            rotation: {
              detail: 'label旋转角度',
              "default": 0
            },
            textAlign: {
              detail: 'label textAlign',
              "default": 'center',
              values: ['left', 'center', 'right']
            },
            //left center right
            verticalAlign: {
              detail: 'label verticalAlign',
              "default": 'middle',
              values: ['top', 'middle', 'bottom']
            },
            //top middle bottom
            position: {
              detail: 'label位置',
              "default": 'origin'
            },
            offsetX: {
              detail: 'label在x方向的偏移量',
              "default": 0
            },
            offsetY: {
              detail: 'label在y方向的偏移量',
              "default": 0
            }
          }
        },
        bgEnabled: {
          detail: '是否开启背景',
          "default": true
        },
        bgColor: {
          detail: '进度条背景颜色',
          "default": '#f7f7f7'
        },
        radius: {
          detail: '半径',
          "default": null
        },
        allAngle: {
          detail: '总角度',
          documentation: '默认为null，则和坐标系同步',
          "default": null
        },
        startAngle: {
          detail: '其实角度',
          documentation: '默认为null，则和坐标系同步',
          "default": null
        }
      };
    }
  }]);
  return Progress;
}(_index["default"]);

_index["default"].registerComponent(Progress, 'graphs', 'progress');

var _default = Progress;
exports["default"] = _default;
});

unwrapExports(progress);

var arrayWithoutHoles$1 = createCommonjsModule(function (module) {
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray$1(arr);
}

module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(arrayWithoutHoles$1);

var iterableToArray$1 = createCommonjsModule(function (module) {
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(iterableToArray$1);

var nonIterableSpread$1 = createCommonjsModule(function (module) {
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(nonIterableSpread$1);

var toConsumableArray$1 = createCommonjsModule(function (module) {
function _toConsumableArray(arr) {
  return arrayWithoutHoles$1(arr) || iterableToArray$1(arr) || unsupportedIterableToArray$1(arr) || nonIterableSpread$1();
}

module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

unwrapExports(toConsumableArray$1);

var data = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayToTreeJsonForRelation = arrayToTreeJsonForRelation;
exports.checkDataIsJson = checkDataIsJson;
exports.jsonToArrayForRelation = jsonToArrayForRelation;



/**
 * 把json数据转化为关系图的数据格式
 */
//判断数据是否符合json格式要求的规范，
//如：
// [{
// 	name: 'xxxx',
// 	children: [{
// 		name: 'aaaaa'
// 	}, {
// 		name: 'bbbb',
// 		children: [{
// 			name: 'ccccc'
// 		}]
// 	}],
// }];
//const parentKey = 'parent';
var defaultFieldKey = '__key__';
var childrenKey = 'children';

function checkDataIsJson(data, key, _childrenField) {
  childrenKey = _childrenField;
  var result = false; //1、要求数据必须是一个数组

  if (!Canvax._.isArray(data)) return false; //2、数组中的每个元素是一个对象

  result = Canvax._.every(data, function (item) {
    return Canvax._.isObject(item);
  }); //3、field 自动不能是数组，如果是表示已经处理过的数据

  if (result) {
    result = Canvax._.every(data, function (item) {
      return !Canvax._.isArray(item[key]);
    });
  }

  result = Canvax._.some(data, function (item) {
    return childrenKey in item;
  });
  return result;
}

function jsonToArrayForRelation(data, options, _childrenField) {
  childrenKey = _childrenField;
  var result = [];
  var wm = new WeakMap();
  var key = options.field || defaultFieldKey;
  var label = options.node && options.node.content && options.node.content.field;

  if (!checkDataIsJson(data, key, childrenKey)) {
    return result;
  }
  var childrens = [];
  var index = 0;

  Canvax._.each(data, function (_item) {
    childrens.push(_item);
  });

  var _loop = function _loop() {
    var item = childrens.pop();
    if (!item[key]) item[key] = index;
    var _child = item[childrenKey];

    if (_child) {
      Canvax._.each(_child, function (ch) {
        wm.set(ch, {
          parentIndex: index,
          parentNode: item
        });
      });

      childrens = childrens.concat(_child.reverse());
    }

    var obj = {};

    Canvax._.each(item, function (value, key) {
      if (key !== childrenKey) {
        obj[key] = value;
      }
    });

    result.push(obj);
    var myWm = wm.get(item);

    if (myWm) {
      var start = myWm.parentIndex;
      var startNode = myWm.parentNode;
      var line = {};
      line.key = [start, index].join(',');

      if (label) {
        line[label] = [startNode[label], item[label]].join('_');
      }

      result.push(line);
    }

    index++;
  };

  while (childrens.length) {
    _loop();
  } // wm = null;


  return result;
}

function arrayToTreeJsonForRelation(data, options) {
  // [ { key: 1, name: },{key:'1,2'} ] to [ { name: children: [ {}... ] } ] 
  var _nodes = {};
  var _edges = {};

  Canvax._.each(data, function (item) {
    var key = item[options.field] + '';

    if (key.split(',').length == 1) {
      _nodes[key] = item;
    } else {
      _edges[key] = item;
    }
  }); //先找到所有的一层


  var arr = [];

  Canvax._.each(_nodes, function (node, nkey) {
    var isFirstLev = true;

    Canvax._.each(_edges, function (edge, ekey) {
      ekey = ekey + '';

      if (ekey.split(',')[1] == nkey) {
        isFirstLev = false;
        return false;
      }
    });

    if (isFirstLev) {
      arr.push(node);
      node.__inRelation = true;
    }
  }); //有了第一层就好办了


  function getChildren(list) {
    Canvax._.each(list, function (node) {
      if (node.__cycle) return;
      var key = node[options.field];

      Canvax._.each(_edges, function (edge, ekey) {
        ekey = ekey + '';

        if (ekey.split(',')[0] == key) {
          //那么说明[1] 就是自己的children
          var childNode = _nodes[ekey.split(',')[1]];

          if (childNode) {
            if (!node.children) node.children = [];

            if (!Canvax._.find(node.children, function (_child) {
              return _child.key == childNode.key;
            })) {
              node.children.push(childNode);
            }
            //如果这个目标节点__inRelation已经在关系结构中
            //那么说明形成闭环了，不需要再分析这个节点的children

            if (childNode.__inRelation) {
              childNode.__cycle = true;
            }
          }
        }
      });

      if (node.children && node.children.length) {
        getChildren(node.children);
      }
    });
  }
  getChildren(arr);
  return arr;
}
});

unwrapExports(data);
var data_1 = data.arrayToTreeJsonForRelation;
var data_2 = data.checkDataIsJson;
var data_3 = data.jsonToArrayForRelation;

var zoom = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

/**
 * @fileOverview zoom controller
 * @author litao.lt@alibaba-in.com
 * @version 1.0
 */
function _default() {
  var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var mouse = {
    x: 0,
    y: 0,
    rx: 0,
    ry: 0
  };
  var scale = opt.scale || 1;
  var scaleMin = opt.scaleMin || 1;
  var scaleMax = opt.scaleMax || 8; //世界坐标

  var wx = 0;
  var wy = 0; //舞台坐标

  var sx = 0;
  var sy = 0;

  var zoomedX = function zoomedX() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return Math.floor((x - wx) * scale + sx);
  };

  var zoomedY = function zoomedY() {
    var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return Math.floor((y - wy) * scale + sy);
  };

  var zoomedX_INV = function zoomedX_INV() {
    var mouseX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return Math.floor((mouseX - sx) * (1 / scale) + wx);
  };

  var zoomedY_INV = function zoomedY_INV() {
    var mouseY = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return Math.floor((mouseY - sy) * (1 / scale) + wy);
  };

  var mouseMoveTo = function mouseMoveTo(point) {
    mouse.x = point.x;
    mouse.y = point.y;
    var xx = mouse.rx;
    var yy = mouse.ry;
    mouse.rx = zoomedX_INV(mouse.x);
    mouse.ry = zoomedY_INV(mouse.y);
    return {
      xx: xx,
      yy: yy
    };
  };

  var offset = function offset(pos) {
    mouse.x += pos.x;
    mouse.y += pos.y;
    return move(mouse);
  };

  var wheel = function wheel(e, point) {
    mouseMoveTo(point);
    wx = mouse.rx; //set world origin

    wy = mouse.ry;
    sx = mouse.x; //set screen origin

    sy = mouse.y; //判断上下滚动来设置scale的逻辑

    if (e.deltaY < 0) {
      scale = Math.min(scaleMax, scale * 1.1); //zoom in
    } else {
      scale = Math.max(scaleMin, scale * (1 / 1.1)); // zoom out is inverse of zoom in
    }
    return {
      scale: scale,
      x: zoomedX(),
      y: zoomedY()
    };
  };

  var move = function move(point) {
    var _mouseMoveTo = mouseMoveTo(point),
        xx = _mouseMoveTo.xx,
        yy = _mouseMoveTo.yy;

    wx -= mouse.rx - xx;
    wy -= mouse.ry - yy;
    mouse.rx = zoomedX_INV(mouse.x);
    mouse.ry = zoomedY_INV(mouse.y);
    return {
      scale: scale,
      x: zoomedX(),
      y: zoomedY()
    };
  };

  var getZoomedPoint = function getZoomedPoint() {
    var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      x: 0,
      y: 0
    };
    return {
      x: zoomedX(point.x),
      y: zoomedY(point.y)
    };
  };

  this.wheel = wheel;
  this.move = move;
  this.mouseMoveTo = mouseMoveTo;
  this.offset = offset;
  this.getZoomedPoint = getZoomedPoint;
}
});

unwrapExports(zoom);

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

var _listCacheClear = listCacheClear;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

var eq_1 = eq;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

var _assocIndexOf = assocIndexOf;

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

var _listCacheDelete = listCacheDelete;

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

var _listCacheGet = listCacheGet;

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

var _listCacheHas = listCacheHas;

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

var _listCacheSet = listCacheSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;

var _ListCache = ListCache;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new _ListCache;
  this.size = 0;
}

var _stackClear = stackClear;

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

var _stackDelete = stackDelete;

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

var _stackGet = stackGet;

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

var _stackHas = stackHas;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal || freeSelf || Function('return this')();

var _root = root;

/** Built-in value references. */
var Symbol$1 = _root.Symbol;

var _Symbol = Symbol$1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$1.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

var _getRawTag = getRawTag;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

var _objectToString = objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag$1 && symToStringTag$1 in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

var _baseGetTag = baseGetTag;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject;

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject_1(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = _baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var isFunction_1 = isFunction;

/** Used to detect overreaching core-js shims. */
var coreJsData = _root['__core-js_shared__'];

var _coreJsData = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

var _isMasked = isMasked;

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

var _toSource = toSource;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$2 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject_1(value) || _isMasked(value)) {
    return false;
  }
  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

var _baseIsNative = baseIsNative;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

var _getValue = getValue;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

var _getNative = getNative;

/* Built-in method references that are verified to be native. */
var Map$1 = _getNative(_root, 'Map');

var _Map = Map$1;

/* Built-in method references that are verified to be native. */
var nativeCreate = _getNative(Object, 'create');

var _nativeCreate = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

var _hashClear = hashClear;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _hashDelete = hashDelete;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty$3.call(data, key) ? data[key] : undefined;
}

var _hashGet = hashGet;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$4.call(data, key);
}

var _hashHas = hashHas;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

var _hashSet = hashSet;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;

var _Hash = Hash;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash,
    'map': new (_Map || _ListCache),
    'string': new _Hash
  };
}

var _mapCacheClear = mapCacheClear;

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

var _isKeyable = isKeyable;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

var _getMapData = getMapData;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _mapCacheDelete = mapCacheDelete;

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

var _mapCacheGet = mapCacheGet;

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

var _mapCacheHas = mapCacheHas;

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _mapCacheSet = mapCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;

var _MapCache = MapCache;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache) {
    var pairs = data.__data__;
    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

var _stackSet = stackSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = _stackClear;
Stack.prototype['delete'] = _stackDelete;
Stack.prototype.get = _stackGet;
Stack.prototype.has = _stackHas;
Stack.prototype.set = _stackSet;

var _Stack = Stack;

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

var _arrayEach = arrayEach;

var defineProperty$2 = (function() {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

var _defineProperty = defineProperty$2;

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty) {
    _defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

var _baseAssignValue = baseAssignValue;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$5.call(object, key) && eq_1(objValue, value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

var _assignValue = assignValue;

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue(object, key, newValue);
    } else {
      _assignValue(object, key, newValue);
    }
  }
  return object;
}

var _copyObject = copyObject;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

var _baseTimes = baseTimes;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
}

var _baseIsArguments = baseIsArguments;

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
  return isObjectLike_1(value) && hasOwnProperty$6.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

var isArguments_1 = isArguments;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

var isArray_1 = isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

var stubFalse_1 = stubFalse;

var isBuffer_1 = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports =  exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse_1;

module.exports = isBuffer;
});

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

var _isIndex = isIndex;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}

var isLength_1 = isLength;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike_1(value) &&
    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
}

var _baseIsTypedArray = baseIsTypedArray;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

var _baseUnary = baseUnary;

var _nodeUtil = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports =  exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && _freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;
});

/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

var isTypedArray_1 = isTypedArray;

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_1(value),
      isArg = !isArr && isArguments_1(value),
      isBuff = !isArr && !isArg && isBuffer_1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? _baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$7.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           _isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

var _arrayLikeKeys = arrayLikeKeys;

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$8;

  return value === proto;
}

var _isPrototype = isPrototype;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys$1 = _overArg(Object.keys, Object);

var _nativeKeys = nativeKeys$1;

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!_isPrototype(object)) {
    return _nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

var _baseKeys = baseKeys;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike$1(value) {
  return value != null && isLength_1(value.length) && !isFunction_1(value);
}

var isArrayLike_1 = isArrayLike$1;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
}

var keys_1 = keys;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && _copyObject(source, keys_1(source), object);
}

var _baseAssign = baseAssign;

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

var _nativeKeysIn = nativeKeysIn;

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject_1(object)) {
    return _nativeKeysIn(object);
  }
  var isProto = _isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$9.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

var _baseKeysIn = baseKeysIn;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}

var keysIn_1 = keysIn;

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && _copyObject(source, keysIn_1(source), object);
}

var _baseAssignIn = baseAssignIn;

var _cloneBuffer = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports =  exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
});

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

var _copyArray = copyArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

var _arrayFilter = arrayFilter;

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

var stubArray_1 = stubArray;

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return _arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};

var _getSymbols = getSymbols;

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return _copyObject(source, _getSymbols(source), object);
}

var _copySymbols = copySymbols;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

var _arrayPush = arrayPush;

/** Built-in value references. */
var getPrototype = _overArg(Object.getPrototypeOf, Object);

var _getPrototype = getPrototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
  var result = [];
  while (object) {
    _arrayPush(result, _getSymbols(object));
    object = _getPrototype(object);
  }
  return result;
};

var _getSymbolsIn = getSymbolsIn;

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return _copyObject(source, _getSymbolsIn(source), object);
}

var _copySymbolsIn = copySymbolsIn;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
}

var _baseGetAllKeys = baseGetAllKeys;

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return _baseGetAllKeys(object, keys_1, _getSymbols);
}

var _getAllKeys = getAllKeys;

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
}

var _getAllKeysIn = getAllKeysIn;

/* Built-in method references that are verified to be native. */
var DataView = _getNative(_root, 'DataView');

var _DataView = DataView;

/* Built-in method references that are verified to be native. */
var Promise$1 = _getNative(_root, 'Promise');

var _Promise = Promise$1;

/* Built-in method references that are verified to be native. */
var Set$1 = _getNative(_root, 'Set');

var _Set = Set$1;

/* Built-in method references that are verified to be native. */
var WeakMap$1 = _getNative(_root, 'WeakMap');

var _WeakMap = WeakMap$1;

/** `Object#toString` result references. */
var mapTag$1 = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$1 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';

var dataViewTag$1 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = _toSource(_DataView),
    mapCtorString = _toSource(_Map),
    promiseCtorString = _toSource(_Promise),
    setCtorString = _toSource(_Set),
    weakMapCtorString = _toSource(_WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = _baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$1) ||
    (_Map && getTag(new _Map) != mapTag$1) ||
    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
    (_Set && getTag(new _Set) != setTag$1) ||
    (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
  getTag = function(value) {
    var result = _baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? _toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$1;
        case mapCtorString: return mapTag$1;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$1;
        case weakMapCtorString: return weakMapTag$1;
      }
    }
    return result;
  };
}

var _getTag = getTag;

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$c.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty$a.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

var _initCloneArray = initCloneArray;

/** Built-in value references. */
var Uint8Array = _root.Uint8Array;

var _Uint8Array = Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}

var _cloneArrayBuffer = cloneArrayBuffer;

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

var _cloneDataView = cloneDataView;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

var _cloneRegExp = cloneRegExp;

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

var _cloneSymbol = cloneSymbol;

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var _cloneTypedArray = cloneTypedArray;

/** `Object#toString` result references. */
var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return _cloneArrayBuffer(object);

    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);

    case dataViewTag$2:
      return _cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return _cloneTypedArray(object, isDeep);

    case mapTag$2:
      return new Ctor;

    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);

    case regexpTag$1:
      return _cloneRegExp(object);

    case setTag$2:
      return new Ctor;

    case symbolTag:
      return _cloneSymbol(object);
  }
}

var _initCloneByTag = initCloneByTag;

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject_1(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

var _baseCreate = baseCreate;

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !_isPrototype(object))
    ? _baseCreate(_getPrototype(object))
    : {};
}

var _initCloneObject = initCloneObject;

/** `Object#toString` result references. */
var mapTag$3 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike_1(value) && _getTag(value) == mapTag$3;
}

var _baseIsMap = baseIsMap;

/* Node.js helper references. */
var nodeIsMap = _nodeUtil && _nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;

var isMap_1 = isMap;

/** `Object#toString` result references. */
var setTag$3 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike_1(value) && _getTag(value) == setTag$3;
}

var _baseIsSet = baseIsSet;

/* Node.js helper references. */
var nodeIsSet = _nodeUtil && _nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;

var isSet_1 = isSet;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$2 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    mapTag$4 = '[object Map]',
    numberTag$2 = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag$2 = '[object RegExp]',
    setTag$4 = '[object Set]',
    stringTag$2 = '[object String]',
    symbolTag$1 = '[object Symbol]',
    weakMapTag$2 = '[object WeakMap]';

var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$3 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] =
cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] =
cloneableTags[boolTag$2] = cloneableTags[dateTag$2] =
cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] =
cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] =
cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] =
cloneableTags[numberTag$2] = cloneableTags[objectTag$2] =
cloneableTags[regexpTag$2] = cloneableTags[setTag$4] =
cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] =
cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] =
cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag$2] =
cloneableTags[weakMapTag$2] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject_1(value)) {
    return value;
  }
  var isArr = isArray_1(value);
  if (isArr) {
    result = _initCloneArray(value);
    if (!isDeep) {
      return _copyArray(value, result);
    }
  } else {
    var tag = _getTag(value),
        isFunc = tag == funcTag$2 || tag == genTag$1;

    if (isBuffer_1(value)) {
      return _cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$2 || tag == argsTag$2 || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : _initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? _copySymbolsIn(value, _baseAssignIn(result, value))
          : _copySymbols(value, _baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = _initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new _Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet_1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_1(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? _getAllKeysIn : _getAllKeys)
    : (isFlat ? keysIn_1 : keys_1);

  var props = isArr ? undefined : keysFunc(value);
  _arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

var _baseClone = baseClone;

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG$1 = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return _baseClone(value, CLONE_SYMBOLS_FLAG$1);
}

var clone_1 = clone;

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var constant_1 = constant;

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

var _createBaseFor = createBaseFor;

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = _createBaseFor();

var _baseFor = baseFor;

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && _baseFor(object, iteratee, keys_1);
}

var _baseForOwn = baseForOwn;

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_1(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

var _createBaseEach = createBaseEach;

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = _createBaseEach(_baseForOwn);

var _baseEach = baseEach;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

var identity_1 = identity;

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity_1;
}

var _castFunction = castFunction;

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray_1(collection) ? _arrayEach : _baseEach;
  return func(collection, _castFunction(iteratee));
}

var forEach_1 = forEach;

var each$1 = forEach_1;

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  _baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

var _baseFilter = baseFilter;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);
  return this;
}

var _setCacheAdd = setCacheAdd;

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

var _setCacheHas = setCacheHas;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new _MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
SetCache.prototype.has = _setCacheHas;

var _SetCache = SetCache;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

var _arraySome = arraySome;

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

var _cacheHas = cacheHas;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!_arraySome(other, function(othValue, othIndex) {
            if (!_cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

var _equalArrays = equalArrays;

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

var _mapToArray = mapToArray;

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

var _setToArray = setToArray;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/** `Object#toString` result references. */
var boolTag$3 = '[object Boolean]',
    dateTag$3 = '[object Date]',
    errorTag$2 = '[object Error]',
    mapTag$5 = '[object Map]',
    numberTag$3 = '[object Number]',
    regexpTag$3 = '[object RegExp]',
    setTag$5 = '[object Set]',
    stringTag$3 = '[object String]',
    symbolTag$2 = '[object Symbol]';

var arrayBufferTag$3 = '[object ArrayBuffer]',
    dataViewTag$4 = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$4:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$3:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag$3:
    case dateTag$3:
    case numberTag$3:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq_1(+object, +other);

    case errorTag$2:
      return object.name == other.name && object.message == other.message;

    case regexpTag$3:
    case stringTag$3:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag$5:
      var convert = _mapToArray;

    case setTag$5:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = _setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$1;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag$2:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
      }
  }
  return false;
}

var _equalByTag = equalByTag;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1;

/** Used for built-in method references. */
var objectProto$d = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$b = objectProto$d.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
      objProps = _getAllKeys(object),
      objLength = objProps.length,
      othProps = _getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$b.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

var _equalObjects = equalObjects;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1;

/** `Object#toString` result references. */
var argsTag$3 = '[object Arguments]',
    arrayTag$2 = '[object Array]',
    objectTag$3 = '[object Object]';

/** Used for built-in method references. */
var objectProto$e = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$c = objectProto$e.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_1(object),
      othIsArr = isArray_1(other),
      objTag = objIsArr ? arrayTag$2 : _getTag(object),
      othTag = othIsArr ? arrayTag$2 : _getTag(other);

  objTag = objTag == argsTag$3 ? objectTag$3 : objTag;
  othTag = othTag == argsTag$3 ? objectTag$3 : othTag;

  var objIsObj = objTag == objectTag$3,
      othIsObj = othTag == objectTag$3,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer_1(object)) {
    if (!isBuffer_1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new _Stack);
    return (objIsArr || isTypedArray_1(object))
      ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$c.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$c.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new _Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new _Stack);
  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

var _baseIsEqualDeep = baseIsEqualDeep;

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
    return value !== value && other !== other;
  }
  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

var _baseIsEqual = baseIsEqual;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new _Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

var _baseIsMatch = baseIsMatch;

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject_1(value);
}

var _isStrictComparable = isStrictComparable;

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys_1(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, _isStrictComparable(value)];
  }
  return result;
}

var _getMatchData = getMatchData;

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

var _matchesStrictComparable = matchesStrictComparable;

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = _getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || _baseIsMatch(object, source, matchData);
  };
}

var _baseMatches = baseMatches;

/** `Object#toString` result references. */
var symbolTag$3 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$3);
}

var isSymbol_1 = isSymbol;

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray_1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol_1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

var _isKey = isKey;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || _MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = _MapCache;

var memoize_1 = memoize;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize_1(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

var _memoizeCapped = memoizeCapped;

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = _memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

var _stringToPath = stringToPath;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

var _arrayMap = arrayMap;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto$2 = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray_1(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return _arrayMap(value, baseToString) + '';
  }
  if (isSymbol_1(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

var _baseToString = baseToString;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString$1(value) {
  return value == null ? '' : _baseToString(value);
}

var toString_1 = toString$1;

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray_1(value)) {
    return value;
  }
  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
}

var _castPath = castPath;

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol_1(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

var _toKey = toKey;

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = _castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[_toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

var _baseGet = baseGet;

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : _baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

var get_1 = get;

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

var _baseHasIn = baseHasIn;

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = _castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = _toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_1(length) && _isIndex(key, length) &&
    (isArray_1(object) || isArguments_1(object));
}

var _hasPath = hasPath;

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && _hasPath(object, path, _baseHasIn);
}

var hasIn_1 = hasIn;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (_isKey(path) && _isStrictComparable(srcValue)) {
    return _matchesStrictComparable(_toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get_1(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn_1(object, path)
      : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
  };
}

var _baseMatchesProperty = baseMatchesProperty;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

var _baseProperty = baseProperty;

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return _baseGet(object, path);
  };
}

var _basePropertyDeep = basePropertyDeep;

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
}

var property_1 = property;

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity_1;
  }
  if (typeof value == 'object') {
    return isArray_1(value)
      ? _baseMatchesProperty(value[0], value[1])
      : _baseMatches(value);
  }
  return property_1(value);
}

var _baseIteratee = baseIteratee;

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 *
 * // Combining several predicates using `_.overEvery` or `_.overSome`.
 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
 * // => objects for ['fred', 'barney']
 */
function filter(collection, predicate) {
  var func = isArray_1(collection) ? _arrayFilter : _baseFilter;
  return func(collection, _baseIteratee(predicate));
}

var filter_1 = filter;

/** Used for built-in method references. */
var objectProto$f = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$d = objectProto$f.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty$d.call(object, key);
}

var _baseHas = baseHas;

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && _hasPath(object, path, _baseHas);
}

var has_1 = has;

/** `Object#toString` result references. */
var mapTag$6 = '[object Map]',
    setTag$6 = '[object Set]';

/** Used for built-in method references. */
var objectProto$g = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$e = objectProto$g.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike_1(value) &&
      (isArray_1(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer_1(value) || isTypedArray_1(value) || isArguments_1(value))) {
    return !value.length;
  }
  var tag = _getTag(value);
  if (tag == mapTag$6 || tag == setTag$6) {
    return !value.size;
  }
  if (_isPrototype(value)) {
    return !_baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty$e.call(value, key)) {
      return false;
    }
  }
  return true;
}

var isEmpty_1 = isEmpty;

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

var isUndefined_1 = isUndefined;

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike_1(collection) ? Array(collection.length) : [];

  _baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

var _baseMap = baseMap;

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray_1(collection) ? _arrayMap : _baseMap;
  return func(collection, _baseIteratee(iteratee));
}

var map_1 = map;

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

var _arrayReduce = arrayReduce;

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

var _baseReduce = baseReduce;

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = isArray_1(collection) ? _arrayReduce : _baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, _baseIteratee(iteratee), accumulator, initAccum, _baseEach);
}

var reduce_1 = reduce;

/** `Object#toString` result references. */
var stringTag$4 = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray_1(value) && isObjectLike_1(value) && _baseGetTag(value) == stringTag$4);
}

var isString_1 = isString;

/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
var asciiSize = _baseProperty('length');

var _asciiSize = asciiSize;

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

var _hasUnicode = hasUnicode;

/** Used to compose unicode character classes. */
var rsAstralRange$1 = '\\ud800-\\udfff',
    rsComboMarksRange$1 = '\\u0300-\\u036f',
    reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
    rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange$1 + ']',
    rsCombo = '[' + rsComboRange$1 + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange$1 + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ$1 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange$1 + ']?',
    rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}

var _unicodeSize = unicodeSize;

/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */
function stringSize(string) {
  return _hasUnicode(string)
    ? _unicodeSize(string)
    : _asciiSize(string);
}

var _stringSize = stringSize;

/** `Object#toString` result references. */
var mapTag$7 = '[object Map]',
    setTag$7 = '[object Set]';

/**
 * Gets the size of `collection` by returning its length for array-like
 * values or the number of own enumerable string keyed properties for objects.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @returns {number} Returns the collection size.
 * @example
 *
 * _.size([1, 2, 3]);
 * // => 3
 *
 * _.size({ 'a': 1, 'b': 2 });
 * // => 2
 *
 * _.size('pebbles');
 * // => 7
 */
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike_1(collection)) {
    return isString_1(collection) ? _stringSize(collection) : collection.length;
  }
  var tag = _getTag(collection);
  if (tag == mapTag$7 || tag == setTag$7) {
    return collection.size;
  }
  return _baseKeys(collection).length;
}

var size_1 = size;

/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own
 * enumerable string keyed properties thru `iteratee`, with each invocation
 * potentially mutating the `accumulator` object. If `accumulator` is not
 * provided, a new object with the same `[[Prototype]]` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * }, []);
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */
function transform(object, iteratee, accumulator) {
  var isArr = isArray_1(object),
      isArrLike = isArr || isBuffer_1(object) || isTypedArray_1(object);

  iteratee = _baseIteratee(iteratee);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor : [];
    }
    else if (isObject_1(object)) {
      accumulator = isFunction_1(Ctor) ? _baseCreate(_getPrototype(object)) : {};
    }
    else {
      accumulator = {};
    }
  }
  (isArrLike ? _arrayEach : _baseForOwn)(object, function(value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

var transform_1 = transform;

/** Built-in value references. */
var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray_1(value) || isArguments_1(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

var _isFlattenable = isFlattenable;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = _isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        _arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

var _baseFlatten = baseFlatten;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

var _apply = apply;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return _apply(func, this, otherArgs);
  };
}

var _overRest = overRest;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !_defineProperty ? identity_1 : function(func, string) {
  return _defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant_1(string),
    'writable': true
  });
};

var _baseSetToString = baseSetToString;

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

var _shortOut = shortOut;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = _shortOut(_baseSetToString);

var _setToString = setToString;

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return _setToString(_overRest(func, start, identity_1), func + '');
}

var _baseRest = baseRest;

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

var _baseFindIndex = baseFindIndex;

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

var _baseIsNaN = baseIsNaN;

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

var _strictIndexOf = strictIndexOf;

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? _strictIndexOf(array, value, fromIndex)
    : _baseFindIndex(array, _baseIsNaN, fromIndex);
}

var _baseIndexOf = baseIndexOf;

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && _baseIndexOf(array, value, 0) > -1;
}

var _arrayIncludes = arrayIncludes;

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

var _arrayIncludesWith = arrayIncludesWith;

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

var noop_1 = noop;

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(_Set && (1 / _setToArray(new _Set([,-0]))[1]) == INFINITY$2) ? noop_1 : function(values) {
  return new _Set(values);
};

var _createSet = createSet;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$1 = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = _arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = _arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE$1) {
    var set = iteratee ? null : _createSet(array);
    if (set) {
      return _setToArray(set);
    }
    isCommon = false;
    includes = _cacheHas;
    seen = new _SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

var _baseUniq = baseUniq;

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike_1(value) && isArrayLike_1(value);
}

var isArrayLikeObject_1 = isArrayLikeObject;

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = _baseRest(function(arrays) {
  return _baseUniq(_baseFlatten(arrays, 1, isArrayLikeObject_1, true));
});

var union_1 = union;

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return _arrayMap(props, function(key) {
    return object[key];
  });
}

var _baseValues = baseValues;

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : _baseValues(object, keys_1(object));
}

var values_1 = values;

/* global window */

var lodash;

if (typeof commonjsRequire === "function") {
  try {
    lodash = {
      clone: clone_1,
      constant: constant_1,
      each: each$1,
      filter: filter_1,
      has:  has_1,
      isArray: isArray_1,
      isEmpty: isEmpty_1,
      isFunction: isFunction_1,
      isUndefined: isUndefined_1,
      keys: keys_1,
      map: map_1,
      reduce: reduce_1,
      size: size_1,
      transform: transform_1,
      union: union_1,
      values: values_1
    };
  } catch (e) {
    // continue regardless of error
  }
}

if (!lodash) {
  lodash = window._;
}

var lodash_1 = lodash;

var graph = Graph;

var DEFAULT_EDGE_NAME = "\x00";
var GRAPH_NODE = "\x00";
var EDGE_KEY_DELIM = "\x01";

// Implementation notes:
//
//  * Node id query functions should return string ids for the nodes
//  * Edge id query functions should return an "edgeObj", edge object, that is
//    composed of enough information to uniquely identify an edge: {v, w, name}.
//  * Internally we use an "edgeId", a stringified form of the edgeObj, to
//    reference edges. This is because we need a performant way to look these
//    edges up and, object properties, which have string keys, are the closest
//    we're going to get to a performant hashtable in JavaScript.

function Graph(opts) {
  this._isDirected = lodash_1.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = lodash_1.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = lodash_1.has(opts, "compound") ? opts.compound : false;

  // Label for the graph itself
  this._label = undefined;

  // Defaults to be set when creating a new node
  this._defaultNodeLabelFn = lodash_1.constant(undefined);

  // Defaults to be set when creating a new edge
  this._defaultEdgeLabelFn = lodash_1.constant(undefined);

  // v -> label
  this._nodes = {};

  if (this._isCompound) {
    // v -> parent
    this._parent = {};

    // v -> children
    this._children = {};
    this._children[GRAPH_NODE] = {};
  }

  // v -> edgeObj
  this._in = {};

  // u -> v -> Number
  this._preds = {};

  // v -> edgeObj
  this._out = {};

  // v -> w -> Number
  this._sucs = {};

  // e -> edgeObj
  this._edgeObjs = {};

  // e -> label
  this._edgeLabels = {};
}

/* Number of nodes in the graph. Should only be changed by the implementation. */
Graph.prototype._nodeCount = 0;

/* Number of edges in the graph. Should only be changed by the implementation. */
Graph.prototype._edgeCount = 0;


/* === Graph functions ========= */

Graph.prototype.isDirected = function() {
  return this._isDirected;
};

Graph.prototype.isMultigraph = function() {
  return this._isMultigraph;
};

Graph.prototype.isCompound = function() {
  return this._isCompound;
};

Graph.prototype.setGraph = function(label) {
  this._label = label;
  return this;
};

Graph.prototype.graph = function() {
  return this._label;
};


/* === Node functions ========== */

Graph.prototype.setDefaultNodeLabel = function(newDefault) {
  if (!lodash_1.isFunction(newDefault)) {
    newDefault = lodash_1.constant(newDefault);
  }
  this._defaultNodeLabelFn = newDefault;
  return this;
};

Graph.prototype.nodeCount = function() {
  return this._nodeCount;
};

Graph.prototype.nodes = function() {
  return lodash_1.keys(this._nodes);
};

Graph.prototype.sources = function() {
  var self = this;
  return lodash_1.filter(this.nodes(), function(v) {
    return lodash_1.isEmpty(self._in[v]);
  });
};

Graph.prototype.sinks = function() {
  var self = this;
  return lodash_1.filter(this.nodes(), function(v) {
    return lodash_1.isEmpty(self._out[v]);
  });
};

Graph.prototype.setNodes = function(vs, value) {
  var args = arguments;
  var self = this;
  lodash_1.each(vs, function(v) {
    if (args.length > 1) {
      self.setNode(v, value);
    } else {
      self.setNode(v);
    }
  });
  return this;
};

Graph.prototype.setNode = function(v, value) {
  if (lodash_1.has(this._nodes, v)) {
    if (arguments.length > 1) {
      this._nodes[v] = value;
    }
    return this;
  }

  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
  if (this._isCompound) {
    this._parent[v] = GRAPH_NODE;
    this._children[v] = {};
    this._children[GRAPH_NODE][v] = true;
  }
  this._in[v] = {};
  this._preds[v] = {};
  this._out[v] = {};
  this._sucs[v] = {};
  ++this._nodeCount;
  return this;
};

Graph.prototype.node = function(v) {
  return this._nodes[v];
};

Graph.prototype.hasNode = function(v) {
  return lodash_1.has(this._nodes, v);
};

Graph.prototype.removeNode =  function(v) {
  var self = this;
  if (lodash_1.has(this._nodes, v)) {
    var removeEdge = function(e) { self.removeEdge(self._edgeObjs[e]); };
    delete this._nodes[v];
    if (this._isCompound) {
      this._removeFromParentsChildList(v);
      delete this._parent[v];
      lodash_1.each(this.children(v), function(child) {
        self.setParent(child);
      });
      delete this._children[v];
    }
    lodash_1.each(lodash_1.keys(this._in[v]), removeEdge);
    delete this._in[v];
    delete this._preds[v];
    lodash_1.each(lodash_1.keys(this._out[v]), removeEdge);
    delete this._out[v];
    delete this._sucs[v];
    --this._nodeCount;
  }
  return this;
};

Graph.prototype.setParent = function(v, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }

  if (lodash_1.isUndefined(parent)) {
    parent = GRAPH_NODE;
  } else {
    // Coerce parent to string
    parent += "";
    for (var ancestor = parent;
      !lodash_1.isUndefined(ancestor);
      ancestor = this.parent(ancestor)) {
      if (ancestor === v) {
        throw new Error("Setting " + parent+ " as parent of " + v +
                        " would create a cycle");
      }
    }

    this.setNode(parent);
  }

  this.setNode(v);
  this._removeFromParentsChildList(v);
  this._parent[v] = parent;
  this._children[parent][v] = true;
  return this;
};

Graph.prototype._removeFromParentsChildList = function(v) {
  delete this._children[this._parent[v]][v];
};

Graph.prototype.parent = function(v) {
  if (this._isCompound) {
    var parent = this._parent[v];
    if (parent !== GRAPH_NODE) {
      return parent;
    }
  }
};

Graph.prototype.children = function(v) {
  if (lodash_1.isUndefined(v)) {
    v = GRAPH_NODE;
  }

  if (this._isCompound) {
    var children = this._children[v];
    if (children) {
      return lodash_1.keys(children);
    }
  } else if (v === GRAPH_NODE) {
    return this.nodes();
  } else if (this.hasNode(v)) {
    return [];
  }
};

Graph.prototype.predecessors = function(v) {
  var predsV = this._preds[v];
  if (predsV) {
    return lodash_1.keys(predsV);
  }
};

Graph.prototype.successors = function(v) {
  var sucsV = this._sucs[v];
  if (sucsV) {
    return lodash_1.keys(sucsV);
  }
};

Graph.prototype.neighbors = function(v) {
  var preds = this.predecessors(v);
  if (preds) {
    return lodash_1.union(preds, this.successors(v));
  }
};

Graph.prototype.isLeaf = function (v) {
  var neighbors;
  if (this.isDirected()) {
    neighbors = this.successors(v);
  } else {
    neighbors = this.neighbors(v);
  }
  return neighbors.length === 0;
};

Graph.prototype.filterNodes = function(filter) {
  var copy = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });

  copy.setGraph(this.graph());

  var self = this;
  lodash_1.each(this._nodes, function(value, v) {
    if (filter(v)) {
      copy.setNode(v, value);
    }
  });

  lodash_1.each(this._edgeObjs, function(e) {
    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
      copy.setEdge(e, self.edge(e));
    }
  });

  var parents = {};
  function findParent(v) {
    var parent = self.parent(v);
    if (parent === undefined || copy.hasNode(parent)) {
      parents[v] = parent;
      return parent;
    } else if (parent in parents) {
      return parents[parent];
    } else {
      return findParent(parent);
    }
  }

  if (this._isCompound) {
    lodash_1.each(copy.nodes(), function(v) {
      copy.setParent(v, findParent(v));
    });
  }

  return copy;
};

/* === Edge functions ========== */

Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
  if (!lodash_1.isFunction(newDefault)) {
    newDefault = lodash_1.constant(newDefault);
  }
  this._defaultEdgeLabelFn = newDefault;
  return this;
};

Graph.prototype.edgeCount = function() {
  return this._edgeCount;
};

Graph.prototype.edges = function() {
  return lodash_1.values(this._edgeObjs);
};

Graph.prototype.setPath = function(vs, value) {
  var self = this;
  var args = arguments;
  lodash_1.reduce(vs, function(v, w) {
    if (args.length > 1) {
      self.setEdge(v, w, value);
    } else {
      self.setEdge(v, w);
    }
    return w;
  });
  return this;
};

/*
 * setEdge(v, w, [value, [name]])
 * setEdge({ v, w, [name] }, [value])
 */
Graph.prototype.setEdge = function() {
  var v, w, name, value;
  var valueSpecified = false;
  var arg0 = arguments[0];

  if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
    v = arg0.v;
    w = arg0.w;
    name = arg0.name;
    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v = arg0;
    w = arguments[1];
    name = arguments[3];
    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }

  v = "" + v;
  w = "" + w;
  if (!lodash_1.isUndefined(name)) {
    name = "" + name;
  }

  var e = edgeArgsToId(this._isDirected, v, w, name);
  if (lodash_1.has(this._edgeLabels, e)) {
    if (valueSpecified) {
      this._edgeLabels[e] = value;
    }
    return this;
  }

  if (!lodash_1.isUndefined(name) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  }

  // It didn't exist, so we need to create it.
  // First ensure the nodes exist.
  this.setNode(v);
  this.setNode(w);

  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);

  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
  // Ensure we add undirected edges in a consistent way.
  v = edgeObj.v;
  w = edgeObj.w;

  Object.freeze(edgeObj);
  this._edgeObjs[e] = edgeObj;
  incrementOrInitEntry(this._preds[w], v);
  incrementOrInitEntry(this._sucs[v], w);
  this._in[w][e] = edgeObj;
  this._out[v][e] = edgeObj;
  this._edgeCount++;
  return this;
};

Graph.prototype.edge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  return this._edgeLabels[e];
};

Graph.prototype.hasEdge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  return lodash_1.has(this._edgeLabels, e);
};

Graph.prototype.removeEdge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  var edge = this._edgeObjs[e];
  if (edge) {
    v = edge.v;
    w = edge.w;
    delete this._edgeLabels[e];
    delete this._edgeObjs[e];
    decrementOrRemoveEntry(this._preds[w], v);
    decrementOrRemoveEntry(this._sucs[v], w);
    delete this._in[w][e];
    delete this._out[v][e];
    this._edgeCount--;
  }
  return this;
};

Graph.prototype.inEdges = function(v, u) {
  var inV = this._in[v];
  if (inV) {
    var edges = lodash_1.values(inV);
    if (!u) {
      return edges;
    }
    return lodash_1.filter(edges, function(edge) { return edge.v === u; });
  }
};

Graph.prototype.outEdges = function(v, w) {
  var outV = this._out[v];
  if (outV) {
    var edges = lodash_1.values(outV);
    if (!w) {
      return edges;
    }
    return lodash_1.filter(edges, function(edge) { return edge.w === w; });
  }
};

Graph.prototype.nodeEdges = function(v, w) {
  var inEdges = this.inEdges(v, w);
  if (inEdges) {
    return inEdges.concat(this.outEdges(v, w));
  }
};

function incrementOrInitEntry(map, k) {
  if (map[k]) {
    map[k]++;
  } else {
    map[k] = 1;
  }
}

function decrementOrRemoveEntry(map, k) {
  if (!--map[k]) { delete map[k]; }
}

function edgeArgsToId(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +
             (lodash_1.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
}

function edgeArgsToObj(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  var edgeObj =  { v: v, w: w };
  if (name) {
    edgeObj.name = name;
  }
  return edgeObj;
}

function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}

var version = '2.1.8';

// Includes only the "core" of graphlib
var lib = {
  Graph: graph,
  version: version
};

var json = {
  write: write,
  read: read
};

function write(g) {
  var json = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound()
    },
    nodes: writeNodes(g),
    edges: writeEdges(g)
  };
  if (!lodash_1.isUndefined(g.graph())) {
    json.value = lodash_1.clone(g.graph());
  }
  return json;
}

function writeNodes(g) {
  return lodash_1.map(g.nodes(), function(v) {
    var nodeValue = g.node(v);
    var parent = g.parent(v);
    var node = { v: v };
    if (!lodash_1.isUndefined(nodeValue)) {
      node.value = nodeValue;
    }
    if (!lodash_1.isUndefined(parent)) {
      node.parent = parent;
    }
    return node;
  });
}

function writeEdges(g) {
  return lodash_1.map(g.edges(), function(e) {
    var edgeValue = g.edge(e);
    var edge = { v: e.v, w: e.w };
    if (!lodash_1.isUndefined(e.name)) {
      edge.name = e.name;
    }
    if (!lodash_1.isUndefined(edgeValue)) {
      edge.value = edgeValue;
    }
    return edge;
  });
}

function read(json) {
  var g = new graph(json.options).setGraph(json.value);
  lodash_1.each(json.nodes, function(entry) {
    g.setNode(entry.v, entry.value);
    if (entry.parent) {
      g.setParent(entry.v, entry.parent);
    }
  });
  lodash_1.each(json.edges, function(entry) {
    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
  });
  return g;
}

var components_1 = components;

function components(g) {
  var visited = {};
  var cmpts = [];
  var cmpt;

  function dfs(v) {
    if (lodash_1.has(visited, v)) return;
    visited[v] = true;
    cmpt.push(v);
    lodash_1.each(g.successors(v), dfs);
    lodash_1.each(g.predecessors(v), dfs);
  }

  lodash_1.each(g.nodes(), function(v) {
    cmpt = [];
    dfs(v);
    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });

  return cmpts;
}

var priorityQueue = PriorityQueue;

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., "Introduction to Algorithms". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
function PriorityQueue() {
  this._arr = [];
  this._keyIndices = {};
}

/**
 * Returns the number of elements in the queue. Takes `O(1)` time.
 */
PriorityQueue.prototype.size = function() {
  return this._arr.length;
};

/**
 * Returns the keys that are in the queue. Takes `O(n)` time.
 */
PriorityQueue.prototype.keys = function() {
  return this._arr.map(function(x) { return x.key; });
};

/**
 * Returns `true` if **key** is in the queue and `false` if not.
 */
PriorityQueue.prototype.has = function(key) {
  return lodash_1.has(this._keyIndices, key);
};

/**
 * Returns the priority for **key**. If **key** is not present in the queue
 * then this function returns `undefined`. Takes `O(1)` time.
 *
 * @param {Object} key
 */
PriorityQueue.prototype.priority = function(key) {
  var index = this._keyIndices[key];
  if (index !== undefined) {
    return this._arr[index].priority;
  }
};

/**
 * Returns the key for the minimum element in this queue. If the queue is
 * empty this function throws an Error. Takes `O(1)` time.
 */
PriorityQueue.prototype.min = function() {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }
  return this._arr[0].key;
};

/**
 * Inserts a new key into the priority queue. If the key already exists in
 * the queue this function returns `false`; otherwise it will return `true`.
 * Takes `O(n)` time.
 *
 * @param {Object} key the key to add
 * @param {Number} priority the initial priority for the key
 */
PriorityQueue.prototype.add = function(key, priority) {
  var keyIndices = this._keyIndices;
  key = String(key);
  if (!lodash_1.has(keyIndices, key)) {
    var arr = this._arr;
    var index = arr.length;
    keyIndices[key] = index;
    arr.push({key: key, priority: priority});
    this._decrease(index);
    return true;
  }
  return false;
};

/**
 * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
 */
PriorityQueue.prototype.removeMin = function() {
  this._swap(0, this._arr.length - 1);
  var min = this._arr.pop();
  delete this._keyIndices[min.key];
  this._heapify(0);
  return min.key;
};

/**
 * Decreases the priority for **key** to **priority**. If the new priority is
 * greater than the previous priority, this function will throw an Error.
 *
 * @param {Object} key the key for which to raise priority
 * @param {Number} priority the new priority for the key
 */
PriorityQueue.prototype.decrease = function(key, priority) {
  var index = this._keyIndices[key];
  if (priority > this._arr[index].priority) {
    throw new Error("New priority is greater than current priority. " +
        "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
  }
  this._arr[index].priority = priority;
  this._decrease(index);
};

PriorityQueue.prototype._heapify = function(i) {
  var arr = this._arr;
  var l = 2 * i;
  var r = l + 1;
  var largest = i;
  if (l < arr.length) {
    largest = arr[l].priority < arr[largest].priority ? l : largest;
    if (r < arr.length) {
      largest = arr[r].priority < arr[largest].priority ? r : largest;
    }
    if (largest !== i) {
      this._swap(i, largest);
      this._heapify(largest);
    }
  }
};

PriorityQueue.prototype._decrease = function(index) {
  var arr = this._arr;
  var priority = arr[index].priority;
  var parent;
  while (index !== 0) {
    parent = index >> 1;
    if (arr[parent].priority < priority) {
      break;
    }
    this._swap(index, parent);
    index = parent;
  }
};

PriorityQueue.prototype._swap = function(i, j) {
  var arr = this._arr;
  var keyIndices = this._keyIndices;
  var origArrI = arr[i];
  var origArrJ = arr[j];
  arr[i] = origArrJ;
  arr[j] = origArrI;
  keyIndices[origArrJ.key] = i;
  keyIndices[origArrI.key] = j;
};

var dijkstra_1 = dijkstra;

var DEFAULT_WEIGHT_FUNC = lodash_1.constant(1);

function dijkstra(g, source, weightFn, edgeFn) {
  return runDijkstra(g, String(source),
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) { return g.outEdges(v); });
}

function runDijkstra(g, source, weightFn, edgeFn) {
  var results = {};
  var pq = new priorityQueue();
  var v, vEntry;

  var updateNeighbors = function(edge) {
    var w = edge.v !== v ? edge.v : edge.w;
    var wEntry = results[w];
    var weight = weightFn(edge);
    var distance = vEntry.distance + weight;

    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. " +
                      "Bad edge: " + edge + " Weight: " + weight);
    }

    if (distance < wEntry.distance) {
      wEntry.distance = distance;
      wEntry.predecessor = v;
      pq.decrease(w, distance);
    }
  };

  g.nodes().forEach(function(v) {
    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
    results[v] = { distance: distance };
    pq.add(v, distance);
  });

  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];
    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }

    edgeFn(v).forEach(updateNeighbors);
  }

  return results;
}

var dijkstraAll_1 = dijkstraAll;

function dijkstraAll(g, weightFunc, edgeFunc) {
  return lodash_1.transform(g.nodes(), function(acc, v) {
    acc[v] = dijkstra_1(g, v, weightFunc, edgeFunc);
  }, {});
}

var tarjan_1 = tarjan;

function tarjan(g) {
  var index = 0;
  var stack = [];
  var visited = {}; // node id -> { onStack, lowlink, index }
  var results = [];

  function dfs(v) {
    var entry = visited[v] = {
      onStack: true,
      lowlink: index,
      index: index++
    };
    stack.push(v);

    g.successors(v).forEach(function(w) {
      if (!lodash_1.has(visited, w)) {
        dfs(w);
        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
      } else if (visited[w].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
      }
    });

    if (entry.lowlink === entry.index) {
      var cmpt = [];
      var w;
      do {
        w = stack.pop();
        visited[w].onStack = false;
        cmpt.push(w);
      } while (v !== w);
      results.push(cmpt);
    }
  }

  g.nodes().forEach(function(v) {
    if (!lodash_1.has(visited, v)) {
      dfs(v);
    }
  });

  return results;
}

var findCycles_1 = findCycles;

function findCycles(g) {
  return lodash_1.filter(tarjan_1(g), function(cmpt) {
    return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));
  });
}

var floydWarshall_1 = floydWarshall;

var DEFAULT_WEIGHT_FUNC$1 = lodash_1.constant(1);

function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(g,
    weightFn || DEFAULT_WEIGHT_FUNC$1,
    edgeFn || function(v) { return g.outEdges(v); });
}

function runFloydWarshall(g, weightFn, edgeFn) {
  var results = {};
  var nodes = g.nodes();

  nodes.forEach(function(v) {
    results[v] = {};
    results[v][v] = { distance: 0 };
    nodes.forEach(function(w) {
      if (v !== w) {
        results[v][w] = { distance: Number.POSITIVE_INFINITY };
      }
    });
    edgeFn(v).forEach(function(edge) {
      var w = edge.v === v ? edge.w : edge.v;
      var d = weightFn(edge);
      results[v][w] = { distance: d, predecessor: v };
    });
  });

  nodes.forEach(function(k) {
    var rowK = results[k];
    nodes.forEach(function(i) {
      var rowI = results[i];
      nodes.forEach(function(j) {
        var ik = rowI[k];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });

  return results;
}

var topsort_1 = topsort;
topsort.CycleException = CycleException;

function topsort(g) {
  var visited = {};
  var stack = {};
  var results = [];

  function visit(node) {
    if (lodash_1.has(stack, node)) {
      throw new CycleException();
    }

    if (!lodash_1.has(visited, node)) {
      stack[node] = true;
      visited[node] = true;
      lodash_1.each(g.predecessors(node), visit);
      delete stack[node];
      results.push(node);
    }
  }

  lodash_1.each(g.sinks(), visit);

  if (lodash_1.size(visited) !== g.nodeCount()) {
    throw new CycleException();
  }

  return results;
}

function CycleException() {}
CycleException.prototype = new Error(); // must be an instance of Error to pass testing

var isAcyclic_1 = isAcyclic;

function isAcyclic(g) {
  try {
    topsort_1(g);
  } catch (e) {
    if (e instanceof topsort_1.CycleException) {
      return false;
    }
    throw e;
  }
  return true;
}

var dfs_1 = dfs;

/*
 * A helper that preforms a pre- or post-order traversal on the input graph
 * and returns the nodes in the order they were visited. If the graph is
 * undirected then this algorithm will navigate using neighbors. If the graph
 * is directed then this algorithm will navigate using successors.
 *
 * Order must be one of "pre" or "post".
 */
function dfs(g, vs, order) {
  if (!lodash_1.isArray(vs)) {
    vs = [vs];
  }

  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);

  var acc = [];
  var visited = {};
  lodash_1.each(vs, function(v) {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }

    doDfs(g, v, order === "post", visited, navigation, acc);
  });
  return acc;
}

function doDfs(g, v, postorder, visited, navigation, acc) {
  if (!lodash_1.has(visited, v)) {
    visited[v] = true;

    if (!postorder) { acc.push(v); }
    lodash_1.each(navigation(v), function(w) {
      doDfs(g, w, postorder, visited, navigation, acc);
    });
    if (postorder) { acc.push(v); }
  }
}

var postorder_1 = postorder;

function postorder(g, vs) {
  return dfs_1(g, vs, "post");
}

var preorder_1 = preorder;

function preorder(g, vs) {
  return dfs_1(g, vs, "pre");
}

var prim_1 = prim;

function prim(g, weightFunc) {
  var result = new graph();
  var parents = {};
  var pq = new priorityQueue();
  var v;

  function updateNeighbors(edge) {
    var w = edge.v === v ? edge.w : edge.v;
    var pri = pq.priority(w);
    if (pri !== undefined) {
      var edgeWeight = weightFunc(edge);
      if (edgeWeight < pri) {
        parents[w] = v;
        pq.decrease(w, edgeWeight);
      }
    }
  }

  if (g.nodeCount() === 0) {
    return result;
  }

  lodash_1.each(g.nodes(), function(v) {
    pq.add(v, Number.POSITIVE_INFINITY);
    result.setNode(v);
  });

  // Start from an arbitrary node
  pq.decrease(g.nodes()[0], 0);

  var init = false;
  while (pq.size() > 0) {
    v = pq.removeMin();
    if (lodash_1.has(parents, v)) {
      result.setEdge(v, parents[v]);
    } else if (init) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init = true;
    }

    g.nodeEdges(v).forEach(updateNeighbors);
  }

  return result;
}

var alg = {
  components: components_1,
  dijkstra: dijkstra_1,
  dijkstraAll: dijkstraAll_1,
  findCycles: findCycles_1,
  floydWarshall: floydWarshall_1,
  isAcyclic: isAcyclic_1,
  postorder: postorder_1,
  preorder: preorder_1,
  prim: prim_1,
  tarjan: tarjan_1,
  topsort: topsort_1
};

/**
 * Copyright (c) 2014, Chris Pettitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



var _graphlib_2_1_8_graphlib = {
  Graph: lib.Graph,
  json: json,
  alg: alg,
  version: lib.version
};

/* global window */

var graphlib;

if (typeof commonjsRequire === "function") {
  try {
    graphlib = _graphlib_2_1_8_graphlib;
  } catch (e) {
    // continue regardless of error
  }
}

if (!graphlib) {
  graphlib = window.graphlib;
}

var graphlib_1 = graphlib;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1,
    CLONE_SYMBOLS_FLAG$2 = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$2);
}

var cloneDeep_1 = cloneDeep;

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject_1(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike_1(object) && _isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq_1(object[index], value);
  }
  return false;
}

var _isIterateeCall = isIterateeCall;

/** Used for built-in method references. */
var objectProto$h = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$f = objectProto$h.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = _baseRest(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn_1(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq_1(value, objectProto$h[key]) && !hasOwnProperty$f.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

var defaults_1 = defaults;

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike_1(collection)) {
      var iteratee = _baseIteratee(predicate);
      collection = keys_1(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

var _createFind = createFind;

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

var _trimmedEndIndex = trimmedEndIndex;

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

var _baseTrim = baseTrim;

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol_1(value)) {
    return NAN;
  }
  if (isObject_1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject_1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = _baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var toNumber_1 = toNumber;

/** Used as references for various `Number` constants. */
var INFINITY$3 = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_1(value);
  if (value === INFINITY$3 || value === -INFINITY$3) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

var toFinite_1 = toFinite;

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite_1(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

var toInteger_1 = toInteger;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$1 = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger_1(fromIndex);
  if (index < 0) {
    index = nativeMax$1(length + index, 0);
  }
  return _baseFindIndex(array, _baseIteratee(predicate), index);
}

var findIndex_1 = findIndex;

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = _createFind(findIndex_1);

var find_1 = find;

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? _baseFlatten(array, 1) : [];
}

var flatten_1 = flatten$1;

/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */
function forIn(object, iteratee) {
  return object == null
    ? object
    : _baseFor(object, _castFunction(iteratee), keysIn_1);
}

var forIn_1 = forIn;

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

var last_1 = last;

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = _baseIteratee(iteratee);

  _baseForOwn(object, function(value, key, object) {
    _baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

var mapValues_1 = mapValues;

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol_1(current))
          : comparator(current, computed)
        )) {
      var computed = current,
          result = value;
    }
  }
  return result;
}

var _baseExtremum = baseExtremum;

/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt(value, other) {
  return value > other;
}

var _baseGt = baseGt;

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return (array && array.length)
    ? _baseExtremum(array, identity_1, _baseGt)
    : undefined;
}

var max_1 = max;

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq_1(object[key], value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

var _assignMergeValue = assignMergeValue;

/** `Object#toString` result references. */
var objectTag$4 = '[object Object]';

/** Used for built-in method references. */
var funcProto$2 = Function.prototype,
    objectProto$i = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$g = objectProto$i.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString$2.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$4) {
    return false;
  }
  var proto = _getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$g.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString$2.call(Ctor) == objectCtorString;
}

var isPlainObject_1 = isPlainObject;

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

var _safeGet = safeGet;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return _copyObject(value, keysIn_1(value));
}

var toPlainObject_1 = toPlainObject;

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = _safeGet(object, key),
      srcValue = _safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    _assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray_1(srcValue),
        isBuff = !isArr && isBuffer_1(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_1(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject_1(objValue)) {
        newValue = _copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = _cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = _cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
      newValue = objValue;
      if (isArguments_1(objValue)) {
        newValue = toPlainObject_1(objValue);
      }
      else if (!isObject_1(objValue) || isFunction_1(objValue)) {
        newValue = _initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  _assignMergeValue(object, key, newValue);
}

var _baseMergeDeep = baseMergeDeep;

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  _baseFor(source, function(srcValue, key) {
    stack || (stack = new _Stack);
    if (isObject_1(srcValue)) {
      _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      _assignMergeValue(object, key, newValue);
    }
  }, keysIn_1);
}

var _baseMerge = baseMerge;

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return _baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

var _createAssigner = createAssigner;

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = _createAssigner(function(object, source, srcIndex) {
  _baseMerge(object, source, srcIndex);
});

var merge_1 = merge;

/**
 * The base implementation of `_.lt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than `other`,
 *  else `false`.
 */
function baseLt(value, other) {
  return value < other;
}

var _baseLt = baseLt;

/**
 * Computes the minimum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * _.min([4, 2, 8, 6]);
 * // => 2
 *
 * _.min([]);
 * // => undefined
 */
function min(array) {
  return (array && array.length)
    ? _baseExtremum(array, identity_1, _baseLt)
    : undefined;
}

var min_1 = min;

/**
 * This method is like `_.min` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * _.minBy(objects, function(o) { return o.n; });
 * // => { 'n': 1 }
 *
 * // The `_.property` iteratee shorthand.
 * _.minBy(objects, 'n');
 * // => { 'n': 1 }
 */
function minBy(array, iteratee) {
  return (array && array.length)
    ? _baseExtremum(array, _baseIteratee(iteratee), _baseLt)
    : undefined;
}

var minBy_1 = minBy;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now$2 = function() {
  return _root.Date.now();
};

var now_1 = now$2;

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject_1(object)) {
    return object;
  }
  path = _castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = _toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject_1(objValue)
          ? objValue
          : (_isIndex(path[index + 1]) ? [] : {});
      }
    }
    _assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

var _baseSet = baseSet;

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = _baseGet(object, path);

    if (predicate(value, path)) {
      _baseSet(result, _castPath(path, object), value);
    }
  }
  return result;
}

var _basePickBy = basePickBy;

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return _basePickBy(object, paths, function(value, path) {
    return hasIn_1(object, path);
  });
}

var _basePick = basePick;

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return _setToString(_overRest(func, undefined, flatten_1), func + '');
}

var _flatRest = flatRest;

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = _flatRest(function(object, paths) {
  return object == null ? {} : _basePick(object, paths);
});

var pick_1 = pick;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax$2 = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax$2(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

var _baseRange = baseRange;

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && _isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite_1(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite_1(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite_1(step);
    return _baseRange(start, end, step, fromRight);
  };
}

var _createRange = createRange;

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = _createRange();

var range_1 = range;

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

var _baseSortBy = baseSortBy;

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol_1(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol_1(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

var _compareAscending = compareAscending;

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = _compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

var _compareMultiple = compareMultiple;

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = _arrayMap(iteratees, function(iteratee) {
      if (isArray_1(iteratee)) {
        return function(value) {
          return _baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        }
      }
      return iteratee;
    });
  } else {
    iteratees = [identity_1];
  }

  var index = -1;
  iteratees = _arrayMap(iteratees, _baseUnary(_baseIteratee));

  var result = _baseMap(collection, function(value, key, collection) {
    var criteria = _arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return _baseSortBy(result, function(object, other) {
    return _compareMultiple(object, other, orders);
  });
}

var _baseOrderBy = baseOrderBy;

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */
var sortBy = _baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && _isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && _isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return _baseOrderBy(collection, _baseFlatten(iteratees, 1), []);
});

var sortBy_1 = sortBy;

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString_1(prefix) + id;
}

var uniqueId_1 = uniqueId;

/**
 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
 *
 * @private
 * @param {Array} props The property identifiers.
 * @param {Array} values The property values.
 * @param {Function} assignFunc The function to assign values.
 * @returns {Object} Returns the new object.
 */
function baseZipObject(props, values, assignFunc) {
  var index = -1,
      length = props.length,
      valsLength = values.length,
      result = {};

  while (++index < length) {
    var value = index < valsLength ? values[index] : undefined;
    assignFunc(result, props[index], value);
  }
  return result;
}

var _baseZipObject = baseZipObject;

/**
 * This method is like `_.fromPairs` except that it accepts two arrays,
 * one of property identifiers and one of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 0.4.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.zipObject(['a', 'b'], [1, 2]);
 * // => { 'a': 1, 'b': 2 }
 */
function zipObject(props, values) {
  return _baseZipObject(props || [], values || [], _assignValue);
}

var zipObject_1 = zipObject;

/* global window */

var lodash$1;

if (typeof commonjsRequire === "function") {
  try {
    lodash$1 = {
      cloneDeep: cloneDeep_1,
      constant: constant_1,
      defaults: defaults_1,
      each: each$1,
      filter: filter_1,
      find: find_1,
      flatten: flatten_1,
      forEach: forEach_1,
      forIn: forIn_1,
      has:  has_1,
      isUndefined: isUndefined_1,
      last: last_1,
      map: map_1,
      mapValues: mapValues_1,
      max: max_1,
      merge: merge_1,
      min: min_1,
      minBy: minBy_1,
      now: now_1,
      pick: pick_1,
      range: range_1,
      reduce: reduce_1,
      sortBy: sortBy_1,
      uniqueId: uniqueId_1,
      values: values_1,
      zipObject: zipObject_1,
    };
  } catch (e) {
    // continue regardless of error
  }
}

if (!lodash$1) {
  lodash$1 = window._;
}

var lodash_1$1 = lodash$1;

/*
 * Simple doubly linked list implementation derived from Cormen, et al.,
 * "Introduction to Algorithms".
 */

var list = List;

function List() {
  var sentinel = {};
  sentinel._next = sentinel._prev = sentinel;
  this._sentinel = sentinel;
}

List.prototype.dequeue = function() {
  var sentinel = this._sentinel;
  var entry = sentinel._prev;
  if (entry !== sentinel) {
    unlink(entry);
    return entry;
  }
};

List.prototype.enqueue = function(entry) {
  var sentinel = this._sentinel;
  if (entry._prev && entry._next) {
    unlink(entry);
  }
  entry._next = sentinel._next;
  sentinel._next._prev = entry;
  sentinel._next = entry;
  entry._prev = sentinel;
};

List.prototype.toString = function() {
  var strs = [];
  var sentinel = this._sentinel;
  var curr = sentinel._prev;
  while (curr !== sentinel) {
    strs.push(JSON.stringify(curr, filterOutLinks));
    curr = curr._prev;
  }
  return "[" + strs.join(", ") + "]";
};

function unlink(entry) {
  entry._prev._next = entry._next;
  entry._next._prev = entry._prev;
  delete entry._next;
  delete entry._prev;
}

function filterOutLinks(k, v) {
  if (k !== "_next" && k !== "_prev") {
    return v;
  }
}

var Graph$1 = graphlib_1.Graph;


/*
 * A greedy heuristic for finding a feedback arc set for a graph. A feedback
 * arc set is a set of edges that can be removed to make a graph acyclic.
 * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, "A fast and
 * effective heuristic for the feedback arc set problem." This implementation
 * adjusts that from the paper to allow for weighted edges.
 */
var greedyFas = greedyFAS;

var DEFAULT_WEIGHT_FN = lodash_1$1.constant(1);

function greedyFAS(g, weightFn) {
  if (g.nodeCount() <= 1) {
    return [];
  }
  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);

  // Expand multi-edges
  return lodash_1$1.flatten(lodash_1$1.map(results, function(e) {
    return g.outEdges(e.v, e.w);
  }), true);
}

function doGreedyFAS(g, buckets, zeroIdx) {
  var results = [];
  var sources = buckets[buckets.length - 1];
  var sinks = buckets[0];

  var entry;
  while (g.nodeCount()) {
    while ((entry = sinks.dequeue()))   { removeNode(g, buckets, zeroIdx, entry); }
    while ((entry = sources.dequeue())) { removeNode(g, buckets, zeroIdx, entry); }
    if (g.nodeCount()) {
      for (var i = buckets.length - 2; i > 0; --i) {
        entry = buckets[i].dequeue();
        if (entry) {
          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }

  return results;
}

function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
  var results = collectPredecessors ? [] : undefined;

  lodash_1$1.forEach(g.inEdges(entry.v), function(edge) {
    var weight = g.edge(edge);
    var uEntry = g.node(edge.v);

    if (collectPredecessors) {
      results.push({ v: edge.v, w: edge.w });
    }

    uEntry.out -= weight;
    assignBucket(buckets, zeroIdx, uEntry);
  });

  lodash_1$1.forEach(g.outEdges(entry.v), function(edge) {
    var weight = g.edge(edge);
    var w = edge.w;
    var wEntry = g.node(w);
    wEntry["in"] -= weight;
    assignBucket(buckets, zeroIdx, wEntry);
  });

  g.removeNode(entry.v);

  return results;
}

function buildState(g, weightFn) {
  var fasGraph = new Graph$1();
  var maxIn = 0;
  var maxOut = 0;

  lodash_1$1.forEach(g.nodes(), function(v) {
    fasGraph.setNode(v, { v: v, "in": 0, out: 0 });
  });

  // Aggregate weights on nodes, but also sum the weights across multi-edges
  // into a single edge for the fasGraph.
  lodash_1$1.forEach(g.edges(), function(e) {
    var prevWeight = fasGraph.edge(e.v, e.w) || 0;
    var weight = weightFn(e);
    var edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e.v, e.w, edgeWeight);
    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
    maxIn  = Math.max(maxIn,  fasGraph.node(e.w)["in"]  += weight);
  });

  var buckets = lodash_1$1.range(maxOut + maxIn + 3).map(function() { return new list(); });
  var zeroIdx = maxIn + 1;

  lodash_1$1.forEach(fasGraph.nodes(), function(v) {
    assignBucket(buckets, zeroIdx, fasGraph.node(v));
  });

  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };
}

function assignBucket(buckets, zeroIdx, entry) {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
}

var acyclic = {
  run: run,
  undo: undo
};

function run(g) {
  var fas = (g.graph().acyclicer === "greedy"
    ? greedyFas(g, weightFn(g))
    : dfsFAS(g));
  lodash_1$1.forEach(fas, function(e) {
    var label = g.edge(e);
    g.removeEdge(e);
    label.forwardName = e.name;
    label.reversed = true;
    g.setEdge(e.w, e.v, label, lodash_1$1.uniqueId("rev"));
  });

  function weightFn(g) {
    return function(e) {
      return g.edge(e).weight;
    };
  }
}

function dfsFAS(g) {
  var fas = [];
  var stack = {};
  var visited = {};

  function dfs(v) {
    if (lodash_1$1.has(visited, v)) {
      return;
    }
    visited[v] = true;
    stack[v] = true;
    lodash_1$1.forEach(g.outEdges(v), function(e) {
      if (lodash_1$1.has(stack, e.w)) {
        fas.push(e);
      } else {
        dfs(e.w);
      }
    });
    delete stack[v];
  }

  lodash_1$1.forEach(g.nodes(), dfs);
  return fas;
}

function undo(g) {
  lodash_1$1.forEach(g.edges(), function(e) {
    var label = g.edge(e);
    if (label.reversed) {
      g.removeEdge(e);

      var forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g.setEdge(e.w, e.v, label, forwardName);
    }
  });
}

var Graph$2 = graphlib_1.Graph;

var util = {
  addDummyNode: addDummyNode,
  simplify: simplify,
  asNonCompoundGraph: asNonCompoundGraph,
  successorWeights: successorWeights,
  predecessorWeights: predecessorWeights,
  intersectRect: intersectRect,
  buildLayerMatrix: buildLayerMatrix,
  normalizeRanks: normalizeRanks,
  removeEmptyRanks: removeEmptyRanks,
  addBorderNode: addBorderNode,
  maxRank: maxRank,
  partition: partition$1,
  time: time,
  notime: notime
};

/*
 * Adds a dummy node to the graph and return v.
 */
function addDummyNode(g, type, attrs, name) {
  var v;
  do {
    v = lodash_1$1.uniqueId(name);
  } while (g.hasNode(v));

  attrs.dummy = type;
  g.setNode(v, attrs);
  return v;
}

/*
 * Returns a new graph with only simple edges. Handles aggregation of data
 * associated with multi-edges.
 */
function simplify(g) {
  var simplified = new Graph$2().setGraph(g.graph());
  lodash_1$1.forEach(g.nodes(), function(v) { simplified.setNode(v, g.node(v)); });
  lodash_1$1.forEach(g.edges(), function(e) {
    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
    var label = g.edge(e);
    simplified.setEdge(e.v, e.w, {
      weight: simpleLabel.weight + label.weight,
      minlen: Math.max(simpleLabel.minlen, label.minlen)
    });
  });
  return simplified;
}

function asNonCompoundGraph(g) {
  var simplified = new Graph$2({ multigraph: g.isMultigraph() }).setGraph(g.graph());
  lodash_1$1.forEach(g.nodes(), function(v) {
    if (!g.children(v).length) {
      simplified.setNode(v, g.node(v));
    }
  });
  lodash_1$1.forEach(g.edges(), function(e) {
    simplified.setEdge(e, g.edge(e));
  });
  return simplified;
}

function successorWeights(g) {
  var weightMap = lodash_1$1.map(g.nodes(), function(v) {
    var sucs = {};
    lodash_1$1.forEach(g.outEdges(v), function(e) {
      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
    });
    return sucs;
  });
  return lodash_1$1.zipObject(g.nodes(), weightMap);
}

function predecessorWeights(g) {
  var weightMap = lodash_1$1.map(g.nodes(), function(v) {
    var preds = {};
    lodash_1$1.forEach(g.inEdges(v), function(e) {
      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
    });
    return preds;
  });
  return lodash_1$1.zipObject(g.nodes(), weightMap);
}

/*
 * Finds where a line starting at point ({x, y}) would intersect a rectangle
 * ({x, y, width, height}) if it were pointing at the rectangle's center.
 */
function intersectRect(rect, point) {
  var x = rect.x;
  var y = rect.y;

  // Rectangle intersection algorithm from:
  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes
  var dx = point.x - x;
  var dy = point.y - y;
  var w = rect.width / 2;
  var h = rect.height / 2;

  if (!dx && !dy) {
    throw new Error("Not possible to find intersection inside of the rectangle");
  }

  var sx, sy;
  if (Math.abs(dy) * w > Math.abs(dx) * h) {
    // Intersection is top or bottom of rect.
    if (dy < 0) {
      h = -h;
    }
    sx = h * dx / dy;
    sy = h;
  } else {
    // Intersection is left or right of rect.
    if (dx < 0) {
      w = -w;
    }
    sx = w;
    sy = w * dy / dx;
  }

  return { x: x + sx, y: y + sy };
}

/*
 * Given a DAG with each node assigned "rank" and "order" properties, this
 * function will produce a matrix with the ids of each node.
 */
function buildLayerMatrix(g) {
  var layering = lodash_1$1.map(lodash_1$1.range(maxRank(g) + 1), function() { return []; });
  lodash_1$1.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    var rank = node.rank;
    if (!lodash_1$1.isUndefined(rank)) {
      layering[rank][node.order] = v;
    }
  });
  return layering;
}

/*
 * Adjusts the ranks for all nodes in the graph such that all nodes v have
 * rank(v) >= 0 and at least one node w has rank(w) = 0.
 */
function normalizeRanks(g) {
  var min = lodash_1$1.min(lodash_1$1.map(g.nodes(), function(v) { return g.node(v).rank; }));
  lodash_1$1.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (lodash_1$1.has(node, "rank")) {
      node.rank -= min;
    }
  });
}

function removeEmptyRanks(g) {
  // Ranks may not start at 0, so we need to offset them
  var offset = lodash_1$1.min(lodash_1$1.map(g.nodes(), function(v) { return g.node(v).rank; }));

  var layers = [];
  lodash_1$1.forEach(g.nodes(), function(v) {
    var rank = g.node(v).rank - offset;
    if (!layers[rank]) {
      layers[rank] = [];
    }
    layers[rank].push(v);
  });

  var delta = 0;
  var nodeRankFactor = g.graph().nodeRankFactor;
  lodash_1$1.forEach(layers, function(vs, i) {
    if (lodash_1$1.isUndefined(vs) && i % nodeRankFactor !== 0) {
      --delta;
    } else if (delta) {
      lodash_1$1.forEach(vs, function(v) { g.node(v).rank += delta; });
    }
  });
}

function addBorderNode(g, prefix, rank, order) {
  var node = {
    width: 0,
    height: 0
  };
  if (arguments.length >= 4) {
    node.rank = rank;
    node.order = order;
  }
  return addDummyNode(g, "border", node, prefix);
}

function maxRank(g) {
  return lodash_1$1.max(lodash_1$1.map(g.nodes(), function(v) {
    var rank = g.node(v).rank;
    if (!lodash_1$1.isUndefined(rank)) {
      return rank;
    }
  }));
}

/*
 * Partition a collection into two groups: `lhs` and `rhs`. If the supplied
 * function returns true for an entry it goes into `lhs`. Otherwise it goes
 * into `rhs.
 */
function partition$1(collection, fn) {
  var result = { lhs: [], rhs: [] };
  lodash_1$1.forEach(collection, function(value) {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
}

/*
 * Returns a new function that wraps `fn` with a timer. The wrapper logs the
 * time it takes to execute the function.
 */
function time(name, fn) {
  var start = lodash_1$1.now();
  try {
    return fn();
  } finally {
    console.log(name + " time: " + (lodash_1$1.now() - start) + "ms");
  }
}

function notime(name, fn) {
  return fn();
}

var normalize = {
  run: run$1,
  undo: undo$1
};

/*
 * Breaks any long edges in the graph into short segments that span 1 layer
 * each. This operation is undoable with the denormalize function.
 *
 * Pre-conditions:
 *
 *    1. The input graph is a DAG.
 *    2. Each node in the graph has a "rank" property.
 *
 * Post-condition:
 *
 *    1. All edges in the graph have a length of 1.
 *    2. Dummy nodes are added where edges have been split into segments.
 *    3. The graph is augmented with a "dummyChains" attribute which contains
 *       the first dummy in each chain of dummy nodes produced.
 */
function run$1(g) {
  g.graph().dummyChains = [];
  lodash_1$1.forEach(g.edges(), function(edge) { normalizeEdge(g, edge); });
}

function normalizeEdge(g, e) {
  var v = e.v;
  var vRank = g.node(v).rank;
  var w = e.w;
  var wRank = g.node(w).rank;
  var name = e.name;
  var edgeLabel = g.edge(e);
  var labelRank = edgeLabel.labelRank;

  if (wRank === vRank + 1) return;

  g.removeEdge(e);

  var dummy, attrs, i;
  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
    edgeLabel.points = [];
    attrs = {
      width: 0, height: 0,
      edgeLabel: edgeLabel, edgeObj: e,
      rank: vRank
    };
    dummy = util.addDummyNode(g, "edge", attrs, "_d");
    if (vRank === labelRank) {
      attrs.width = edgeLabel.width;
      attrs.height = edgeLabel.height;
      attrs.dummy = "edge-label";
      attrs.labelpos = edgeLabel.labelpos;
    }
    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
    if (i === 0) {
      g.graph().dummyChains.push(dummy);
    }
    v = dummy;
  }

  g.setEdge(v, w, { weight: edgeLabel.weight }, name);
}

function undo$1(g) {
  lodash_1$1.forEach(g.graph().dummyChains, function(v) {
    var node = g.node(v);
    var origLabel = node.edgeLabel;
    var w;
    g.setEdge(node.edgeObj, origLabel);
    while (node.dummy) {
      w = g.successors(v)[0];
      g.removeNode(v);
      origLabel.points.push({ x: node.x, y: node.y });
      if (node.dummy === "edge-label") {
        origLabel.x = node.x;
        origLabel.y = node.y;
        origLabel.width = node.width;
        origLabel.height = node.height;
      }
      v = w;
      node = g.node(v);
    }
  });
}

var util$1 = {
  longestPath: longestPath,
  slack: slack
};

/*
 * Initializes ranks for the input graph using the longest path algorithm. This
 * algorithm scales well and is fast in practice, it yields rather poor
 * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom
 * ranks wide and leaving edges longer than necessary. However, due to its
 * speed, this algorithm is good for getting an initial ranking that can be fed
 * into other algorithms.
 *
 * This algorithm does not normalize layers because it will be used by other
 * algorithms in most cases. If using this algorithm directly, be sure to
 * run normalize at the end.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG.
 *    2. Input graph node labels can be assigned properties.
 *
 * Post-conditions:
 *
 *    1. Each node will be assign an (unnormalized) "rank" property.
 */
function longestPath(g) {
  var visited = {};

  function dfs(v) {
    var label = g.node(v);
    if (lodash_1$1.has(visited, v)) {
      return label.rank;
    }
    visited[v] = true;

    var rank = lodash_1$1.min(lodash_1$1.map(g.outEdges(v), function(e) {
      return dfs(e.w) - g.edge(e).minlen;
    }));

    if (rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
        rank === undefined || // return value of _.map([]) for Lodash 4
        rank === null) { // return value of _.map([null])
      rank = 0;
    }

    return (label.rank = rank);
  }

  lodash_1$1.forEach(g.sources(), dfs);
}

/*
 * Returns the amount of slack for the given edge. The slack is defined as the
 * difference between the length of the edge and its minimum length.
 */
function slack(g, e) {
  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
}

var Graph$3 = graphlib_1.Graph;
var slack$1 = util$1.slack;

var feasibleTree_1 = feasibleTree;

/*
 * Constructs a spanning tree with tight edges and adjusted the input node's
 * ranks to achieve this. A tight edge is one that is has a length that matches
 * its "minlen" attribute.
 *
 * The basic structure for this function is derived from Gansner, et al., "A
 * Technique for Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a DAG.
 *    2. Graph must be connected.
 *    3. Graph must have at least one node.
 *    5. Graph nodes must have been previously assigned a "rank" property that
 *       respects the "minlen" property of incident edges.
 *    6. Graph edges must have a "minlen" property.
 *
 * Post-conditions:
 *
 *    - Graph nodes will have their rank adjusted to ensure that all edges are
 *      tight.
 *
 * Returns a tree (undirected graph) that is constructed using only "tight"
 * edges.
 */
function feasibleTree(g) {
  var t = new Graph$3({ directed: false });

  // Choose arbitrary node from which to start our tree
  var start = g.nodes()[0];
  var size = g.nodeCount();
  t.setNode(start, {});

  var edge, delta;
  while (tightTree(t, g) < size) {
    edge = findMinSlackEdge(t, g);
    delta = t.hasNode(edge.v) ? slack$1(g, edge) : -slack$1(g, edge);
    shiftRanks(t, g, delta);
  }

  return t;
}

/*
 * Finds a maximal tree of tight edges and returns the number of nodes in the
 * tree.
 */
function tightTree(t, g) {
  function dfs(v) {
    lodash_1$1.forEach(g.nodeEdges(v), function(e) {
      var edgeV = e.v,
        w = (v === edgeV) ? e.w : edgeV;
      if (!t.hasNode(w) && !slack$1(g, e)) {
        t.setNode(w, {});
        t.setEdge(v, w, {});
        dfs(w);
      }
    });
  }

  lodash_1$1.forEach(t.nodes(), dfs);
  return t.nodeCount();
}

/*
 * Finds the edge with the smallest slack that is incident on tree and returns
 * it.
 */
function findMinSlackEdge(t, g) {
  return lodash_1$1.minBy(g.edges(), function(e) {
    if (t.hasNode(e.v) !== t.hasNode(e.w)) {
      return slack$1(g, e);
    }
  });
}

function shiftRanks(t, g, delta) {
  lodash_1$1.forEach(t.nodes(), function(v) {
    g.node(v).rank += delta;
  });
}

var slack$2 = util$1.slack;
var initRank = util$1.longestPath;
var preorder$1 = graphlib_1.alg.preorder;
var postorder$1 = graphlib_1.alg.postorder;
var simplify$1 = util.simplify;

var networkSimplex_1 = networkSimplex;

// Expose some internals for testing purposes
networkSimplex.initLowLimValues = initLowLimValues;
networkSimplex.initCutValues = initCutValues;
networkSimplex.calcCutValue = calcCutValue;
networkSimplex.leaveEdge = leaveEdge;
networkSimplex.enterEdge = enterEdge;
networkSimplex.exchangeEdges = exchangeEdges;

/*
 * The network simplex algorithm assigns ranks to each node in the input graph
 * and iteratively improves the ranking to reduce the length of edges.
 *
 * Preconditions:
 *
 *    1. The input graph must be a DAG.
 *    2. All nodes in the graph must have an object value.
 *    3. All edges in the graph must have "minlen" and "weight" attributes.
 *
 * Postconditions:
 *
 *    1. All nodes in the graph will have an assigned "rank" attribute that has
 *       been optimized by the network simplex algorithm. Ranks start at 0.
 *
 *
 * A rough sketch of the algorithm is as follows:
 *
 *    1. Assign initial ranks to each node. We use the longest path algorithm,
 *       which assigns ranks to the lowest position possible. In general this
 *       leads to very wide bottom ranks and unnecessarily long edges.
 *    2. Construct a feasible tight tree. A tight tree is one such that all
 *       edges in the tree have no slack (difference between length of edge
 *       and minlen for the edge). This by itself greatly improves the assigned
 *       rankings by shorting edges.
 *    3. Iteratively find edges that have negative cut values. Generally a
 *       negative cut value indicates that the edge could be removed and a new
 *       tree edge could be added to produce a more compact graph.
 *
 * Much of the algorithms here are derived from Gansner, et al., "A Technique
 * for Drawing Directed Graphs." The structure of the file roughly follows the
 * structure of the overall algorithm.
 */
function networkSimplex(g) {
  g = simplify$1(g);
  initRank(g);
  var t = feasibleTree_1(g);
  initLowLimValues(t);
  initCutValues(t, g);

  var e, f;
  while ((e = leaveEdge(t))) {
    f = enterEdge(t, g, e);
    exchangeEdges(t, g, e, f);
  }
}

/*
 * Initializes cut values for all edges in the tree.
 */
function initCutValues(t, g) {
  var vs = postorder$1(t, t.nodes());
  vs = vs.slice(0, vs.length - 1);
  lodash_1$1.forEach(vs, function(v) {
    assignCutValue(t, g, v);
  });
}

function assignCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
}

/*
 * Given the tight tree, its graph, and a child in the graph calculate and
 * return the cut value for the edge between the child and its parent.
 */
function calcCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  // True if the child is on the tail end of the edge in the directed graph
  var childIsTail = true;
  // The graph's view of the tree edge we're inspecting
  var graphEdge = g.edge(child, parent);
  // The accumulated cut value for the edge between this node and its parent
  var cutValue = 0;

  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g.edge(parent, child);
  }

  cutValue = graphEdge.weight;

  lodash_1$1.forEach(g.nodeEdges(child), function(e) {
    var isOutEdge = e.v === child,
      other = isOutEdge ? e.w : e.v;

    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail,
        otherWeight = g.edge(e).weight;

      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t, child, other)) {
        var otherCutValue = t.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });

  return cutValue;
}

function initLowLimValues(tree, root) {
  if (arguments.length < 2) {
    root = tree.nodes()[0];
  }
  dfsAssignLowLim(tree, {}, 1, root);
}

function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
  var low = nextLim;
  var label = tree.node(v);

  visited[v] = true;
  lodash_1$1.forEach(tree.neighbors(v), function(w) {
    if (!lodash_1$1.has(visited, w)) {
      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
    }
  });

  label.low = low;
  label.lim = nextLim++;
  if (parent) {
    label.parent = parent;
  } else {
    // TODO should be able to remove this when we incrementally update low lim
    delete label.parent;
  }

  return nextLim;
}

function leaveEdge(tree) {
  return lodash_1$1.find(tree.edges(), function(e) {
    return tree.edge(e).cutvalue < 0;
  });
}

function enterEdge(t, g, edge) {
  var v = edge.v;
  var w = edge.w;

  // For the rest of this function we assume that v is the tail and w is the
  // head, so if we don't have this edge in the graph we should flip it to
  // match the correct orientation.
  if (!g.hasEdge(v, w)) {
    v = edge.w;
    w = edge.v;
  }

  var vLabel = t.node(v);
  var wLabel = t.node(w);
  var tailLabel = vLabel;
  var flip = false;

  // If the root is in the tail of the edge then we need to flip the logic that
  // checks for the head and tail nodes in the candidates function below.
  if (vLabel.lim > wLabel.lim) {
    tailLabel = wLabel;
    flip = true;
  }

  var candidates = lodash_1$1.filter(g.edges(), function(edge) {
    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&
           flip !== isDescendant(t, t.node(edge.w), tailLabel);
  });

  return lodash_1$1.minBy(candidates, function(edge) { return slack$2(g, edge); });
}

function exchangeEdges(t, g, e, f) {
  var v = e.v;
  var w = e.w;
  t.removeEdge(v, w);
  t.setEdge(f.v, f.w, {});
  initLowLimValues(t);
  initCutValues(t, g);
  updateRanks(t, g);
}

function updateRanks(t, g) {
  var root = lodash_1$1.find(t.nodes(), function(v) { return !g.node(v).parent; });
  var vs = preorder$1(t, root);
  vs = vs.slice(1);
  lodash_1$1.forEach(vs, function(v) {
    var parent = t.node(v).parent,
      edge = g.edge(v, parent),
      flipped = false;

    if (!edge) {
      edge = g.edge(parent, v);
      flipped = true;
    }

    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}

/*
 * Returns true if the edge is in the tree.
 */
function isTreeEdge(tree, u, v) {
  return tree.hasEdge(u, v);
}

/*
 * Returns true if the specified node is descendant of the root node per the
 * assigned low and lim attributes in the tree.
 */
function isDescendant(tree, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}

var longestPath$1 = util$1.longestPath;



var rank_1 = rank;

/*
 * Assigns a rank to each node in the input graph that respects the "minlen"
 * constraint specified on edges between nodes.
 *
 * This basic structure is derived from Gansner, et al., "A Technique for
 * Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a connected DAG
 *    2. Graph nodes must be objects
 *    3. Graph edges must have "weight" and "minlen" attributes
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have a "rank" attribute based on the results of the
 *       algorithm. Ranks can start at any index (including negative), we'll
 *       fix them up later.
 */
function rank(g) {
  switch(g.graph().ranker) {
  case "network-simplex": networkSimplexRanker(g); break;
  case "tight-tree": tightTreeRanker(g); break;
  case "longest-path": longestPathRanker(g); break;
  default: networkSimplexRanker(g);
  }
}

// A fast and simple ranker, but results are far from optimal.
var longestPathRanker = longestPath$1;

function tightTreeRanker(g) {
  longestPath$1(g);
  feasibleTree_1(g);
}

function networkSimplexRanker(g) {
  networkSimplex_1(g);
}

var parentDummyChains_1 = parentDummyChains;

function parentDummyChains(g) {
  var postorderNums = postorder$2(g);

  lodash_1$1.forEach(g.graph().dummyChains, function(v) {
    var node = g.node(v);
    var edgeObj = node.edgeObj;
    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
    var path = pathData.path;
    var lca = pathData.lca;
    var pathIdx = 0;
    var pathV = path[pathIdx];
    var ascending = true;

    while (v !== edgeObj.w) {
      node = g.node(v);

      if (ascending) {
        while ((pathV = path[pathIdx]) !== lca &&
               g.node(pathV).maxRank < node.rank) {
          pathIdx++;
        }

        if (pathV === lca) {
          ascending = false;
        }
      }

      if (!ascending) {
        while (pathIdx < path.length - 1 &&
               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
          pathIdx++;
        }
        pathV = path[pathIdx];
      }

      g.setParent(v, pathV);
      v = g.successors(v)[0];
    }
  });
}

// Find a path from v to w through the lowest common ancestor (LCA). Return the
// full path and the LCA.
function findPath(g, postorderNums, v, w) {
  var vPath = [];
  var wPath = [];
  var low = Math.min(postorderNums[v].low, postorderNums[w].low);
  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
  var parent;
  var lca;

  // Traverse up from v to find the LCA
  parent = v;
  do {
    parent = g.parent(parent);
    vPath.push(parent);
  } while (parent &&
           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;

  // Traverse from w to LCA
  parent = w;
  while ((parent = g.parent(parent)) !== lca) {
    wPath.push(parent);
  }

  return { path: vPath.concat(wPath.reverse()), lca: lca };
}

function postorder$2(g) {
  var result = {};
  var lim = 0;

  function dfs(v) {
    var low = lim;
    lodash_1$1.forEach(g.children(v), dfs);
    result[v] = { low: low, lim: lim++ };
  }
  lodash_1$1.forEach(g.children(), dfs);

  return result;
}

var nestingGraph = {
  run: run$2,
  cleanup: cleanup
};

/*
 * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,
 * adds appropriate edges to ensure that all cluster nodes are placed between
 * these boundries, and ensures that the graph is connected.
 *
 * In addition we ensure, through the use of the minlen property, that nodes
 * and subgraph border nodes to not end up on the same rank.
 *
 * Preconditions:
 *
 *    1. Input graph is a DAG
 *    2. Nodes in the input graph has a minlen attribute
 *
 * Postconditions:
 *
 *    1. Input graph is connected.
 *    2. Dummy nodes are added for the tops and bottoms of subgraphs.
 *    3. The minlen attribute for nodes is adjusted to ensure nodes do not
 *       get placed on the same rank as subgraph border nodes.
 *
 * The nesting graph idea comes from Sander, "Layout of Compound Directed
 * Graphs."
 */
function run$2(g) {
  var root = util.addDummyNode(g, "root", {}, "_root");
  var depths = treeDepths(g);
  var height = lodash_1$1.max(lodash_1$1.values(depths)) - 1; // Note: depths is an Object not an array
  var nodeSep = 2 * height + 1;

  g.graph().nestingRoot = root;

  // Multiply minlen by nodeSep to align nodes on non-border ranks.
  lodash_1$1.forEach(g.edges(), function(e) { g.edge(e).minlen *= nodeSep; });

  // Calculate a weight that is sufficient to keep subgraphs vertically compact
  var weight = sumWeights(g) + 1;

  // Create border nodes and link them up
  lodash_1$1.forEach(g.children(), function(child) {
    dfs$1(g, root, nodeSep, weight, height, depths, child);
  });

  // Save the multiplier for node layers for later removal of empty border
  // layers.
  g.graph().nodeRankFactor = nodeSep;
}

function dfs$1(g, root, nodeSep, weight, height, depths, v) {
  var children = g.children(v);
  if (!children.length) {
    if (v !== root) {
      g.setEdge(root, v, { weight: 0, minlen: nodeSep });
    }
    return;
  }

  var top = util.addBorderNode(g, "_bt");
  var bottom = util.addBorderNode(g, "_bb");
  var label = g.node(v);

  g.setParent(top, v);
  label.borderTop = top;
  g.setParent(bottom, v);
  label.borderBottom = bottom;

  lodash_1$1.forEach(children, function(child) {
    dfs$1(g, root, nodeSep, weight, height, depths, child);

    var childNode = g.node(child);
    var childTop = childNode.borderTop ? childNode.borderTop : child;
    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
    var thisWeight = childNode.borderTop ? weight : 2 * weight;
    var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;

    g.setEdge(top, childTop, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });

    g.setEdge(childBottom, bottom, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });
  });

  if (!g.parent(v)) {
    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });
  }
}

function treeDepths(g) {
  var depths = {};
  function dfs(v, depth) {
    var children = g.children(v);
    if (children && children.length) {
      lodash_1$1.forEach(children, function(child) {
        dfs(child, depth + 1);
      });
    }
    depths[v] = depth;
  }
  lodash_1$1.forEach(g.children(), function(v) { dfs(v, 1); });
  return depths;
}

function sumWeights(g) {
  return lodash_1$1.reduce(g.edges(), function(acc, e) {
    return acc + g.edge(e).weight;
  }, 0);
}

function cleanup(g) {
  var graphLabel = g.graph();
  g.removeNode(graphLabel.nestingRoot);
  delete graphLabel.nestingRoot;
  lodash_1$1.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.nestingEdge) {
      g.removeEdge(e);
    }
  });
}

var addBorderSegments_1 = addBorderSegments;

function addBorderSegments(g) {
  function dfs(v) {
    var children = g.children(v);
    var node = g.node(v);
    if (children.length) {
      lodash_1$1.forEach(children, dfs);
    }

    if (lodash_1$1.has(node, "minRank")) {
      node.borderLeft = [];
      node.borderRight = [];
      for (var rank = node.minRank, maxRank = node.maxRank + 1;
        rank < maxRank;
        ++rank) {
        addBorderNode$1(g, "borderLeft", "_bl", v, node, rank);
        addBorderNode$1(g, "borderRight", "_br", v, node, rank);
      }
    }
  }

  lodash_1$1.forEach(g.children(), dfs);
}

function addBorderNode$1(g, prop, prefix, sg, sgNode, rank) {
  var label = { width: 0, height: 0, rank: rank, borderType: prop };
  var prev = sgNode[prop][rank - 1];
  var curr = util.addDummyNode(g, "border", label, prefix);
  sgNode[prop][rank] = curr;
  g.setParent(curr, sg);
  if (prev) {
    g.setEdge(prev, curr, { weight: 1 });
  }
}

var coordinateSystem = {
  adjust: adjust,
  undo: undo$2
};

function adjust(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "lr" || rankDir === "rl") {
    swapWidthHeight(g);
  }
}

function undo$2(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "bt" || rankDir === "rl") {
    reverseY(g);
  }

  if (rankDir === "lr" || rankDir === "rl") {
    swapXY(g);
    swapWidthHeight(g);
  }
}

function swapWidthHeight(g) {
  lodash_1$1.forEach(g.nodes(), function(v) { swapWidthHeightOne(g.node(v)); });
  lodash_1$1.forEach(g.edges(), function(e) { swapWidthHeightOne(g.edge(e)); });
}

function swapWidthHeightOne(attrs) {
  var w = attrs.width;
  attrs.width = attrs.height;
  attrs.height = w;
}

function reverseY(g) {
  lodash_1$1.forEach(g.nodes(), function(v) { reverseYOne(g.node(v)); });

  lodash_1$1.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    lodash_1$1.forEach(edge.points, reverseYOne);
    if (lodash_1$1.has(edge, "y")) {
      reverseYOne(edge);
    }
  });
}

function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}

function swapXY(g) {
  lodash_1$1.forEach(g.nodes(), function(v) { swapXYOne(g.node(v)); });

  lodash_1$1.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    lodash_1$1.forEach(edge.points, swapXYOne);
    if (lodash_1$1.has(edge, "x")) {
      swapXYOne(edge);
    }
  });
}

function swapXYOne(attrs) {
  var x = attrs.x;
  attrs.x = attrs.y;
  attrs.y = x;
}

var initOrder_1 = initOrder;

/*
 * Assigns an initial order value for each node by performing a DFS search
 * starting from nodes in the first rank. Nodes are assigned an order in their
 * rank as they are first visited.
 *
 * This approach comes from Gansner, et al., "A Technique for Drawing Directed
 * Graphs."
 *
 * Returns a layering matrix with an array per layer and each layer sorted by
 * the order of its nodes.
 */
function initOrder(g) {
  var visited = {};
  var simpleNodes = lodash_1$1.filter(g.nodes(), function(v) {
    return !g.children(v).length;
  });
  var maxRank = lodash_1$1.max(lodash_1$1.map(simpleNodes, function(v) { return g.node(v).rank; }));
  var layers = lodash_1$1.map(lodash_1$1.range(maxRank + 1), function() { return []; });

  function dfs(v) {
    if (lodash_1$1.has(visited, v)) return;
    visited[v] = true;
    var node = g.node(v);
    layers[node.rank].push(v);
    lodash_1$1.forEach(g.successors(v), dfs);
  }

  var orderedVs = lodash_1$1.sortBy(simpleNodes, function(v) { return g.node(v).rank; });
  lodash_1$1.forEach(orderedVs, dfs);

  return layers;
}

var crossCount_1 = crossCount;

/*
 * A function that takes a layering (an array of layers, each with an array of
 * ordererd nodes) and a graph and returns a weighted crossing count.
 *
 * Pre-conditions:
 *
 *    1. Input graph must be simple (not a multigraph), directed, and include
 *       only simple edges.
 *    2. Edges in the input graph must have assigned weights.
 *
 * Post-conditions:
 *
 *    1. The graph and layering matrix are left unchanged.
 *
 * This algorithm is derived from Barth, et al., "Bilayer Cross Counting."
 */
function crossCount(g, layering) {
  var cc = 0;
  for (var i = 1; i < layering.length; ++i) {
    cc += twoLayerCrossCount(g, layering[i-1], layering[i]);
  }
  return cc;
}

function twoLayerCrossCount(g, northLayer, southLayer) {
  // Sort all of the edges between the north and south layers by their position
  // in the north layer and then the south. Map these edges to the position of
  // their head in the south layer.
  var southPos = lodash_1$1.zipObject(southLayer,
    lodash_1$1.map(southLayer, function (v, i) { return i; }));
  var southEntries = lodash_1$1.flatten(lodash_1$1.map(northLayer, function(v) {
    return lodash_1$1.sortBy(lodash_1$1.map(g.outEdges(v), function(e) {
      return { pos: southPos[e.w], weight: g.edge(e).weight };
    }), "pos");
  }), true);

  // Build the accumulator tree
  var firstIndex = 1;
  while (firstIndex < southLayer.length) firstIndex <<= 1;
  var treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  var tree = lodash_1$1.map(new Array(treeSize), function() { return 0; });

  // Calculate the weighted crossings
  var cc = 0;
  lodash_1$1.forEach(southEntries.forEach(function(entry) {
    var index = entry.pos + firstIndex;
    tree[index] += entry.weight;
    var weightSum = 0;
    while (index > 0) {
      if (index % 2) {
        weightSum += tree[index + 1];
      }
      index = (index - 1) >> 1;
      tree[index] += entry.weight;
    }
    cc += entry.weight * weightSum;
  }));

  return cc;
}

var barycenter_1 = barycenter;

function barycenter(g, movable) {
  return lodash_1$1.map(movable, function(v) {
    var inV = g.inEdges(v);
    if (!inV.length) {
      return { v: v };
    } else {
      var result = lodash_1$1.reduce(inV, function(acc, e) {
        var edge = g.edge(e),
          nodeU = g.node(e.v);
        return {
          sum: acc.sum + (edge.weight * nodeU.order),
          weight: acc.weight + edge.weight
        };
      }, { sum: 0, weight: 0 });

      return {
        v: v,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    }
  });
}

var resolveConflicts_1 = resolveConflicts;

/*
 * Given a list of entries of the form {v, barycenter, weight} and a
 * constraint graph this function will resolve any conflicts between the
 * constraint graph and the barycenters for the entries. If the barycenters for
 * an entry would violate a constraint in the constraint graph then we coalesce
 * the nodes in the conflict into a new node that respects the contraint and
 * aggregates barycenter and weight information.
 *
 * This implementation is based on the description in Forster, "A Fast and
 * Simple Hueristic for Constrained Two-Level Crossing Reduction," thought it
 * differs in some specific details.
 *
 * Pre-conditions:
 *
 *    1. Each entry has the form {v, barycenter, weight}, or if the node has
 *       no barycenter, then {v}.
 *
 * Returns:
 *
 *    A new list of entries of the form {vs, i, barycenter, weight}. The list
 *    `vs` may either be a singleton or it may be an aggregation of nodes
 *    ordered such that they do not violate constraints from the constraint
 *    graph. The property `i` is the lowest original index of any of the
 *    elements in `vs`.
 */
function resolveConflicts(entries, cg) {
  var mappedEntries = {};
  lodash_1$1.forEach(entries, function(entry, i) {
    var tmp = mappedEntries[entry.v] = {
      indegree: 0,
      "in": [],
      out: [],
      vs: [entry.v],
      i: i
    };
    if (!lodash_1$1.isUndefined(entry.barycenter)) {
      tmp.barycenter = entry.barycenter;
      tmp.weight = entry.weight;
    }
  });

  lodash_1$1.forEach(cg.edges(), function(e) {
    var entryV = mappedEntries[e.v];
    var entryW = mappedEntries[e.w];
    if (!lodash_1$1.isUndefined(entryV) && !lodash_1$1.isUndefined(entryW)) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e.w]);
    }
  });

  var sourceSet = lodash_1$1.filter(mappedEntries, function(entry) {
    return !entry.indegree;
  });

  return doResolveConflicts(sourceSet);
}

function doResolveConflicts(sourceSet) {
  var entries = [];

  function handleIn(vEntry) {
    return function(uEntry) {
      if (uEntry.merged) {
        return;
      }
      if (lodash_1$1.isUndefined(uEntry.barycenter) ||
          lodash_1$1.isUndefined(vEntry.barycenter) ||
          uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  }

  function handleOut(vEntry) {
    return function(wEntry) {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  }

  while (sourceSet.length) {
    var entry = sourceSet.pop();
    entries.push(entry);
    lodash_1$1.forEach(entry["in"].reverse(), handleIn(entry));
    lodash_1$1.forEach(entry.out, handleOut(entry));
  }

  return lodash_1$1.map(lodash_1$1.filter(entries, function(entry) { return !entry.merged; }),
    function(entry) {
      return lodash_1$1.pick(entry, ["vs", "i", "barycenter", "weight"]);
    });

}

function mergeEntries(target, source) {
  var sum = 0;
  var weight = 0;

  if (target.weight) {
    sum += target.barycenter * target.weight;
    weight += target.weight;
  }

  if (source.weight) {
    sum += source.barycenter * source.weight;
    weight += source.weight;
  }

  target.vs = source.vs.concat(target.vs);
  target.barycenter = sum / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
}

var sort_1 = sort;

function sort(entries, biasRight) {
  var parts = util.partition(entries, function(entry) {
    return lodash_1$1.has(entry, "barycenter");
  });
  var sortable = parts.lhs,
    unsortable = lodash_1$1.sortBy(parts.rhs, function(entry) { return -entry.i; }),
    vs = [],
    sum = 0,
    weight = 0,
    vsIndex = 0;

  sortable.sort(compareWithBias(!!biasRight));

  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);

  lodash_1$1.forEach(sortable, function (entry) {
    vsIndex += entry.vs.length;
    vs.push(entry.vs);
    sum += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });

  var result = { vs: lodash_1$1.flatten(vs, true) };
  if (weight) {
    result.barycenter = sum / weight;
    result.weight = weight;
  }
  return result;
}

function consumeUnsortable(vs, unsortable, index) {
  var last;
  while (unsortable.length && (last = lodash_1$1.last(unsortable)).i <= index) {
    unsortable.pop();
    vs.push(last.vs);
    index++;
  }
  return index;
}

function compareWithBias(bias) {
  return function(entryV, entryW) {
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    } else if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }

    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
}

var sortSubgraph_1 = sortSubgraph;

function sortSubgraph(g, v, cg, biasRight) {
  var movable = g.children(v);
  var node = g.node(v);
  var bl = node ? node.borderLeft : undefined;
  var br = node ? node.borderRight: undefined;
  var subgraphs = {};

  if (bl) {
    movable = lodash_1$1.filter(movable, function(w) {
      return w !== bl && w !== br;
    });
  }

  var barycenters = barycenter_1(g, movable);
  lodash_1$1.forEach(barycenters, function(entry) {
    if (g.children(entry.v).length) {
      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult;
      if (lodash_1$1.has(subgraphResult, "barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });

  var entries = resolveConflicts_1(barycenters, cg);
  expandSubgraphs(entries, subgraphs);

  var result = sort_1(entries, biasRight);

  if (bl) {
    result.vs = lodash_1$1.flatten([bl, result.vs, br], true);
    if (g.predecessors(bl).length) {
      var blPred = g.node(g.predecessors(bl)[0]),
        brPred = g.node(g.predecessors(br)[0]);
      if (!lodash_1$1.has(result, "barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight +
                           blPred.order + brPred.order) / (result.weight + 2);
      result.weight += 2;
    }
  }

  return result;
}

function expandSubgraphs(entries, subgraphs) {
  lodash_1$1.forEach(entries, function(entry) {
    entry.vs = lodash_1$1.flatten(entry.vs.map(function(v) {
      if (subgraphs[v]) {
        return subgraphs[v].vs;
      }
      return v;
    }), true);
  });
}

function mergeBarycenters(target, other) {
  if (!lodash_1$1.isUndefined(target.barycenter)) {
    target.barycenter = (target.barycenter * target.weight +
                         other.barycenter * other.weight) /
                        (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
}

var Graph$4 = graphlib_1.Graph;

var buildLayerGraph_1 = buildLayerGraph;

/*
 * Constructs a graph that can be used to sort a layer of nodes. The graph will
 * contain all base and subgraph nodes from the request layer in their original
 * hierarchy and any edges that are incident on these nodes and are of the type
 * requested by the "relationship" parameter.
 *
 * Nodes from the requested rank that do not have parents are assigned a root
 * node in the output graph, which is set in the root graph attribute. This
 * makes it easy to walk the hierarchy of movable nodes during ordering.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG
 *    2. Base nodes in the input graph have a rank attribute
 *    3. Subgraph nodes in the input graph has minRank and maxRank attributes
 *    4. Edges have an assigned weight
 *
 * Post-conditions:
 *
 *    1. Output graph has all nodes in the movable rank with preserved
 *       hierarchy.
 *    2. Root nodes in the movable layer are made children of the node
 *       indicated by the root attribute of the graph.
 *    3. Non-movable nodes incident on movable nodes, selected by the
 *       relationship parameter, are included in the graph (without hierarchy).
 *    4. Edges incident on movable nodes, selected by the relationship
 *       parameter, are added to the output graph.
 *    5. The weights for copied edges are aggregated as need, since the output
 *       graph is not a multi-graph.
 */
function buildLayerGraph(g, rank, relationship) {
  var root = createRootNode(g),
    result = new Graph$4({ compound: true }).setGraph({ root: root })
      .setDefaultNodeLabel(function(v) { return g.node(v); });

  lodash_1$1.forEach(g.nodes(), function(v) {
    var node = g.node(v),
      parent = g.parent(v);

    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
      result.setNode(v);
      result.setParent(v, parent || root);

      // This assumes we have only short edges!
      lodash_1$1.forEach(g[relationship](v), function(e) {
        var u = e.v === v ? e.w : e.v,
          edge = result.edge(u, v),
          weight = !lodash_1$1.isUndefined(edge) ? edge.weight : 0;
        result.setEdge(u, v, { weight: g.edge(e).weight + weight });
      });

      if (lodash_1$1.has(node, "minRank")) {
        result.setNode(v, {
          borderLeft: node.borderLeft[rank],
          borderRight: node.borderRight[rank]
        });
      }
    }
  });

  return result;
}

function createRootNode(g) {
  var v;
  while (g.hasNode((v = lodash_1$1.uniqueId("_root"))));
  return v;
}

var addSubgraphConstraints_1 = addSubgraphConstraints;

function addSubgraphConstraints(g, cg, vs) {
  var prev = {},
    rootPrev;

  lodash_1$1.forEach(vs, function(v) {
    var child = g.parent(v),
      parent,
      prevChild;
    while (child) {
      parent = g.parent(child);
      if (parent) {
        prevChild = prev[parent];
        prev[parent] = child;
      } else {
        prevChild = rootPrev;
        rootPrev = child;
      }
      if (prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });

  /*
  function dfs(v) {
    var children = v ? g.children(v) : g.children();
    if (children.length) {
      var min = Number.POSITIVE_INFINITY,
          subgraphs = [];
      _.each(children, function(child) {
        var childMin = dfs(child);
        if (g.children(child).length) {
          subgraphs.push({ v: child, order: childMin });
        }
        min = Math.min(min, childMin);
      });
      _.reduce(_.sortBy(subgraphs, "order"), function(prev, curr) {
        cg.setEdge(prev.v, curr.v);
        return curr;
      });
      return min;
    }
    return g.node(v).order;
  }
  dfs(undefined);
  */
}

var Graph$5 = graphlib_1.Graph;


var order_1 = order;

/*
 * Applies heuristics to minimize edge crossings in the graph and sets the best
 * order solution as an order attribute on each node.
 *
 * Pre-conditions:
 *
 *    1. Graph must be DAG
 *    2. Graph nodes must be objects with a "rank" attribute
 *    3. Graph edges must have the "weight" attribute
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have an "order" attribute based on the results of the
 *       algorithm.
 */
function order(g) {
  var maxRank = util.maxRank(g),
    downLayerGraphs = buildLayerGraphs(g, lodash_1$1.range(1, maxRank + 1), "inEdges"),
    upLayerGraphs = buildLayerGraphs(g, lodash_1$1.range(maxRank - 1, -1, -1), "outEdges");

  var layering = initOrder_1(g);
  assignOrder(g, layering);

  var bestCC = Number.POSITIVE_INFINITY,
    best;

  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);

    layering = util.buildLayerMatrix(g);
    var cc = crossCount_1(g, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = lodash_1$1.cloneDeep(layering);
      bestCC = cc;
    }
  }

  assignOrder(g, best);
}

function buildLayerGraphs(g, ranks, relationship) {
  return lodash_1$1.map(ranks, function(rank) {
    return buildLayerGraph_1(g, rank, relationship);
  });
}

function sweepLayerGraphs(layerGraphs, biasRight) {
  var cg = new Graph$5();
  lodash_1$1.forEach(layerGraphs, function(lg) {
    var root = lg.graph().root;
    var sorted = sortSubgraph_1(lg, root, cg, biasRight);
    lodash_1$1.forEach(sorted.vs, function(v, i) {
      lg.node(v).order = i;
    });
    addSubgraphConstraints_1(lg, cg, sorted.vs);
  });
}

function assignOrder(g, layering) {
  lodash_1$1.forEach(layering, function(layer) {
    lodash_1$1.forEach(layer, function(v, i) {
      g.node(v).order = i;
    });
  });
}

var Graph$6 = graphlib_1.Graph;


/*
 * This module provides coordinate assignment based on Brandes and Köpf, "Fast
 * and Simple Horizontal Coordinate Assignment."
 */

var bk = {
  positionX: positionX,
  findType1Conflicts: findType1Conflicts,
  findType2Conflicts: findType2Conflicts,
  addConflict: addConflict,
  hasConflict: hasConflict,
  verticalAlignment: verticalAlignment,
  horizontalCompaction: horizontalCompaction,
  alignCoordinates: alignCoordinates,
  findSmallestWidthAlignment: findSmallestWidthAlignment,
  balance: balance
};

/*
 * Marks all edges in the graph with a type-1 conflict with the "type1Conflict"
 * property. A type-1 conflict is one where a non-inner segment crosses an
 * inner segment. An inner segment is an edge with both incident nodes marked
 * with the "dummy" property.
 *
 * This algorithm scans layer by layer, starting with the second, for type-1
 * conflicts between the current layer and the previous layer. For each layer
 * it scans the nodes from left to right until it reaches one that is incident
 * on an inner segment. It then scans predecessors to determine if they have
 * edges that cross that inner segment. At the end a final scan is done for all
 * nodes on the current rank to see if they cross the last visited inner
 * segment.
 *
 * This algorithm (safely) assumes that a dummy node will only be incident on a
 * single node in the layers being scanned.
 */
function findType1Conflicts(g, layering) {
  var conflicts = {};

  function visitLayer(prevLayer, layer) {
    var
      // last visited node in the previous layer that is incident on an inner
      // segment.
      k0 = 0,
      // Tracks the last node in this layer scanned for crossings with a type-1
      // segment.
      scanPos = 0,
      prevLayerLength = prevLayer.length,
      lastNode = lodash_1$1.last(layer);

    lodash_1$1.forEach(layer, function(v, i) {
      var w = findOtherInnerSegmentNode(g, v),
        k1 = w ? g.node(w).order : prevLayerLength;

      if (w || v === lastNode) {
        lodash_1$1.forEach(layer.slice(scanPos, i +1), function(scanNode) {
          lodash_1$1.forEach(g.predecessors(scanNode), function(u) {
            var uLabel = g.node(u),
              uPos = uLabel.order;
            if ((uPos < k0 || k1 < uPos) &&
                !(uLabel.dummy && g.node(scanNode).dummy)) {
              addConflict(conflicts, u, scanNode);
            }
          });
        });
        scanPos = i + 1;
        k0 = k1;
      }
    });

    return layer;
  }

  lodash_1$1.reduce(layering, visitLayer);
  return conflicts;
}

function findType2Conflicts(g, layering) {
  var conflicts = {};

  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    var v;
    lodash_1$1.forEach(lodash_1$1.range(southPos, southEnd), function(i) {
      v = south[i];
      if (g.node(v).dummy) {
        lodash_1$1.forEach(g.predecessors(v), function(u) {
          var uNode = g.node(u);
          if (uNode.dummy &&
              (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
            addConflict(conflicts, u, v);
          }
        });
      }
    });
  }


  function visitLayer(north, south) {
    var prevNorthPos = -1,
      nextNorthPos,
      southPos = 0;

    lodash_1$1.forEach(south, function(v, southLookahead) {
      if (g.node(v).dummy === "border") {
        var predecessors = g.predecessors(v);
        if (predecessors.length) {
          nextNorthPos = g.node(predecessors[0]).order;
          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scan(south, southPos, south.length, nextNorthPos, north.length);
    });

    return south;
  }

  lodash_1$1.reduce(layering, visitLayer);
  return conflicts;
}

function findOtherInnerSegmentNode(g, v) {
  if (g.node(v).dummy) {
    return lodash_1$1.find(g.predecessors(v), function(u) {
      return g.node(u).dummy;
    });
  }
}

function addConflict(conflicts, v, w) {
  if (v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }

  var conflictsV = conflicts[v];
  if (!conflictsV) {
    conflicts[v] = conflictsV = {};
  }
  conflictsV[w] = true;
}

function hasConflict(conflicts, v, w) {
  if (v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return lodash_1$1.has(conflicts[v], w);
}

/*
 * Try to align nodes into vertical "blocks" where possible. This algorithm
 * attempts to align a node with one of its median neighbors. If the edge
 * connecting a neighbor is a type-1 conflict then we ignore that possibility.
 * If a previous node has already formed a block with a node after the node
 * we're trying to form a block with, we also ignore that possibility - our
 * blocks would be split in that scenario.
 */
function verticalAlignment(g, layering, conflicts, neighborFn) {
  var root = {},
    align = {},
    pos = {};

  // We cache the position here based on the layering because the graph and
  // layering may be out of sync. The layering matrix is manipulated to
  // generate different extreme alignments.
  lodash_1$1.forEach(layering, function(layer) {
    lodash_1$1.forEach(layer, function(v, order) {
      root[v] = v;
      align[v] = v;
      pos[v] = order;
    });
  });

  lodash_1$1.forEach(layering, function(layer) {
    var prevIdx = -1;
    lodash_1$1.forEach(layer, function(v) {
      var ws = neighborFn(v);
      if (ws.length) {
        ws = lodash_1$1.sortBy(ws, function(w) { return pos[w]; });
        var mp = (ws.length - 1) / 2;
        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
          var w = ws[i];
          if (align[v] === v &&
              prevIdx < pos[w] &&
              !hasConflict(conflicts, v, w)) {
            align[w] = v;
            align[v] = root[v] = root[w];
            prevIdx = pos[w];
          }
        }
      }
    });
  });

  return { root: root, align: align };
}

function horizontalCompaction(g, layering, root, align, reverseSep) {
  // This portion of the algorithm differs from BK due to a number of problems.
  // Instead of their algorithm we construct a new block graph and do two
  // sweeps. The first sweep places blocks with the smallest possible
  // coordinates. The second sweep removes unused space by moving blocks to the
  // greatest coordinates without violating separation.
  var xs = {},
    blockG = buildBlockGraph(g, layering, root, reverseSep),
    borderType = reverseSep ? "borderLeft" : "borderRight";

  function iterate(setXsFunc, nextNodesFunc) {
    var stack = blockG.nodes();
    var elem = stack.pop();
    var visited = {};
    while (elem) {
      if (visited[elem]) {
        setXsFunc(elem);
      } else {
        visited[elem] = true;
        stack.push(elem);
        stack = stack.concat(nextNodesFunc(elem));
      }

      elem = stack.pop();
    }
  }

  // First pass, assign smallest coordinates
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
      return Math.max(acc, xs[e.v] + blockG.edge(e));
    }, 0);
  }

  // Second pass, assign greatest coordinates
  function pass2(elem) {
    var min = blockG.outEdges(elem).reduce(function(acc, e) {
      return Math.min(acc, xs[e.w] - blockG.edge(e));
    }, Number.POSITIVE_INFINITY);

    var node = g.node(elem);
    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min);
    }
  }

  iterate(pass1, blockG.predecessors.bind(blockG));
  iterate(pass2, blockG.successors.bind(blockG));

  // Assign x coordinates to all nodes
  lodash_1$1.forEach(align, function(v) {
    xs[v] = xs[root[v]];
  });

  return xs;
}


function buildBlockGraph(g, layering, root, reverseSep) {
  var blockGraph = new Graph$6(),
    graphLabel = g.graph(),
    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);

  lodash_1$1.forEach(layering, function(layer) {
    var u;
    lodash_1$1.forEach(layer, function(v) {
      var vRoot = root[v];
      blockGraph.setNode(vRoot);
      if (u) {
        var uRoot = root[u],
          prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
      }
      u = v;
    });
  });

  return blockGraph;
}

/*
 * Returns the alignment that has the smallest width of the given alignments.
 */
function findSmallestWidthAlignment(g, xss) {
  return lodash_1$1.minBy(lodash_1$1.values(xss), function (xs) {
    var max = Number.NEGATIVE_INFINITY;
    var min = Number.POSITIVE_INFINITY;

    lodash_1$1.forIn(xs, function (x, v) {
      var halfWidth = width(g, v) / 2;

      max = Math.max(x + halfWidth, max);
      min = Math.min(x - halfWidth, min);
    });

    return max - min;
  });
}

/*
 * Align the coordinates of each of the layout alignments such that
 * left-biased alignments have their minimum coordinate at the same point as
 * the minimum coordinate of the smallest width alignment and right-biased
 * alignments have their maximum coordinate at the same point as the maximum
 * coordinate of the smallest width alignment.
 */
function alignCoordinates(xss, alignTo) {
  var alignToVals = lodash_1$1.values(alignTo),
    alignToMin = lodash_1$1.min(alignToVals),
    alignToMax = lodash_1$1.max(alignToVals);

  lodash_1$1.forEach(["u", "d"], function(vert) {
    lodash_1$1.forEach(["l", "r"], function(horiz) {
      var alignment = vert + horiz,
        xs = xss[alignment],
        delta;
      if (xs === alignTo) return;

      var xsVals = lodash_1$1.values(xs);
      delta = horiz === "l" ? alignToMin - lodash_1$1.min(xsVals) : alignToMax - lodash_1$1.max(xsVals);

      if (delta) {
        xss[alignment] = lodash_1$1.mapValues(xs, function(x) { return x + delta; });
      }
    });
  });
}

function balance(xss, align) {
  return lodash_1$1.mapValues(xss.ul, function(ignore, v) {
    if (align) {
      return xss[align.toLowerCase()][v];
    } else {
      var xs = lodash_1$1.sortBy(lodash_1$1.map(xss, v));
      return (xs[1] + xs[2]) / 2;
    }
  });
}

function positionX(g) {
  var layering = util.buildLayerMatrix(g);
  var conflicts = lodash_1$1.merge(
    findType1Conflicts(g, layering),
    findType2Conflicts(g, layering));

  var xss = {};
  var adjustedLayering;
  lodash_1$1.forEach(["u", "d"], function(vert) {
    adjustedLayering = vert === "u" ? layering : lodash_1$1.values(layering).reverse();
    lodash_1$1.forEach(["l", "r"], function(horiz) {
      if (horiz === "r") {
        adjustedLayering = lodash_1$1.map(adjustedLayering, function(inner) {
          return lodash_1$1.values(inner).reverse();
        });
      }

      var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
      var xs = horizontalCompaction(g, adjustedLayering,
        align.root, align.align, horiz === "r");
      if (horiz === "r") {
        xs = lodash_1$1.mapValues(xs, function(x) { return -x; });
      }
      xss[vert + horiz] = xs;
    });
  });

  var smallestWidth = findSmallestWidthAlignment(g, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g.graph().align);
}

function sep(nodeSep, edgeSep, reverseSep) {
  return function(g, v, w) {
    var vLabel = g.node(v);
    var wLabel = g.node(w);
    var sum = 0;
    var delta;

    sum += vLabel.width / 2;
    if (lodash_1$1.has(vLabel, "labelpos")) {
      switch (vLabel.labelpos.toLowerCase()) {
      case "l": delta = -vLabel.width / 2; break;
      case "r": delta = vLabel.width / 2; break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;

    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;

    sum += wLabel.width / 2;
    if (lodash_1$1.has(wLabel, "labelpos")) {
      switch (wLabel.labelpos.toLowerCase()) {
      case "l": delta = wLabel.width / 2; break;
      case "r": delta = -wLabel.width / 2; break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;

    return sum;
  };
}

function width(g, v) {
  return g.node(v).width;
}

var positionX$1 = bk.positionX;

var position_1 = position;

function position(g) {
  g = util.asNonCompoundGraph(g);

  positionY(g);
  lodash_1$1.forEach(positionX$1(g), function(x, v) {
    g.node(v).x = x;
  });
}

function positionY(g) {
  var layering = util.buildLayerMatrix(g);
  var rankSep = g.graph().ranksep;
  var prevY = 0;
  lodash_1$1.forEach(layering, function(layer) {
    var maxHeight = lodash_1$1.max(lodash_1$1.map(layer, function(v) { return g.node(v).height; }));
    lodash_1$1.forEach(layer, function(v) {
      g.node(v).y = prevY + maxHeight / 2;
    });
    prevY += maxHeight + rankSep;
  });
}

var normalizeRanks$1 = util.normalizeRanks;

var removeEmptyRanks$1 = util.removeEmptyRanks;





var util$2 = util;
var Graph$7 = graphlib_1.Graph;

var layout_1$1 = layout$1;

function layout$1(g, opts) {
  var time = opts && opts.debugTiming ? util$2.time : util$2.notime;
  time("layout", function() {
    var layoutGraph = 
      time("  buildLayoutGraph", function() { return buildLayoutGraph(g); });
    time("  runLayout",        function() { runLayout(layoutGraph, time); });
    time("  updateInputGraph", function() { updateInputGraph(g, layoutGraph); });
  });
}

function runLayout(g, time) {
  time("    makeSpaceForEdgeLabels", function() { makeSpaceForEdgeLabels(g); });
  time("    removeSelfEdges",        function() { removeSelfEdges(g); });
  time("    acyclic",                function() { acyclic.run(g); });
  time("    nestingGraph.run",       function() { nestingGraph.run(g); });
  time("    rank",                   function() { rank_1(util$2.asNonCompoundGraph(g)); });
  time("    injectEdgeLabelProxies", function() { injectEdgeLabelProxies(g); });
  time("    removeEmptyRanks",       function() { removeEmptyRanks$1(g); });
  time("    nestingGraph.cleanup",   function() { nestingGraph.cleanup(g); });
  time("    normalizeRanks",         function() { normalizeRanks$1(g); });
  time("    assignRankMinMax",       function() { assignRankMinMax(g); });
  time("    removeEdgeLabelProxies", function() { removeEdgeLabelProxies(g); });
  time("    normalize.run",          function() { normalize.run(g); });
  time("    parentDummyChains",      function() { parentDummyChains_1(g); });
  time("    addBorderSegments",      function() { addBorderSegments_1(g); });
  time("    order",                  function() { order_1(g); });
  time("    insertSelfEdges",        function() { insertSelfEdges(g); });
  time("    adjustCoordinateSystem", function() { coordinateSystem.adjust(g); });
  time("    position",               function() { position_1(g); });
  time("    positionSelfEdges",      function() { positionSelfEdges(g); });
  time("    removeBorderNodes",      function() { removeBorderNodes(g); });
  time("    normalize.undo",         function() { normalize.undo(g); });
  time("    fixupEdgeLabelCoords",   function() { fixupEdgeLabelCoords(g); });
  time("    undoCoordinateSystem",   function() { coordinateSystem.undo(g); });
  time("    translateGraph",         function() { translateGraph(g); });
  time("    assignNodeIntersects",   function() { assignNodeIntersects(g); });
  time("    reversePoints",          function() { reversePointsForReversedEdges(g); });
  time("    acyclic.undo",           function() { acyclic.undo(g); });
}

/*
 * Copies final layout information from the layout graph back to the input
 * graph. This process only copies whitelisted attributes from the layout graph
 * to the input graph, so it serves as a good place to determine what
 * attributes can influence layout.
 */
function updateInputGraph(inputGraph, layoutGraph) {
  lodash_1$1.forEach(inputGraph.nodes(), function(v) {
    var inputLabel = inputGraph.node(v);
    var layoutLabel = layoutGraph.node(v);

    if (inputLabel) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;

      if (layoutGraph.children(v).length) {
        inputLabel.width = layoutLabel.width;
        inputLabel.height = layoutLabel.height;
      }
    }
  });

  lodash_1$1.forEach(inputGraph.edges(), function(e) {
    var inputLabel = inputGraph.edge(e);
    var layoutLabel = layoutGraph.edge(e);

    inputLabel.points = layoutLabel.points;
    if (lodash_1$1.has(layoutLabel, "x")) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
    }
  });

  inputGraph.graph().width = layoutGraph.graph().width;
  inputGraph.graph().height = layoutGraph.graph().height;
}

var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
var nodeNumAttrs = ["width", "height"];
var nodeDefaults = { width: 0, height: 0 };
var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
var edgeDefaults = {
  minlen: 1, weight: 1, width: 0, height: 0,
  labeloffset: 10, labelpos: "r"
};
var edgeAttrs = ["labelpos"];

/*
 * Constructs a new graph from the input graph, which can be used for layout.
 * This process copies only whitelisted attributes from the input graph to the
 * layout graph. Thus this function serves as a good place to determine what
 * attributes can influence layout.
 */
function buildLayoutGraph(inputGraph) {
  var g = new Graph$7({ multigraph: true, compound: true });
  var graph = canonicalize(inputGraph.graph());

  g.setGraph(lodash_1$1.merge({},
    graphDefaults,
    selectNumberAttrs(graph, graphNumAttrs),
    lodash_1$1.pick(graph, graphAttrs)));

  lodash_1$1.forEach(inputGraph.nodes(), function(v) {
    var node = canonicalize(inputGraph.node(v));
    g.setNode(v, lodash_1$1.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));
    g.setParent(v, inputGraph.parent(v));
  });

  lodash_1$1.forEach(inputGraph.edges(), function(e) {
    var edge = canonicalize(inputGraph.edge(e));
    g.setEdge(e, lodash_1$1.merge({},
      edgeDefaults,
      selectNumberAttrs(edge, edgeNumAttrs),
      lodash_1$1.pick(edge, edgeAttrs)));
  });

  return g;
}

/*
 * This idea comes from the Gansner paper: to account for edge labels in our
 * layout we split each rank in half by doubling minlen and halving ranksep.
 * Then we can place labels at these mid-points between nodes.
 *
 * We also add some minimal padding to the width to push the label for the edge
 * away from the edge itself a bit.
 */
function makeSpaceForEdgeLabels(g) {
  var graph = g.graph();
  graph.ranksep /= 2;
  lodash_1$1.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    edge.minlen *= 2;
    if (edge.labelpos.toLowerCase() !== "c") {
      if (graph.rankdir === "TB" || graph.rankdir === "BT") {
        edge.width += edge.labeloffset;
      } else {
        edge.height += edge.labeloffset;
      }
    }
  });
}

/*
 * Creates temporary dummy nodes that capture the rank in which each edge's
 * label is going to, if it has one of non-zero width and height. We do this
 * so that we can safely remove empty ranks while preserving balance for the
 * label's position.
 */
function injectEdgeLabelProxies(g) {
  lodash_1$1.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.width && edge.height) {
      var v = g.node(e.v);
      var w = g.node(e.w);
      var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };
      util$2.addDummyNode(g, "edge-proxy", label, "_ep");
    }
  });
}

function assignRankMinMax(g) {
  var maxRank = 0;
  lodash_1$1.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.borderTop) {
      node.minRank = g.node(node.borderTop).rank;
      node.maxRank = g.node(node.borderBottom).rank;
      maxRank = lodash_1$1.max(maxRank, node.maxRank);
    }
  });
  g.graph().maxRank = maxRank;
}

function removeEdgeLabelProxies(g) {
  lodash_1$1.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.dummy === "edge-proxy") {
      g.edge(node.e).labelRank = node.rank;
      g.removeNode(v);
    }
  });
}

function translateGraph(g) {
  var minX = Number.POSITIVE_INFINITY;
  var maxX = 0;
  var minY = Number.POSITIVE_INFINITY;
  var maxY = 0;
  var graphLabel = g.graph();
  var marginX = graphLabel.marginx || 0;
  var marginY = graphLabel.marginy || 0;

  function getExtremes(attrs) {
    var x = attrs.x;
    var y = attrs.y;
    var w = attrs.width;
    var h = attrs.height;
    minX = Math.min(minX, x - w / 2);
    maxX = Math.max(maxX, x + w / 2);
    minY = Math.min(minY, y - h / 2);
    maxY = Math.max(maxY, y + h / 2);
  }

  lodash_1$1.forEach(g.nodes(), function(v) { getExtremes(g.node(v)); });
  lodash_1$1.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (lodash_1$1.has(edge, "x")) {
      getExtremes(edge);
    }
  });

  minX -= marginX;
  minY -= marginY;

  lodash_1$1.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    node.x -= minX;
    node.y -= minY;
  });

  lodash_1$1.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    lodash_1$1.forEach(edge.points, function(p) {
      p.x -= minX;
      p.y -= minY;
    });
    if (lodash_1$1.has(edge, "x")) { edge.x -= minX; }
    if (lodash_1$1.has(edge, "y")) { edge.y -= minY; }
  });

  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY - minY + marginY;
}

function assignNodeIntersects(g) {
  lodash_1$1.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    var nodeV = g.node(e.v);
    var nodeW = g.node(e.w);
    var p1, p2;
    if (!edge.points) {
      edge.points = [];
      p1 = nodeW;
      p2 = nodeV;
    } else {
      p1 = edge.points[0];
      p2 = edge.points[edge.points.length - 1];
    }
    edge.points.unshift(util$2.intersectRect(nodeV, p1));
    edge.points.push(util$2.intersectRect(nodeW, p2));
  });
}

function fixupEdgeLabelCoords(g) {
  lodash_1$1.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (lodash_1$1.has(edge, "x")) {
      if (edge.labelpos === "l" || edge.labelpos === "r") {
        edge.width -= edge.labeloffset;
      }
      switch (edge.labelpos) {
      case "l": edge.x -= edge.width / 2 + edge.labeloffset; break;
      case "r": edge.x += edge.width / 2 + edge.labeloffset; break;
      }
    }
  });
}

function reversePointsForReversedEdges(g) {
  lodash_1$1.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.reversed) {
      edge.points.reverse();
    }
  });
}

function removeBorderNodes(g) {
  lodash_1$1.forEach(g.nodes(), function(v) {
    if (g.children(v).length) {
      var node = g.node(v);
      var t = g.node(node.borderTop);
      var b = g.node(node.borderBottom);
      var l = g.node(lodash_1$1.last(node.borderLeft));
      var r = g.node(lodash_1$1.last(node.borderRight));

      node.width = Math.abs(r.x - l.x);
      node.height = Math.abs(b.y - t.y);
      node.x = l.x + node.width / 2;
      node.y = t.y + node.height / 2;
    }
  });

  lodash_1$1.forEach(g.nodes(), function(v) {
    if (g.node(v).dummy === "border") {
      g.removeNode(v);
    }
  });
}

function removeSelfEdges(g) {
  lodash_1$1.forEach(g.edges(), function(e) {
    if (e.v === e.w) {
      var node = g.node(e.v);
      if (!node.selfEdges) {
        node.selfEdges = [];
      }
      node.selfEdges.push({ e: e, label: g.edge(e) });
      g.removeEdge(e);
    }
  });
}

function insertSelfEdges(g) {
  var layers = util$2.buildLayerMatrix(g);
  lodash_1$1.forEach(layers, function(layer) {
    var orderShift = 0;
    lodash_1$1.forEach(layer, function(v, i) {
      var node = g.node(v);
      node.order = i + orderShift;
      lodash_1$1.forEach(node.selfEdges, function(selfEdge) {
        util$2.addDummyNode(g, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node.rank,
          order: i + (++orderShift),
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      });
      delete node.selfEdges;
    });
  });
}

function positionSelfEdges(g) {
  lodash_1$1.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.dummy === "selfedge") {
      var selfNode = g.node(node.e.v);
      var x = selfNode.x + selfNode.width / 2;
      var y = selfNode.y;
      var dx = node.x - x;
      var dy = selfNode.height / 2;
      g.setEdge(node.e, node.label);
      g.removeNode(v);
      node.label.points = [
        { x: x + 2 * dx / 3, y: y - dy },
        { x: x + 5 * dx / 6, y: y - dy },
        { x: x +     dx    , y: y },
        { x: x + 5 * dx / 6, y: y + dy },
        { x: x + 2 * dx / 3, y: y + dy }
      ];
      node.label.x = node.x;
      node.label.y = node.y;
    }
  });
}

function selectNumberAttrs(obj, attrs) {
  return lodash_1$1.mapValues(lodash_1$1.pick(obj, attrs), Number);
}

function canonicalize(attrs) {
  var newAttrs = {};
  lodash_1$1.forEach(attrs, function(v, k) {
    newAttrs[k.toLowerCase()] = v;
  });
  return newAttrs;
}

var Graph$8 = graphlib_1.Graph;

var debug = {
  debugOrdering: debugOrdering
};

/* istanbul ignore next */
function debugOrdering(g) {
  var layerMatrix = util.buildLayerMatrix(g);

  var h = new Graph$8({ compound: true, multigraph: true }).setGraph({});

  lodash_1$1.forEach(g.nodes(), function(v) {
    h.setNode(v, { label: v });
    h.setParent(v, "layer" + g.node(v).rank);
  });

  lodash_1$1.forEach(g.edges(), function(e) {
    h.setEdge(e.v, e.w, {}, e.name);
  });

  lodash_1$1.forEach(layerMatrix, function(layer, i) {
    var layerV = "layer" + i;
    h.setNode(layerV, { rank: "same" });
    lodash_1$1.reduce(layer, function(u, v) {
      h.setEdge(u, v, { style: "invis" });
      return v;
    });
  });

  return h;
}

var version$1 = "0.8.5";

/*
Copyright (c) 2012-2014 Chris Pettitt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

var _dagre_0_8_5_dagre = {
  graphlib: graphlib_1,

  layout: layout_1$1,
  debug: debug,
  util: {
    time: util.time,
    notime: util.notime
  },
  version: version$1
};

var relation = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = interopRequireDefault(toConsumableArray$1);

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(graphs);

var _global = interopRequireDefault(global$1);

var _dataFrame = interopRequireDefault(dataFrame);





var _zoom = interopRequireDefault(zoom);

var _dagre = interopRequireDefault(_dagre_0_8_5_dagre);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Rect = _canvax["default"].Shapes.Rect;
var Diamond = _canvax["default"].Shapes.Diamond;
var Path = _canvax["default"].Shapes.Path;
var BrokenLine = _canvax["default"].Shapes.BrokenLine;
var Circle = _canvax["default"].Shapes.Circle;
var Arrow = _canvax["default"].Shapes.Arrow;
/**
 * 关系图中 包括了  配置，数据，和布局数据，
 * 默认用配置和数据可以完成绘图， 但是如果有布局数据，就绘图玩额外调用一次绘图，把布局数据传入修正布局效果
 */

var Relation = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(Relation, _GraphsBase);

  var _super = _createSuper(Relation);

  function Relation(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, Relation);
    _this = _super.call(this, opt, app);
    _this.type = "relation";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(Relation.defaultProps()), opt);

    if (_this.layout === 'dagre') {
      var dagreOpts = {
        graph: {
          rankdir: 'TB',
          nodesep: 10,
          ranksep: 10,
          edgesep: 10,
          acyclicer: "greedy"
        },
        node: {},
        edge: {
          labelpos: 'c' //labeloffset: 0

        }
      };

      _.extend(true, dagreOpts, _this.layoutOpts);

      _.extend(true, _this.layoutOpts, dagreOpts);

      if (!_this.rankdir) {
        _this.rankdir = _this.layoutOpts.graph.rankdir;
      } else {
        //如果有设置this.randdir 则已经 ta 为准
        _this.layoutOpts.graph.rankdir = _this.rankdir;
      }
    }
    _this.domContainer = app.canvax.domView;
    _this.induce = null;

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(Relation, [{
    key: "init",
    value: function init() {
      this._initInduce();

      this.nodesSp = new _canvax["default"].Display.Sprite({
        id: "nodesSp"
      });
      this.nodesContentSp = new _canvax["default"].Display.Sprite({
        id: "nodesContentSp"
      });
      this.edgesSp = new _canvax["default"].Display.Sprite({
        id: "edgesSp"
      });
      this.arrowsSp = new _canvax["default"].Display.Sprite({
        id: "arrowsSp"
      });
      this.labelsSp = new _canvax["default"].Display.Sprite({
        id: "labelsSp"
      });
      this.graphsSp = new _canvax["default"].Display.Sprite({
        id: "graphsSp"
      }); //这个view和induce是一一对应的，在induce上面执行拖拽和滚轮缩放，操作的目标元素就是graphsView

      this.graphsView = new _canvax["default"].Display.Sprite({
        id: "graphsView"
      });
      this.graphsSp.addChild(this.edgesSp);
      this.graphsSp.addChild(this.nodesSp);
      this.graphsSp.addChild(this.nodesContentSp);
      this.graphsSp.addChild(this.arrowsSp);
      this.graphsSp.addChild(this.labelsSp);
      this.graphsView.addChild(this.graphsSp);
      this.sprite.addChild(this.graphsView);
      this.zoom = new _zoom["default"]();
    }
  }, {
    key: "_initInduce",
    value: function _initInduce() {
      var me = this;
      this.induce = new Rect({
        id: "induce",
        context: {
          width: 0,
          height: 0,
          fillStyle: "#000000",
          globalAlpha: 0
        }
      });
      this.sprite.addChild(this.induce);
      var _mosedownIng = false;

      var _preCursor = me.app.canvax.domView ? "default" : me.app.canvax.domView.style.cursor; //滚轮缩放相关


      var _wheelHandleTimeLen = 32; //16*2

      var _wheelHandleTimeer = null;
      var _deltaY = 0;
      this.induce.on(event.types.get(), function (e) {
        if (me.status.transform.enabled) {
          e.preventDefault();
          var point = e.target.localToGlobal(e.point, me.sprite); //鼠标拖拽移动

          if (e.type == "mousedown") {
            me.induce.toFront();
            _mosedownIng = true;
            me.app.canvax.domView && (me.app.canvax.domView.style.cursor = "move");
            me.zoom.mouseMoveTo(point);
          }

          if (e.type == "mouseup" || e.type == "mouseout") {
            me.induce.toBack();
            _mosedownIng = false;
            me.app.canvax.domView && (me.app.canvax.domView.style.cursor = _preCursor);
          }

          if (e.type == "mousemove") {
            if (_mosedownIng) {
              var _me$zoom$move = me.zoom.move(point),
                  x = _me$zoom$move.x,
                  y = _me$zoom$move.y;

              me.graphsView.context.x = parseInt(x);
              me.graphsView.context.y = parseInt(y);
            }
          }

          if (e.type == "wheel") {
            if (Math.abs(e.deltaY) > Math.abs(_deltaY)) {
              _deltaY = e.deltaY;
            }

            if (!_wheelHandleTimeer) {
              _wheelHandleTimeer = setTimeout(function () {
                if (me.status.transform.wheelAction == 'offset') {
                  //移动的话用offset,偏移多少像素
                  var _me$zoom$offset = me.zoom.offset({
                    x: -e.deltaX,
                    y: -e.deltaY
                  }),
                      _x = _me$zoom$offset.x,
                      _y = _me$zoom$offset.y; //me.zoom.move( {x:zx, y:zy} );


                  me.graphsView.context.x = _x;
                  me.graphsView.context.y = _y;
                }

                if (me.status.transform.wheelAction == 'scale') {
                  // 缩放         
                  var _me$zoom$wheel = me.zoom.wheel(e, point),
                      scale = _me$zoom$wheel.scale,
                      _x2 = _me$zoom$wheel.x,
                      _y2 = _me$zoom$wheel.y;

                  me.graphsView.context.x = _x2;
                  me.graphsView.context.y = _y2;
                  me.graphsView.context.scaleX = scale;
                  me.graphsView.context.scaleY = scale;
                  me.status.transform.scale = scale;
                }

                _wheelHandleTimeer = null;
                _deltaY = 0;
              }, _wheelHandleTimeLen);
            }
          }
        }
      });
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      var _this2 = this;

      !opt && (opt = {});

      _.extend(true, this, opt);

      this._initData(opt.data).then(function (data) {
        _this2.data = data;

        _this2._layoutData();

        _this2.widget();

        _this2.induce.context.width = _this2.width;
        _this2.induce.context.height = _this2.height;
        _this2.sprite.context.x = parseInt(_this2.origin.x);
        _this2.sprite.context.y = parseInt(_this2.origin.y);

        var _offsetLeft = (_this2.width - _this2.data.size.width) / 2;

        if (_offsetLeft < 0) {
          _offsetLeft = 0;
        }

        var _offsetTop = (_this2.height - _this2.data.size.height) / 2;

        if (_offsetTop < 0) {
          _offsetTop = 0;
        }
        _this2.graphsSp.context.x = parseInt(_offsetLeft);
        _this2.graphsSp.context.y = parseInt(_offsetTop);

        _this2.fire("complete");
      });
    } //如果dataTrigger.origin 有传入， 则已经这个origin为参考点做重新布局
    //TODO， 如果这个图的options中有配置 一个 符合 关系图的数据{nodes, edges, size}
    //那么这个时候的resetData还不能满足，因为resetData的第一个个参数是dataFrame， 而options.data其实已经算是配置了，
    //后面遇到这个情况再调整吧

  }, {
    key: "resetData",
    value: function resetData(dataFrame, dataTrigger) {
      var _this3 = this;

      this._resetData(dataFrame, dataTrigger).then(function () {
        _this3.fire("complete");
      });
    }
  }, {
    key: "_resetData",
    value: function _resetData(data, dataTrigger) {
      var _this4 = this;

      var me = this;
      this._preData = this.data;
      return new Promise(function (resolve) {
        _this4._initData(data).then(function (_data) {
          _this4.data = _data;

          _this4._layoutData();

          _.each(_this4._preData.nodes, function (preNode) {
            var nodeData = _.find(me.data.nodes, function (node) {
              return preNode.key == node.key;
            });

            if (!nodeData) {
              me._destroy(preNode);
            } else {
              //如果找到了，要从前面
              nodeData.focused = preNode.focused;
              nodeData.selected = preNode.selected;
            }
          });

          _.each(_this4._preData.edges, function (preEdge) {
            if (!_.find(me.data.edges, function (edge) {
              return preEdge.key.join('_') == edge.key.join('_');
            })) {
              me._destroy(preEdge);
            }
          });

          _this4.widget();

          if (dataTrigger) {
            var origin = dataTrigger.origin || (dataTrigger.params || {}).origin; //兼容老的配置里面没有params，直接传origin的情况
            //钉住某个node为参考点（不移动)

            if (origin != undefined) {
              var preOriginNode = _.find(_this4._preData.nodes, function (node) {
                return node.key == origin;
              });

              var originNode = _.find(_this4.data.nodes, function (node) {
                return node.key == origin;
              });

              if (preOriginNode && originNode) {
                var offsetPos = {
                  x: parseInt(preOriginNode.x) - parseInt(originNode.x),
                  y: parseInt(preOriginNode.y) - parseInt(originNode.y)
                };

                var _this4$zoom$offset = _this4.zoom.offset(offsetPos),
                    x = _this4$zoom$offset.x,
                    y = _this4$zoom$offset.y;

                me.graphsView.context.x = parseInt(x);
                me.graphsView.context.y = parseInt(y);
              }
            }
          }
          resolve();
        });
      });
    }
  }, {
    key: "_destroy",
    value: function _destroy(item) {
      item.shapeElement && item.shapeElement.destroy();

      if (item.contentElement.destroy) {
        item.contentElement.destroy();
      } else {
        //否则就可定是个dom
        this.domContainer.removeChild(item.contentElement);
      }

      item.pathElement && item.pathElement.destroy();
      item.labelElement && item.labelElement.destroy();
      item.arrowElement && item.arrowElement.destroy();
      item.edgeIconElement && item.edgeIconElement.destroy();
      item.edgeIconBack && item.edgeIconBack.destroy();
    }
  }, {
    key: "_getDefNode",
    value: function _getDefNode() {
      var node = {
        type: "relation",
        iNode: 0,
        rowData: null,
        key: "",
        content: '',
        _contentInited: false,
        ctype: 'canvas',
        //下面三个属性在_setElementAndSize中设置
        contentElement: null,
        //外面传的layout数据可能没有element，widget的时候要检测下
        width: null,
        height: null,
        //这个在layout的时候设置
        x: null,
        y: null,
        shapeType: null,
        //如果是edge，要填写这两节点
        source: null,
        target: null,
        focused: false,
        selected: false
      };
      return node;
    } //$data如果用户设置了符合data的数据格式数据{nodes, edges, size}，那就直接返回

  }, {
    key: "_initData",
    value: function _initData($data) {
      var _this5 = this;

      return new Promise(function (resolve) {
        if ($data && $data.nodes && $data.edges) {
          resolve($data);
          return;
        }
        var data$1 = {
          //{ type,key,content,ctype,width,height,x,y }
          nodes: [],
          //{ type,key[],content,ctype,width,height,x,y }
          edges: [],
          size: {
            width: 0,
            height: 0
          }
        };
        var originData = _this5.app._data;

        if ((0, data.checkDataIsJson)(originData, _this5.field, _this5.childrenField)) {
          _this5.jsonData = (0, data.jsonToArrayForRelation)(originData, _this5, _this5.childrenField);
          _this5.dataFrame = _this5.app.dataFrame = (0, _dataFrame["default"])(_this5.jsonData, _this5);
        } else {
          if (_this5.layout == "tree") {
            //源数据就是图表标准数据，只需要转换成json的Children格式
            //app.dataFrame.jsonOrg ==> [{name: key:} ...] 不是children的树结构
            _this5.jsonData = (0, data.arrayToTreeJsonForRelation)(JSON.parse(JSON.stringify(_this5.app.dataFrame.jsonOrg)), _this5);
          }
        }

        for (var i = 0; i < _this5.dataFrame.length; i++) {
          var rowData = _this5.dataFrame.getRowDataAt(i);

          var fields = _.flatten([(rowData[_this5.field] + "").split(",")]);

          var content = _this5._getContent(rowData);

          var node = _this5._getDefNode();

          Object.assign(node, {
            iNode: i,
            rowData: rowData,
            key: fields.length == 1 ? fields[0] : fields,
            content: content,
            ctype: _this5._checkHtml(content) ? 'html' : 'canvas'
          });

          if (fields.length == 1) {
            //isNode
            node.shapeType = _this5.getProp(_this5.node.shapeType, node);
            Object.assign(node, _this5.layoutOpts.node);
            data$1.nodes.push(node);
          } else {
            // isEdge
            node.shapeType = _this5.getProp(_this5.line.shapeType, node);
            Object.assign(node, _this5.layoutOpts.edge);
            data$1.edges.push(node);
          }
        }

        _this5._initAllDataSize(data$1).then(function (data) {
          resolve(data);
        });
      });
    }
  }, {
    key: "_initAllDataSize",
    value: function _initAllDataSize(data) {
      var _this6 = this;

      return new Promise(function (resolve) {
        var _nodeMap = {};
        var initNum = 0;
        data.nodes.concat(data.edges).forEach(function (node) {
          _nodeMap[node.key] = node; //计算和设置node的尺寸

          _this6._initContentAndGetSize(node).then(function (opt) {
            _.extend(node, opt); //如果是菱形，还需要重新调整新的尺寸


            if (node.shapeType == 'diamond') {
              //因为node的尺寸前面计算出来的是矩形的尺寸，如果是菱形的话，这里就是指内接矩形的尺寸，
              //需要换算成外接矩形的尺寸
              var innerRect = {
                //内接矩形
                width: node.width,
                height: node.height
              };
              var includedAngle = _this6.node.includedAngle / 2;
              var includeRad = includedAngle * Math.PI / 180;
              var newWidthDiff = innerRect.height / Math.tan(includeRad);
              var newHeightDiff = innerRect.width * Math.tan(includeRad); //在内接矩形基础上扩展出来的外界矩形

              var newWidth = innerRect.width + newWidthDiff;
              var newHeight = innerRect.height + newHeightDiff; //把新的菱形的外界边界回写

              node._innerRect = {
                width: node.width,
                height: node.height
              };
              node.width = newWidth;
              node.height = newHeight;
            }
            node._contentInited = true;
            initNum++; //如果所有的node的size都初始化完毕

            if (initNum == data.nodes.length + data.edges.length) {
              //all is inited
              //然后给edge填写source 和 target
              _.each(data.edges, function (edge) {
                var keys = edge.key;
                edge.source = _nodeMap[keys[0]];
                edge.target = _nodeMap[keys[1]];
              });

              resolve(data);
            }
          });
        });
      });
    }
  }, {
    key: "_layoutData",
    value: function _layoutData() {
      if (this.layout == "dagre") {
        this._dagreLayout(this.data);
      } else if (this.layout == "tree") {
        this._treeLayout(this.data);
      } else if (_.isFunction(this.layout)) {
        //layout需要设置好data中nodes的xy， 以及edges的points，和 size的width，height
        this.layout(this.data);
      }
    }
  }, {
    key: "_dagreLayout",
    value: function _dagreLayout(data) {
      //https://github.com/dagrejs/dagre/wiki
      var layout = _global["default"].layout.dagre || _dagre["default"];
      var g = new layout.graphlib.Graph();
      g.setGraph(this.layoutOpts.graph);
      g.setDefaultEdgeLabel(function () {
        //其实我到现在都还没搞明白setDefaultEdgeLabel的作用
        return {};
      });

      _.each(data.nodes, function (node) {
        g.setNode(node.key, node);
      });

      _.each(data.edges, function (edge) {
        //后面的参数直接把edge对象传入进去的话，setEdge会吧point 和 x y 等信息写回edge
        g.setEdge.apply(g, (0, _toConsumableArray2["default"])(edge.key).concat([edge])); //g.setEdge(edge.key[0],edge.key[1]);
      });

      layout.layout(g);
      data.size.width = g.graph().width;
      data.size.height = g.graph().height; //this.g = g;

      return data;
    } //TODO: 待实现，目前其实用dagre可以直接实现tree，但是如果可以用更加轻便的tree也可以尝试下

  }, {
    key: "_treeLayout",
    value: function _treeLayout() {// let tree = global.layout.tree().separation(function(a, b) {
      //     //设置横向节点之间的间距
      //     let totalWidth = a.width + b.width;
      //     return (totalWidth/2) + 10;
      // });
      // let nodes = tree.nodes( this.jsonData[0] ).reverse();
      // let links = tree.links(nodes);
    }
  }, {
    key: "widget",
    value: function widget() {
      /*
      me.g.edges().forEach( e => {
          let edge = me.g.edge(e);
          console.log( edge )
      } );
      */
      this._drawEdges();

      this._drawNodes();
    } //画布偏移量

  }, {
    key: "offset",
    value: function offset() {
      var _offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        x: 0,
        y: 0
      };

      var _this$zoom$offset = this.zoom.offset(_offset),
          x = _this$zoom$offset.x,
          y = _this$zoom$offset.y;

      this.graphsView.context.x = parseInt(x);
      this.graphsView.context.y = parseInt(y);
    } //把某个节点移动到居中位置

  }, {
    key: "setNodeToCenter",
    value: function setNodeToCenter(key) {
      var nodeData = this.getNodeDataAt(key);

      if (nodeData) {
        var globalPos = nodeData.shapeElement.localToGlobal();
        var toGlobalPos = {
          x: this.app.width / 2 - nodeData.width / 2,
          y: this.app.height / 2 - nodeData.height / 2
        };
        var toCenterOffset = {
          x: parseInt(toGlobalPos.x - globalPos.x),
          y: parseInt(toGlobalPos.y - globalPos.y)
        };
        this.offset(toCenterOffset);
      }
    }
  }, {
    key: "_drawEdges",
    value: function _drawEdges() {
      var me = this;

      _.each(this.data.edges, function (edge) {
        var key = edge.key.join('_');

        if (me.line.isTree && edge.points.length == 3) {
          //严格树状图的话（三个点），就转化成4个点的，有两个拐点
          me._setTreePoints(edge);
        }

        var lineShapeOpt = me._getLineShape(edge, me.line.inflectionRadius);

        var type = lineShapeOpt.type;
        var path = lineShapeOpt.path;
        var pointList = lineShapeOpt.pointList;
        var shape = type == 'path' ? Path : BrokenLine;
        var lineWidth = me.getProp(me.line.lineWidth, edge);
        var strokeStyle = me.getProp(me.line.strokeStyle, edge);
        var lineType = me.getProp(me.line.lineType, edge);
        var cursor = me.getProp(me.line.cursor, edge);
        var edgeId = 'edge_' + key;

        var _path = me.edgesSp.getChildById(edgeId);

        if (_path) {
          if (type == 'path') {
            _path.context.path = path;
          }

          if (type == 'brokenLine') {
            _path.context.pointList = pointList;
          }

          _path.context.lineWidth = lineWidth;
          _path.context.strokeStyle = strokeStyle;
          _path.context.lineType = lineType;
        } else {
          var _ctx = {
            lineWidth: lineWidth,
            strokeStyle: strokeStyle,
            lineType: lineType,
            cursor: cursor
          };

          if (type == 'path') {
            _ctx.path = path;
          }

          if (type == 'brokenLine') {
            //_ctx.smooth = true;
            //_ctx.curvature = 0.25;
            _ctx.pointList = pointList;
          }

          _path = new shape({
            id: edgeId,
            context: _ctx
          });

          _path.on(event.types.get(), function (e) {
            var node = this.nodeData;
            node.__no_value = true;
            e.eventInfo = {
              trigger: me.line,
              nodes: [node]
            };
            me.app.fire(e.type, e);
          });

          me.edgesSp.addChild(_path);
        }
        edge.pathElement = _path;
        _path.nodeData = edge; //edge也是一个node数据

        var arrowControl = edge.points.slice(-2, -1)[0];

        if (me.line.shapeType == "bezier") {
          if (me.rankdir == "TB" || me.rankdir == "BT") {
            arrowControl.x += (edge.source.x - edge.target.x) / 20;
          }

          if (me.rankdir == "LR" || me.rankdir == "RL") {
            arrowControl.y += (edge.source.y - edge.target.y) / 20;
          }
        }
        var edgeLabelId = 'label_' + key;
        var enabled = me.getProp(me.line.edgeLabel.enabled, edge);

        if (enabled) {
          var textAlign = me.getProp(me.node.content.textAlign, edge);
          var textBaseline = me.getProp(me.node.content.textBaseline, edge);
          var fontSize = me.getProp(me.line.edgeLabel.fontSize, edge);
          var fontColor = me.getProp(me.line.edgeLabel.fontColor, edge); // let offsetX      = me.getProp( me.line.edgeLabel.offsetX    , edge );
          // let offsetY      = me.getProp( me.line.edgeLabel.offsetY    , edge );

          var offset = me.getProp(me.line.icon.offset, edge);

          if (!offset) {
            //default 使用edge.x edge.y 也就是edge label的位置
            offset = {
              x: edge.x,
              y: edge.y
            };
          }

          var _edgeLabel = me.labelsSp.getChildById(edgeLabelId);

          if (_edgeLabel) {
            _edgeLabel.resetText(edge.content);

            _edgeLabel.context.x = offset.x;
            _edgeLabel.context.y = offset.y;
            _edgeLabel.context.fontSize = fontSize;
            _edgeLabel.context.fillStyle = fontColor;
            _edgeLabel.context.textAlign = textAlign;
            _edgeLabel.context.textBaseline = textBaseline;
          } else {
            _edgeLabel = new _canvax["default"].Display.Text(edge.content, {
              id: edgeLabelId,
              context: {
                x: offset.x,
                y: offset.y,
                fontSize: fontSize,
                fillStyle: fontColor,
                textAlign: textAlign,
                textBaseline: textBaseline
              }
            });

            _edgeLabel.on(event.types.get(), function (e) {
              var node = this.nodeData;
              node.__no_value = true;
              e.eventInfo = {
                trigger: me.line,
                nodes: [node]
              };
              me.app.fire(e.type, e);
            });

            me.labelsSp.addChild(_edgeLabel);
          }

          edge.labelElement = _edgeLabel;
          _edgeLabel.nodeData = edge;
        }
        var edgeIconEnabled = me.getProp(me.line.icon.enabled, edge);

        if (edgeIconEnabled) {
          var _chartCode = me.getProp(me.line.icon.charCode, edge);

          var charCode = String.fromCharCode(parseInt(_chartCode, 16));

          if (_chartCode != '') {
            var _lineWidth = me.getProp(me.line.icon.lineWidth, edge);

            var _strokeStyle = me.getProp(me.line.icon.strokeStyle, edge);

            var fontFamily = me.getProp(me.line.icon.fontFamily, edge);

            var _fontSize = me.getProp(me.line.icon.fontSize, edge);

            var _fontColor = me.getProp(me.line.icon.fontColor, edge);

            var background = me.getProp(me.line.icon.background, edge);
            var _textAlign = 'center';
            var _textBaseline = 'middle';

            var _offset2 = me.getProp(me.line.icon.offset, edge);

            var offsetX = me.getProp(me.line.icon.offsetX, edge);
            var offsetY = me.getProp(me.line.icon.offsetY, edge);

            if (!_offset2) {
              //default 使用edge.x edge.y 也就是edge label的位置
              _offset2 = {
                x: parseInt(edge.x) + offsetX,
                y: parseInt(edge.y) + offsetY
              };
            }
            var _iconBackCtx = {
              x: _offset2.x,
              y: _offset2.y - 1,
              r: parseInt(_fontSize * 0.5) + 2,
              fillStyle: background,
              strokeStyle: _strokeStyle,
              lineWidth: _lineWidth
            };
            var edgeIconBackId = 'edge_item_icon_back_' + key;

            var _iconBack = me.labelsSp.getChildById(edgeIconBackId);

            if (_iconBack) {
              //_.extend( true, _iconBack.context, _iconBackCtx )
              Object.assign(_iconBack.context, _iconBackCtx);
            } else {
              _iconBack = new Circle({
                id: edgeIconBackId,
                context: _iconBackCtx
              });
              me.labelsSp.addChild(_iconBack);
            }
            edge.edgeIconBack = _iconBack;
            _iconBack.nodeData = edge;
            var edgeIconId = 'edge_item_icon_' + key;

            var _edgeIcon = me.labelsSp.getChildById(edgeIconId);

            if (_edgeIcon) {
              _edgeIcon.resetText(charCode);

              _edgeIcon.context.x = _offset2.x;
              _edgeIcon.context.y = _offset2.y;
              _edgeIcon.context.fontSize = _fontSize;
              _edgeIcon.context.fillStyle = _fontColor;
              _edgeIcon.context.textAlign = _textAlign;
              _edgeIcon.context.textBaseline = _textBaseline;
              _edgeIcon.context.fontFamily = fontFamily; //_edgeIcon.context.lineWidth    = lineWidth;
              //_edgeIcon.context.strokeStyle  = strokeStyle;
            } else {
              _edgeIcon = new _canvax["default"].Display.Text(charCode, {
                id: edgeIconId,
                context: {
                  x: _offset2.x,
                  y: _offset2.y,
                  fillStyle: _fontColor,
                  cursor: 'pointer',
                  fontSize: _fontSize,
                  textAlign: _textAlign,
                  textBaseline: _textBaseline,
                  fontFamily: fontFamily
                }
              });

              _edgeIcon.on(event.types.get(), function (e) {
                var node = this.nodeData;
                node.__no_value = true;
                var trigger = me.line;

                if (me.line.icon['on' + e.type]) {
                  trigger = me.line.icon;
                }
                e.eventInfo = {
                  trigger: trigger,
                  nodes: [node]
                };
                me.app.fire(e.type, e);
              });

              me.labelsSp.addChild(_edgeIcon);
            }

            edge.edgeIconElement = _edgeIcon;
            _edgeIcon.nodeData = edge;
          }
        }

        if (me.line.arrow.enabled) {
          var arrowId = "arrow_" + key;

          var _arrow = me.arrowsSp.getChildById(arrowId);

          if (_arrow) {
            //arrow 只监听了x y 才会重绘，，，暂时只能这样处理,手动的赋值control.x control.y
            //而不是直接把 arrowControl 赋值给 control
            _arrow.context.x = me.line.arrow.offsetX;
            _arrow.context.y = me.line.arrow.offsetY;
            _arrow.context.fillStyle = strokeStyle;
            _arrow.context.control.x = arrowControl.x;
            _arrow.context.control.y = arrowControl.y;
            _arrow.context.point = edge.points.slice(-1)[0];
            _arrow.context.strokeStyle = strokeStyle;
            _arrow.context.fillStyle = strokeStyle; // _.extend(true, _arrow, {
            //     control: arrowControl,
            //     point: edge.points.slice(-1)[0],
            //     strokeStyle: strokeStyle
            // } );
          } else {
            _arrow = new Arrow({
              id: arrowId,
              context: {
                x: me.line.arrow.offsetX,
                y: me.line.arrow.offsetY,
                control: arrowControl,
                point: edge.points.slice(-1)[0],
                strokeStyle: strokeStyle,
                fillStyle: strokeStyle
              }
            });
            me.arrowsSp.addChild(_arrow);
          }
          edge.arrowElement = _arrow;
        }
      });
    }
  }, {
    key: "_drawNodes",
    value: function _drawNodes() {
      var me = this;

      _.each(this.data.nodes, function (node) {
        me._drawNode(node);
      });
    }
  }, {
    key: "_drawNode",
    value: function _drawNode(node) {
      var me = this;
      var shape = Rect;
      var nodeId = "node_" + node.key;
      var cursor = me.node.cursor;

      var _me$_getNodeStyle = me._getNodeStyle(node),
          lineWidth = _me$_getNodeStyle.lineWidth,
          fillStyle = _me$_getNodeStyle.fillStyle,
          strokeStyle = _me$_getNodeStyle.strokeStyle,
          radius = _me$_getNodeStyle.radius,
          shadowOffsetX = _me$_getNodeStyle.shadowOffsetX,
          shadowOffsetY = _me$_getNodeStyle.shadowOffsetY,
          shadowBlur = _me$_getNodeStyle.shadowBlur,
          shadowColor = _me$_getNodeStyle.shadowColor;

      var context = {
        x: parseInt(node.x) - parseInt(node.width / 2),
        y: parseInt(node.y) - parseInt(node.height / 2),
        width: node.width,
        height: node.height,
        cursor: cursor,
        lineWidth: lineWidth,
        fillStyle: fillStyle,
        strokeStyle: strokeStyle,
        radius: radius,
        shadowOffsetX: shadowOffsetX,
        shadowOffsetY: shadowOffsetY,
        shadowBlur: shadowBlur,
        shadowColor: shadowColor
      };

      if (node.shapeType == 'diamond') {
        shape = Diamond;
        context = {
          x: parseInt(node.x),
          y: parseInt(node.y),
          cursor: cursor,
          innerRect: node._innerRect,
          lineWidth: lineWidth,
          fillStyle: fillStyle,
          strokeStyle: strokeStyle,
          shadowOffsetX: shadowOffsetX,
          shadowOffsetY: shadowOffsetY,
          shadowBlur: shadowBlur,
          shadowColor: shadowColor
        };
      }

      var _boxShape = me.nodesSp.getChildById(nodeId);

      if (_boxShape) {
        _.extend(_boxShape.context, context);
      } else {
        _boxShape = new shape({
          id: nodeId,
          hoverClone: false,
          context: context
        });
        me.nodesSp.addChild(_boxShape);

        _boxShape.on(event.types.get(), function (e) {
          var node = this.nodeData;
          node.__no_value = true;
          e.eventInfo = {
            trigger: me.node,
            nodes: [node]
          };

          if (me.node.focus.enabled) {
            if (e.type == "mouseover") {
              me.focusAt(this.nodeData);
            }

            if (e.type == "mouseout") {
              me.unfocusAt(this.nodeData);
            }
          }

          if (me.node.select.enabled && me.node.select.triggerEventType.indexOf(e.type) > -1) {
            //如果开启了图表的选中交互
            //TODO:这里不能
            var onbefore = me.node.select.onbefore;
            var onend = me.node.select.onend;

            if (!onbefore || typeof onbefore == 'function' && onbefore.apply(me, [this.nodeData]) !== false) {
              if (this.nodeData.selected) {
                //说明已经选中了
                me.unselectAt(this.nodeData);
              } else {
                me.selectAt(this.nodeData);
              }

              onend && typeof onend == 'function' && onend.apply(me, [this.nodeData]);
            }
          }
          me.app.fire(e.type, e);
        });
      }
      _boxShape.nodeData = node;
      node.shapeElement = _boxShape;

      if (me.node.select.list.indexOf(node.key) > -1) {
        me.selectAt(node);
      }

      if (node.ctype == "canvas") {
        node.contentElement.context.visible = true;
      }

      _boxShape.on("transform", function () {
        if (node.ctype == "canvas") {
          node.contentElement.context.x = parseInt(node.x);
          node.contentElement.context.y = parseInt(node.y);
        } else if (node.ctype == "html") {
          var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;

          var contentMatrix = _boxShape.worldTransform.clone();

          contentMatrix = contentMatrix.scale(1 / devicePixelRatio, 1 / devicePixelRatio);
          node.contentElement.style.transform = "matrix(" + contentMatrix.toArray().join() + ")";
          node.contentElement.style.transformOrigin = "left top"; //修改为左上角为旋转中心点来和canvas同步

          if (node.shapeType == 'diamond') {
            node.contentElement.style.left = -parseInt(node._innerRect.width / 2 * me.status.transform.scale) + "px";
            node.contentElement.style.top = -parseInt(node._innerRect.height / 2 * me.status.transform.scale) + "px";
          }
          node.contentElement.style.visibility = "visible";
        }
      });
    }
  }, {
    key: "_getNodeStyle",
    value: function _getNodeStyle(nodeData, targetPath) {
      var me = this;

      var radius = _.flatten([me.getProp(me.node.radius, nodeData)]);

      var target = me.node;

      if (targetPath == 'select') {
        target = me.node.select;
      }

      if (targetPath == 'focus') {
        target = me.node.focus;
      }

      var lineWidth = me.getProp(target.lineWidth, nodeData);
      var fillStyle = me.getProp(target.fillStyle, nodeData);
      var strokeStyle = me.getProp(target.strokeStyle, nodeData);
      var shadowOffsetX = me.getProp(target.shadow.shadowOffsetX, nodeData);
      var shadowOffsetY = me.getProp(target.shadow.shadowOffsetY, nodeData);
      var shadowBlur = me.getProp(target.shadow.shadowBlur, nodeData);
      var shadowColor = me.getProp(target.shadow.shadowColor, nodeData);
      return {
        lineWidth: lineWidth,
        fillStyle: fillStyle,
        strokeStyle: strokeStyle,
        radius: radius,
        shadowOffsetX: shadowOffsetX,
        shadowOffsetY: shadowOffsetY,
        shadowBlur: shadowBlur,
        shadowColor: shadowColor
      };
    }
  }, {
    key: "_setNodeStyle",
    value: function _setNodeStyle(nodeData, targetPath) {
      var _this$_getNodeStyle = this._getNodeStyle(nodeData, targetPath),
          lineWidth = _this$_getNodeStyle.lineWidth,
          fillStyle = _this$_getNodeStyle.fillStyle,
          strokeStyle = _this$_getNodeStyle.strokeStyle,
          shadowOffsetX = _this$_getNodeStyle.shadowOffsetX,
          shadowOffsetY = _this$_getNodeStyle.shadowOffsetY,
          shadowBlur = _this$_getNodeStyle.shadowBlur,
          shadowColor = _this$_getNodeStyle.shadowColor;

      if (nodeData.shapeElement && nodeData.shapeElement.context) {
        var ctx = nodeData.shapeElement.context;
        ctx.lineWidth = lineWidth;
        ctx.fillStyle = fillStyle;
        ctx.strokeStyle = strokeStyle;
        ctx.shadowOffsetX = shadowOffsetX;
        ctx.shadowOffsetY = shadowOffsetY;
        ctx.shadowBlur = shadowBlur;
        ctx.shadowColor = shadowColor;
      }
    }
  }, {
    key: "focusAt",
    value: function focusAt(key) {
      var nodeData = this.getNodeDataAt(key);

      if (nodeData) {
        !nodeData.selected && this._setNodeStyle(nodeData, 'focus');
        nodeData.focused = true;
      }
    }
  }, {
    key: "unfocusAt",
    value: function unfocusAt(key) {
      var nodeData = this.getNodeDataAt(key);

      if (nodeData) {
        !nodeData.selected && this._setNodeStyle(nodeData);
        nodeData.focused = false;
      }
    }
  }, {
    key: "selectAt",
    value: function selectAt(key) {
      var nodeData = this.getNodeDataAt(key);

      if (nodeData) {
        this._setNodeStyle(nodeData, 'select');

        nodeData.selected = true;

        if (this.node.select.list.indexOf(nodeData.key) == -1) {
          this.node.select.list.push(nodeData.key);
        }
      }
    }
  }, {
    key: "selectAll",
    value: function selectAll() {
      var _this7 = this;

      this.data.nodes.forEach(function (nodeData) {
        _this7.selectAt(nodeData);
      });
    }
  }, {
    key: "unselectAt",
    value: function unselectAt(key) {
      var nodeData = this.getNodeDataAt(key);

      if (nodeData) {
        nodeData.focused ? this._setNodeStyle(nodeData, 'focus') : this._setNodeStyle(nodeData);
        nodeData.selected = false;
        var selectedKeyInd = this.node.select.list.indexOf(nodeData.key);

        if (selectedKeyInd > -1) {
          this.node.select.list.splice(selectedKeyInd, 1);
        }
      }
    }
  }, {
    key: "unselectAll",
    value: function unselectAll() {
      var _this8 = this;

      this.data.nodes.forEach(function (nodeData) {
        _this8.unselectAt(nodeData);
      });
    }
  }, {
    key: "getNodeDataAt",
    value: function getNodeDataAt(key) {
      if (key.type && (key.type == "relation" || key.type == "tree")) {
        return key;
      }

      if (typeof key == 'string') {
        var keys = key.split(',');

        if (keys.length == 1) {
          return this.data.nodes.find(function (item) {
            return item.key == key;
          });
        }

        if (keys.length == 2) {
          return this.data.edges.find(function (item) {
            return item.key.join() == keys.join();
          });
        }
      }
    }
  }, {
    key: "_setTreePoints",
    value: function _setTreePoints(edge) {
      var points = edge.points;

      if (this.rankdir == "TB" || this.rankdir == "BT") {
        points[0] = {
          x: edge.source.x,
          y: edge.source.y + (this.rankdir == "BT" ? -1 : 1) * edge.source.height / 2
        };
        points.splice(1, 0, {
          x: edge.source.x,
          y: points.slice(-2, -1)[0].y
        });
      }

      if (this.rankdir == "LR" || this.rankdir == "RL") {
        points[0] = {
          x: edge.source.x + (this.rankdir == "RL" ? -1 : 1) * edge.source.width / 2,
          y: edge.source.y
        };
        points.splice(1, 0, {
          x: points.slice(-2, -1)[0].x,
          y: edge.source.y
        });
      }

      edge.points = points;
    }
    /**
     * 
     * @param {shapeType,points} edge 
     * @param {number} inflectionRadius 拐点的圆角半径
     */

  }, {
    key: "_getLineShape",
    value: function _getLineShape(edge, inflectionRadius) {
      var points = edge.points;
      var line = {
        type: 'path',
        // pah or brokenLine
        pointList: null,
        path: str
      };
      var head = points[0];
      var tail = points.slice(-1)[0];
      var str = "M" + head.x + " " + head.y;

      if (edge.shapeType == "bezier") {
        if (points.length == 3) {
          str += ",Q" + points[1].x + " " + points[1].y + " " + tail.x + " " + tail.y;
        }

        if (points.length == 4) {
          str += ",C" + points[1].x + " " + points[1].y + " " + points[2].x + " " + points[2].y + " " + tail.x + " " + tail.y;
        }

        if (points.length >= 5) {
          line.type = 'brokenLine';
          line.pointList = points.map(function (item) {
            return [item.x, item.y];
          });
          return line;
        }
      }

      if (edge.shapeType == "brokenLine") {
        _.each(points, function (point, i) {
          if (i) {
            if (inflectionRadius && i < points.length - 1) {
              //圆角连线
              var prePoint = points[i - 1];
              var nextPoint = points[i + 1]; //要从这个点到上个点的半径距离，已point为控制点，绘制nextPoint的半径距离

              var radius = inflectionRadius; //radius要做次二次校验，取radius 以及 point 和prePoint距离以及和 nextPoint 的最小值
              //let _disPre = Math.abs(Math.sqrt( (prePoint.x - point.x)*(prePoint.x - point.x) + (prePoint.y - point.y)*(prePoint.y - point.y) ));
              //let _disNext = Math.abs(Math.sqrt( (nextPoint.x - point.x)*(nextPoint.x - point.x) + (nextPoint.y - point.y)*(nextPoint.y - point.y) ));

              var _disPre = Math.max(Math.abs(prePoint.x - point.x) / 2, Math.abs(prePoint.y - point.y) / 2);

              var _disNext = Math.max(Math.abs(nextPoint.x - point.x) / 2, Math.abs(nextPoint.y - point.y) / 2);

              radius = _.min([radius, _disPre, _disNext]); //console.log(Math.atan2( point.y - prePoint.y , point.x - prePoint.x ),Math.atan2( nextPoint.y - point.y , nextPoint.x - point.x ))

              if (point.x == prePoint.x && point.y == prePoint.y || point.x == nextPoint.x && point.y == nextPoint.y || Math.atan2(point.y - prePoint.y, point.x - prePoint.x) == Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x)) {
                //如果中间的这个点 ， 和前后的点在一个直线上面，就略过
                return;
              } else {
                var getPointOf = function getPointOf(p) {
                  var _atan2 = Math.atan2(p.y - point.y, p.x - point.x);

                  return {
                    x: point.x + radius * Math.cos(_atan2),
                    y: point.y + radius * Math.sin(_atan2)
                  };
                };
                var bezierBegin = getPointOf(prePoint);
                var bezierEnd = getPointOf(nextPoint);
                str += ",L" + bezierBegin.x + " " + bezierBegin.y + ",Q" + point.x + " " + point.y + " " + bezierEnd.x + " " + bezierEnd.y;
              }
            } else {
              //直角连线
              str += ",L" + point.x + " " + point.y;
            }
          }
        });
      }
      line.path = str; //str += "z"

      return line;
    }
    /**
     * 字符串是否含有html标签的检测
     */

  }, {
    key: "_checkHtml",
    value: function _checkHtml(str) {
      var reg = /<[^>]+>/g;
      return reg.test(str);
    }
  }, {
    key: "_getContent",
    value: function _getContent(rowData) {
      var me = this;

      var _c; //this.node.content;


      var field = this.node.content.field;

      if (this._isField(field)) {
        _c = rowData[field];
      }

      if (me.node.content.format && _.isFunction(me.node.content.format)) {
        _c = me.node.content.format.apply(this, [_c, rowData]);
      } else {
        //否则用fieldConfig上面的
        var _coord = me.app.getComponent({
          name: 'coord'
        });

        var fieldConfig = _coord.getFieldConfig(field);

        if (fieldConfig) {
          _c = fieldConfig.getFormatValue(_c);
        }
      }

      return _c;
    }
  }, {
    key: "_isField",
    value: function _isField(str) {
      return ~this.dataFrame.fields.indexOf(str);
    }
  }, {
    key: "_initContentAndGetSize",
    value: function _initContentAndGetSize(node) {
      var me = this;
      var contentType = node.ctype;

      if (me._isField(contentType)) {
        contentType = node.rowData[contentType];
      }
      !contentType && (contentType = 'canvas');

      if (contentType == 'canvas') {
        return me._getEleAndsetCanvasSize(node);
      }

      if (contentType == 'html') {
        return me._getEleAndsetHtmlSize(node);
      }
    }
  }, {
    key: "_getEleAndsetCanvasSize",
    value: function _getEleAndsetCanvasSize(node) {
      var _this9 = this;

      var me = this;
      return new Promise(function (resolve) {
        var content = node.content;
        var width = node.rowData.width,
            height = node.rowData.height; //let sprite = new Canvax.Display.Sprite({});

        var context = {
          fillStyle: me.getProp(me.node.content.fontColor, node),
          textAlign: me.getProp(me.node.content.textAlign, node),
          textBaseline: me.getProp(me.node.content.textBaseline, node)
        }; //console.log(node.key);

        var contentLabelId = "content_label_" + node.key;

        var _contentLabel = me.nodesContentSp.getChildById(contentLabelId);

        if (_contentLabel) {
          //已经存在的label
          _contentLabel.resetText(content);

          _.extend(_contentLabel.context, context);
        } else {
          //新创建text，根据 text 来计算node需要的width和height
          _contentLabel = new _canvax["default"].Display.Text(content, {
            id: contentLabelId,
            context: context
          });
          _contentLabel.context.visible = false;

          if (!_.isArray(node.key)) {
            me.nodesContentSp.addChild(_contentLabel);
          }
        }
        var inited;

        if (_this9.node.content.init && typeof _this9.node.content.init === 'function') {
          inited = _this9.node.content.init(node, _contentLabel);
        }

        if (inited && typeof inited.then == 'function') {
          inited.then(function () {
            if (!width) {
              width = _contentLabel.getTextWidth() + me.getProp(me.node.padding, node) * me.status.transform.scale * 2;
            }

            if (!height) {
              height = _contentLabel.getTextHeight() + me.getProp(me.node.padding, node) * me.status.transform.scale * 2;
            }
            resolve({
              contentElement: _contentLabel,
              width: width,
              height: height
            });
          });
        } else {
          if (!width) {
            width = _contentLabel.getTextWidth() + me.getProp(me.node.padding, node) * me.status.transform.scale * 2;
          }

          if (!height) {
            height = _contentLabel.getTextHeight() + me.getProp(me.node.padding, node) * me.status.transform.scale * 2;
          }
          resolve({
            contentElement: _contentLabel,
            width: width,
            height: height
          });
        }
      });
    }
  }, {
    key: "_getEleAndsetHtmlSize",
    value: function _getEleAndsetHtmlSize(node) {
      var _this10 = this;

      var me = this;
      return new Promise(function (resolve) {
        var content = node.content;
        var width = node.rowData.width,
            height = node.rowData.height;
        var contentLabelClass = "__content_label_" + node.key;

        var _dom = _this10.domContainer.getElementsByClassName(contentLabelClass);

        if (!_dom.length) {
          _dom = document.createElement("div");
          _dom.className = "chartx_relation_node " + contentLabelClass;
          _dom.style.cssText += "; position:absolute;visibility:hidden;";

          _this10.domContainer.appendChild(_dom);
        } else {
          _dom = _dom[0];
        }
        _dom.style.cssText += "; color:" + me.getProp(me.node.content.fontColor, node) + ";";
        _dom.style.cssText += "; text-align:" + me.getProp(me.node.content.textAlign, node) + ";";
        _dom.style.cssText += "; vertical-align:" + me.getProp(me.node.content.textBaseline, node) + ";"; //_dom.style.cssText += "; padding:"+me.getProp(me.node.padding, node)+"px;";

        _dom.innerHTML = content;
        var inited;

        if (_this10.node.content.init && typeof _this10.node.content.init === 'function') {
          inited = _this10.node.content.init(node, _dom);
        }

        if (inited && typeof inited.then == 'function') {
          inited.then(function (opt) {
            if (!width) {
              width = _dom.offsetWidth; // + me.getProp(me.node.padding, node) * me.status.transform.scale * 2;
            }

            if (!height) {
              height = _dom.offsetHeight; // + me.getProp(me.node.padding, node) * me.status.transform.scale * 2;
            }
            resolve({
              contentElement: _dom,
              width: width,
              height: height
            });
          });
        } else {
          if (!width) {
            width = _dom.offsetWidth; // + me.getProp(me.node.padding, node) * me.status.transform.scale * 2;
          }

          if (!height) {
            height = _dom.offsetHeight; // + me.getProp(me.node.padding, node) * me.status.transform.scale * 2;
          }
          resolve({
            contentElement: _dom,
            width: width,
            height: height
          });
        }
      });
    }
  }, {
    key: "getNodesAt",
    value: function getNodesAt() {}
  }, {
    key: "getProp",
    value: function getProp(prop, nodeData) {
      var _prop = prop;

      if (this._isField(prop)) {
        _prop = nodeData.rowData[prop];
      } else {
        if (_.isArray(prop)) {
          _prop = prop[nodeData.iNode];
        }

        if (_.isFunction(prop)) {
          _prop = prop.apply(this, [nodeData]);
        }
      }
      return _prop;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: 'key字段设置',
          documentation: '',
          "default": null
        },
        childrenField: {
          detail: '树结构数据的关联字段',
          documentation: '如果是树结构的关联数据，不是行列式，那么就通过这个字段来建立父子关系',
          "default": 'children'
        },
        //rankdir: "TB",
        //align: "DR",
        //nodesep: 0,//同级node之间的距离
        //edgesep: 0,
        //ranksep: 0, //排与排之间的距离
        rankdir: {
          detail: '布局方向',
          "default": null
        },
        node: {
          detail: '单个节点的配置',
          propertys: {
            shapeType: {
              detail: '节点图形，支持rect,diamond',
              "default": 'rect'
            },
            maxWidth: {
              detail: '节点最大的width',
              "default": 200
            },
            cursor: {
              detail: '节点的鼠标样式',
              "default": 'pointer'
            },
            width: {
              detail: '内容的width',
              "default": null
            },
            height: {
              detail: '内容的height',
              "default": null
            },
            radius: {
              detail: '圆角角度，对rect生效',
              "default": 6
            },
            includedAngle: {
              detail: 'shapeType为diamond(菱形)的时候生效,x方向的夹角',
              "default": 60
            },
            fillStyle: {
              detail: '节点背景色',
              "default": '#ffffff'
            },
            lineWidth: {
              detail: '描边宽度',
              "default": 1
            },
            strokeStyle: {
              detail: '描边颜色',
              "default": '#e5e5e5'
            },
            shadow: {
              detail: '阴影设置',
              propertys: {
                shadowOffsetX: {
                  detail: 'x偏移量',
                  "default": 0
                },
                shadowOffsetY: {
                  detail: 'y偏移量',
                  "default": 0
                },
                shadowBlur: {
                  detail: '阴影模糊值',
                  "default": 0
                },
                shadowColor: {
                  detail: '阴影颜色',
                  "default": '#000000'
                }
              }
            },
            select: {
              detail: '选中效果',
              propertys: {
                enabled: {
                  detail: '是否开启选中',
                  "default": false
                },
                list: {
                  detail: '选中的node.key的集合,外部传入可以选中',
                  "default": []
                },
                triggerEventType: {
                  detail: '触发事件',
                  "default": 'click,tap'
                },
                shadow: {
                  detail: '选中效果的阴影设置',
                  propertys: {
                    shadowOffsetX: {
                      detail: 'x偏移量',
                      "default": 0
                    },
                    shadowOffsetY: {
                      detail: 'y偏移量',
                      "default": 0
                    },
                    shadowBlur: {
                      detail: '阴影模糊值',
                      "default": 0
                    },
                    shadowColor: {
                      detail: '阴影颜色',
                      "default": '#000000'
                    }
                  }
                },
                fillStyle: {
                  detail: 'hover节点背景色',
                  "default": '#ffffff'
                },
                lineWidth: {
                  detail: 'hover描边宽度',
                  "default": 1
                },
                strokeStyle: {
                  detail: 'hover描边颜色',
                  "default": '#e5e5e5'
                },
                onbefore: {
                  detail: '执行select处理函数的前处理函数，返回false则取消执行select',
                  "default": null
                },
                onend: {
                  detail: '执行select处理函数的后处理函数',
                  "default": null
                }
              }
            },
            focus: {
              detail: 'hover效果',
              propertys: {
                enabled: {
                  detail: '是否开启hover效果',
                  "default": false
                },
                shadow: {
                  detail: '选中效果的阴影设置',
                  propertys: {
                    shadowOffsetX: {
                      detail: 'x偏移量',
                      "default": 0
                    },
                    shadowOffsetY: {
                      detail: 'y偏移量',
                      "default": 0
                    },
                    shadowBlur: {
                      detail: '阴影模糊值',
                      "default": 0
                    },
                    shadowColor: {
                      detail: '阴影颜色',
                      "default": '#000000'
                    }
                  }
                },
                fillStyle: {
                  detail: 'hover节点背景色',
                  "default": '#ffffff'
                },
                lineWidth: {
                  detail: 'hover描边宽度',
                  "default": 1
                },
                strokeStyle: {
                  detail: 'hover描边颜色',
                  "default": '#e5e5e5'
                }
              }
            },
            padding: {
              detail: 'node节点容器到内容的边距,节点内容是canvas的时候生效，dom节点不生效',
              "default": 10
            },
            content: {
              detail: '节点内容配置',
              propertys: {
                field: {
                  detail: '内容字段',
                  documentation: '默认content字段',
                  "default": 'content'
                },
                fontColor: {
                  detail: '内容文本颜色',
                  "default": '#666'
                },
                format: {
                  detail: '内容格式化处理函数',
                  "default": null
                },
                textAlign: {
                  detail: "textAlign",
                  "default": "center"
                },
                textBaseline: {
                  detail: 'textBaseline',
                  "default": "middle"
                },
                init: {
                  detail: '内容节点的初始化完成回调',
                  documentation: '在节点内容配置为需要异步完成的时候，比如节点内容配置为一个magix的view',
                  "default": null
                }
              }
            }
          }
        },
        line: {
          detail: '两个节点连线配置',
          propertys: {
            isTree: {
              detail: '是否树结构的连线',
              documentation: '非树结构启用该配置可能会有意想不到的惊喜，慎用',
              "default": false
            },
            inflectionRadius: {
              detail: '树状连线的拐点圆角半径',
              "default": 0
            },
            shapeType: {
              detail: '连线的图形样式 brokenLine or bezier',
              "default": 'bezier'
            },
            lineWidth: {
              detail: '线宽',
              "default": 1
            },
            strokeStyle: {
              detail: '连线的颜色',
              "default": '#e5e5e5'
            },
            lineType: {
              detail: '连线样式（虚线等）',
              "default": 'solid'
            },
            arrow: {
              detail: '连线箭头配置',
              propertys: {
                enabled: {
                  detail: '是否开启arrow设置',
                  "default": true
                },
                offsetX: {
                  detail: 'x方向偏移',
                  "default": 0
                },
                offsetY: {
                  detail: 'y方向偏移',
                  "default": 0
                }
              }
            },
            edgeLabel: {
              detail: '连线上面的label配置',
              propertys: {
                enabled: {
                  detail: '是否开启label设置',
                  "default": true
                },
                fontColor: {
                  detail: '文本颜色',
                  "default": '#ccc'
                },
                fontSize: {
                  detail: '文本大小',
                  "default": 12
                },
                // offsetX: {
                //     detail: 'x方向偏移量',
                //     default:0
                // },
                // offsetY: {
                //     detail: 'y方向偏移量',
                //     default:0
                // },
                offset: {
                  detail: 'label的位置，函数，参数是整个edge对象',
                  "default": null
                }
              }
            },
            icon: {
              detail: '连线上面的操作icon',
              propertys: {
                enabled: {
                  detail: '是否开启线上的icon设置',
                  "default": false
                },
                charCode: {
                  detail: 'iconfont上面对应的unicode中&#x后面的字符',
                  "default": null
                },
                lineWidth: {
                  detail: 'icon描边线宽',
                  "default": 1
                },
                strokeStyle: {
                  detail: 'icon的描边颜色',
                  "default": '#e5e5e5'
                },
                fontColor: {
                  detail: 'icon的颜色',
                  "default": '#e5e5e5'
                },
                fontFamily: {
                  detail: 'font-face的font-family设置',
                  "default": 'iconfont'
                },
                fontSize: {
                  detail: 'icon的字体大小',
                  "default": 14
                },
                offset: {
                  detail: 'icon的位置，函数，参数是整个edge对象',
                  "default": null
                },
                offsetX: {
                  detail: '在计算出offset后的X再次便宜量',
                  "default": 1
                },
                offsetY: {
                  detail: '在计算出offset后的Y再次便宜量',
                  "default": 2
                },
                background: {
                  detail: 'icon的背景颜色，背景为圆形',
                  "default": "#fff"
                }
              }
            },
            cursor: 'default'
          }
        },
        layout: {
          detail: '采用的布局引擎,比如dagre',
          "default": "dagre"
        },
        layoutOpts: {
          detail: '布局引擎对应的配置,dagre详见dagre的官方wiki',
          propertys: {}
        },
        status: {
          detail: '一些开关配置',
          propertys: {
            transform: {
              detail: "是否启动拖拽缩放整个画布",
              propertys: {
                fitView: {
                  detail: "自动缩放",
                  "default": '' //autoZoom

                },
                enabled: {
                  detail: "是否开启",
                  "default": true
                },
                scale: {
                  detail: "缩放值",
                  "default": 1
                },
                scaleOrigin: {
                  detail: "缩放原点",
                  "default": {
                    x: 0,
                    y: 0
                  }
                },
                wheelAction: {
                  detail: "滚轮触屏滑动触发的行为，可选有scale和offset，默认offset",
                  "default": "offset"
                }
              }
            }
          }
        }
      };
    }
  }]);
  return Relation;
}(_index["default"]);

_index["default"].registerComponent(Relation, 'graphs', 'relation');

var _default = Relation;
exports["default"] = _default;
});

unwrapExports(relation);

var tree = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(relation);

var _dataFrame = interopRequireDefault(dataFrame);



var _trigger2 = interopRequireDefault(trigger);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Rect = _canvax["default"].Shapes.Rect;
var Diamond = _canvax["default"].Shapes.Diamond;
var Path = _canvax["default"].Shapes.Path;
var Circle = _canvax["default"].Shapes.Circle;
var Arrow = _canvax["default"].Shapes.Arrow;
/**
 * 关系图中 包括了  配置，数据，和布局数据，
 * 默认用配置和数据可以完成绘图， 但是如果有布局数据，就绘图玩额外调用一次绘图，把布局数据传入修正布局效果
 */

var Tree = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(Tree, _GraphsBase);

  var _super = _createSuper(Tree);

  function Tree(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, Tree);
    _this = _super.call(this, opt, app);
    _this.type = "tree";
    _this.shrinked = []; //所有被设置了收缩的node的key

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(Tree.defaultProps()), opt);

    return _this;
  }

  (0, _createClass2["default"])(Tree, [{
    key: "_initData",
    value: function _initData(_data) {
      var _this2 = this;

      return new Promise(function (resolve) {
        if (_data && _data.nodes && _data.edges) {
          resolve(_data);
          return;
        }
        var data$1 = {
          //{ type,key,content,ctype,width,height,x,y }
          nodes: [],
          //{ type,key[],content,ctype,width,height,x,y }
          edges: [],
          size: {
            width: 0,
            height: 0
          }
        };
        var originData = _this2.app._data;

        if ((0, data.checkDataIsJson)(originData, _this2.field, _this2.childrenField)) {
          _this2.jsonData = (0, data.jsonToArrayForRelation)(originData, _this2, _this2.childrenField);
          _this2.dataFrame = _this2.app.dataFrame = (0, _dataFrame["default"])(_this2.jsonData, _this2);
        } else {
          //源数据就是图表标准数据，只需要转换成json的Children格式
          //app.dataFrame.jsonOrg ==> [{name: key:} ...] 不是children的树结构
          //this.jsonData = arrayToTreeJsonForRelation(this.app.dataFrame.jsonOrg, this);
          //if( this.layout == "tree" ){
          //源数据就是图表标准数据，只需要转换成json的Children格式
          //app.dataFrame.jsonOrg ==> [{name: key:} ...] 不是children的树结构
          _this2.jsonData = (0, data.arrayToTreeJsonForRelation)(JSON.parse(JSON.stringify(_this2.app.dataFrame.jsonOrg)), _this2); //};
        }

        var setData = function setData(list, parentRowData) {
          list.forEach(function (rowData) {
            var key = rowData[_this2.field];

            var content = _this2._getContent(rowData); //let preNode = this._preData ? this._preData.nodes.find( item => item.key == key ) : null


            var node = _this2._getDefNode();

            Object.assign(node, {
              type: 'tree',
              iNode: rowData.__index__,
              rowData: rowData,
              key: key,
              content: content,
              ctype: _this2._checkHtml(content) ? 'html' : 'canvas'
            });
            node.shapeType = _this2.getProp(_this2.node.shapeType, node);
            Object.assign(node, _this2.layoutOpts.node);
            data$1.nodes.push(node); //如果有parent，那么就还有连线需要处理

            if (parentRowData) {
              //edge在relation中也是一个标准的node数据结构
              var edgeKey = [parentRowData[_this2.field], rowData[_this2.field]]; //let preEdge = this._preData ? this._preData.edges.find( item => item.key.join(',') == edgeKey.join(',') ) : null

              var edge = _this2._getDefNode();

              var edgeFilter = {};
              edgeFilter[_this2.field] = edgeKey.join(',');

              var edgeRowDatas = _this2.dataFrame.getRowDataOf(edgeFilter);

              if (edgeRowDatas && edgeRowDatas.length) {
                //edgeRowData
                var edgeRowData = edgeRowDatas[0];

                var edgeContent = _this2._getContent(edgeRowData);

                Object.assign(edge, {
                  type: 'tree',
                  iNode: edgeRowData.__index__,
                  rowData: edgeRowData,
                  key: edgeKey,
                  content: edgeContent,
                  ctype: _this2._checkHtml(edgeContent) ? 'html' : 'canvas'
                });
                edge.shapeType = _this2.getProp(_this2.line.shapeType, edge);
                Object.assign(edge, _this2.layoutOpts.edge);
                data$1.edges.push(edge);
              }
            }

            if (rowData.children && _this2.shrinked.indexOf(key) == -1) {
              setData(rowData.children, rowData);
            }
          });
        };

        setData(_this2.jsonData);

        _this2._initAllDataSize(data$1).then(function (data) {
          resolve(data);
        });
      });
    }
  }, {
    key: "_drawNodes",
    value: function _drawNodes() {
      var _this3 = this;

      var me = this;

      _.each(this.data.nodes, function (node) {
        _this3._drawNode(node); //shrink


        if (_this3.node.shrink.enabled) {
          if (node.rowData.children && node.rowData.children.length) {
            var iconId = node.key + "_shrink_icon";
            var iconBackId = node.key + "_shrink_icon_back";
            var charCode = _this3.node.shrink.openCharCode;

            if (_this3.shrinked.indexOf(node.key) == -1) {
              charCode = _this3.node.shrink.closeCharCode;
            }
            var iconText = String.fromCharCode(parseInt(_this3.getProp(charCode, node), 16));

            var fontSize = _this3.getProp(_this3.node.shrink.fontSize, node);

            var fontColor = _this3.getProp(_this3.node.shrink.fontColor, node);

            var fontFamily = _this3.getProp(_this3.node.shrink.fontFamily, node);

            var offsetX = _this3.getProp(_this3.node.shrink.offsetX, node);

            var offsetY = _this3.getProp(_this3.node.shrink.offsetY, node);

            var tipsContent = _this3.getProp(_this3.node.shrink.tipsContent, node);

            var background = _this3.getProp(_this3.node.shrink.background, node);

            var lineWidth = _this3.getProp(_this3.node.shrink.lineWidth, node);

            var strokeStyle = _this3.getProp(_this3.node.shrink.strokeStyle, node);

            var _shrinkIcon = _this3.labelsSp.getChildById(iconId);

            var _shrinkIconBack = _this3.labelsSp.getChildById(iconBackId);

            var x = parseInt(node.x + node.width / 2 + offsetX);
            var y = parseInt(node.y + offsetY); //shrinkIcon的 位置默认为左右方向的xy

            var shrinkCtx = {
              x: x,
              y: y + 1,
              fontSize: fontSize,
              fontFamily: fontFamily,
              fillStyle: fontColor,
              textAlign: "center",
              textBaseline: "middle",
              cursor: 'pointer'
            };
            var _shrinkBackCtx = {
              x: x,
              y: y,
              r: parseInt(fontSize * 0.5) + 2,
              fillStyle: background,
              strokeStyle: strokeStyle,
              lineWidth: lineWidth
            };

            if (_shrinkIcon) {
              _shrinkIcon.resetText(iconText);

              Object.assign(_shrinkIcon.context, shrinkCtx);
              Object.assign(_shrinkIconBack.context, _shrinkBackCtx);
            } else {
              _shrinkIcon = new _canvax["default"].Display.Text(iconText, {
                id: iconId,
                context: shrinkCtx
              });
              _shrinkIconBack = new Circle({
                id: iconBackId,
                context: _shrinkBackCtx
              });

              _this3.labelsSp.addChild(_shrinkIconBack);

              _this3.labelsSp.addChild(_shrinkIcon);

              _shrinkIcon._shrinkIconBack = _shrinkIconBack;

              _shrinkIcon.on(event.types.get(), function (e) {
                var trigger = _this3.node.shrink;
                e.eventInfo = {
                  trigger: trigger,
                  tipsContent: tipsContent,
                  nodes: [] //node

                }; //下面的这个就只在鼠标环境下有就好了

                if (_shrinkIconBack.context) {
                  if (e.type == 'mousedown') {
                    _shrinkIconBack.context.r += 1;
                  }

                  if (e.type == 'mouseup') {
                    _shrinkIconBack.context.r -= 1;
                  }
                }

                if (_this3.node.shrink.triggerEventType.indexOf(e.type) > -1) {
                  if (_this3.shrinked.indexOf(node.key) == -1) {
                    _this3.shrinked.push(node.key);
                  } else {
                    for (var i = 0, l = _this3.shrinked.length; i < l; i++) {
                      if (_this3.shrinked[i] == node.key) {
                        _this3.shrinked.splice(i, 1);

                        i--;
                        l--;
                      }
                    }
                  }

                  var _trigger = new _trigger2["default"](me, {
                    origin: node.key
                  });

                  _this3.app.resetData(null, _trigger);
                }

                _this3.app.fire(e.type, e);
              });
            }
            //shrinkIcon的引用就断了

            _shrinkIcon.nodeData = node;
            node.shrinkIcon = _shrinkIcon;
            node.shrinkIconBack = _shrinkIconBack;
          }
        }
      });
    }
  }, {
    key: "_destroy",
    value: function _destroy(item) {
      item.shapeElement && item.shapeElement.destroy();

      if (item.contentElement.destroy) {
        item.contentElement.destroy();
      } else {
        //否则就可定是个dom
        this.domContainer.removeChild(item.contentElement);
      }

      item.pathElement && item.pathElement.destroy();
      item.labelElement && item.labelElement.destroy();
      item.arrowElement && item.arrowElement.destroy();
      item.edgeIconElement && item.edgeIconElement.destroy();
      item.edgeIconBack && item.edgeIconBack.destroy(); //下面两个是tree中独有的

      item.shrinkIcon && item.shrinkIcon.destroy();
      item.shrinkIconBack && item.shrinkIconBack.destroy();

      if (Array.isArray(item.key)) {
        //是个edge的话，要检查下源头是不是没有子节点了， 没有子节点了， 还要把shrinkIcon 都干掉
        var sourceNode = item.source;

        if (!this.data.edges.find(function (item) {
          return item.key[0] == sourceNode.key;
        })) {
          //如歌edges里面还有 targetNode.key 开头的，targetNode 还有子节点, 否则就可以把 targetNode的shrinkIcon去掉
          sourceNode.shrinkIcon && sourceNode.shrinkIcon.destroy();
          sourceNode.shrinkIconBack && sourceNode.shrinkIconBack.destroy();
        }
      }
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: 'key字段设置',
          documentation: '',
          "default": null
        },
        node: {
          detail: '单个节点的配置',
          propertys: {
            shrink: {
              detail: '树状图是否有节点收缩按钮',
              propertys: {
                enabled: {
                  detail: "是否开启",
                  "default": true
                },
                triggerEventType: {
                  detail: '触发事件',
                  "default": 'click,tap'
                },
                openCharCode: {
                  detail: "点击后触发展开的icon chartCode，当前状态为收缩",
                  "default": ''
                },
                closeCharCode: {
                  detail: "点击后触发收缩的icon chartCode，当前状态为展开",
                  "default": ''
                },
                fontSize: {
                  detail: "icon字号大小",
                  "default": 12
                },
                fontColor: {
                  detail: "icon字体颜色",
                  "default": '#666'
                },
                fontFamily: {
                  detail: "icon在css中的fontFamily",
                  "default": 'iconfont'
                },
                tipsContent: {
                  detail: '鼠标移动到收缩icon上面的tips内容',
                  "default": ''
                },
                offsetX: {
                  detail: 'x方向偏移量',
                  "default": 10
                },
                offsetY: {
                  detail: 'y方向偏移量',
                  "default": 1
                },
                background: {
                  detail: 'icon的 背景色',
                  "default": '#fff'
                },
                lineWidth: {
                  detail: '边框大小',
                  "default": 1
                },
                strokeStyle: {
                  detail: '描边颜色',
                  "default": '#667894'
                }
              }
            }
          }
        }
      };
    }
  }]);
  return Tree;
}(_index["default"]);

_index["default"].registerComponent(Tree, 'graphs', 'tree');

var _default = Tree;
exports["default"] = _default;
});

unwrapExports(tree);

var base = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = interopRequireDefault(defineProperty$1);

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(graphs);



var _zoom = interopRequireDefault(zoom);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Rect = _canvax["default"].Shapes.Rect;
var Diamond = _canvax["default"].Shapes.Diamond;
var Line = _canvax["default"].Shapes.Line;
var Path = _canvax["default"].Shapes.Path;
var BrokenLine = _canvax["default"].Shapes.BrokenLine;
var Circle = _canvax["default"].Shapes.Circle;
var Arrow = _canvax["default"].Shapes.Arrow;
var iconWidth = 20;
/**
 * 关系图中 包括了  配置，数据，和布局数据，
 * 默认用配置和数据可以完成绘图， 但是如果有布局数据，就绘图玩额外调用一次绘图，把布局数据传入修正布局效果
 * 
 * relation 也好，  tree也好， 最后都要转换成 nodes edges
 * 
 */

var RelationBase = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(RelationBase, _GraphsBase);

  var _super = _createSuper(RelationBase);

  function RelationBase(opt, app, preComp) {
    var _this;

    (0, _classCallCheck2["default"])(this, RelationBase);
    _this = _super.call(this, opt, app);
    _this.type = "relation";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(RelationBase.defaultProps()), opt);

    _this.domContainer = app.canvax.domView;
    _this.induce = null;

    _this.init(preComp);

    return _this;
  }

  (0, _createClass2["default"])(RelationBase, [{
    key: "init",
    value: function init(preComp) {
      this._initInduce();

      this.nodesSp = new _canvax["default"].Display.Sprite({
        id: "nodesSp"
      });
      this.nodesContentSp = new _canvax["default"].Display.Sprite({
        id: "nodesContentSp"
      });
      this.edgesSp = new _canvax["default"].Display.Sprite({
        id: "edgesSp"
      });
      this.arrowsSp = new _canvax["default"].Display.Sprite({
        id: "arrowsSp"
      });
      this.labelsSp = new _canvax["default"].Display.Sprite({
        id: "labelsSp"
      });
      this.graphsSp = new _canvax["default"].Display.Sprite({
        id: "graphsSp"
      }); //这个view和induce是一一对应的，在induce上面执行拖拽和滚轮缩放，操作的目标元素就是graphsView

      this.graphsView = new _canvax["default"].Display.Sprite({
        id: "graphsView"
      });
      this.graphsSp.addChild(this.edgesSp);
      this.graphsSp.addChild(this.nodesSp);
      this.graphsSp.addChild(this.nodesContentSp);
      this.graphsSp.addChild(this.arrowsSp);
      this.graphsSp.addChild(this.labelsSp);
      this.graphsView.addChild(this.graphsSp);
      this.sprite.addChild(this.graphsView);

      if (preComp.zoom) {
        this.preGraphsSpPosition = preComp.graphsSpPosition;
        this.zoom = preComp.zoom;
        this.offset();
      } else {
        this.zoom = new _zoom["default"]();
      }
    } //这个node是放在 nodes  和 edges 中的数据结构

  }, {
    key: "getDefNode",
    value: function getDefNode() {
      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var node = _objectSpread({
        type: "relation",
        //tree中会覆盖为tree
        iNode: 0,
        rowData: null,
        key: "",
        content: '',
        ctype: 'canvas',
        //下面三个属性在_setElementAndSize中设置
        contentElement: null,
        //外面传的layout数据可能没有element，widget的时候要检测下
        width: null,
        height: null,
        boundingClientWidth: 0,
        //通过width，然后看有多少icon，计算出来用于layout计算的width
        //这个在layout的时候设置
        x: null,
        y: null,
        shapeType: null,
        focused: false,
        selected: false
      }, opt);

      return node;
    }
  }, {
    key: "checkNodeSizeForShapeType",
    value: function checkNodeSizeForShapeType(node) {
      //如果是菱形，还需要重新调整新的尺寸
      if (node.shapeType == 'diamond') {
        //因为node的尺寸前面计算出来的是矩形的尺寸，如果是菱形的话，这里就是指内接矩形的尺寸，
        //需要换算成外接矩形的尺寸
        var includedAngle = this.node.includedAngle / 2;
        var includeRad = includedAngle * Math.PI / 180;
        var boundingClientWidth = node.boundingClientWidth,
            height = node.height;
        node._innerBound = {
          width: boundingClientWidth,
          height: height
        };
        var newWidthDiff = height / Math.tan(includeRad);
        var newHeightDiff = boundingClientWidth * Math.tan(includeRad); //在内接矩形基础上扩展出来的外界矩形

        var newWidth = boundingClientWidth + newWidthDiff;
        var newHeight = height + newHeightDiff; //node上面记录的width 和 height 永远是内容的 高宽, 但是像 diamond 等， 布局的时候的bound是要计算一个新的
        //布局的时候， 布局算法要优先取 layoutWidth  和  layoutHeight

        node.boundingClientWidth = newWidth;
        node.height = newHeight;
      }
    }
  }, {
    key: "_initInduce",
    value: function _initInduce() {
      var me = this;
      this.induce = new Rect({
        id: "induce",
        context: {
          width: 0,
          height: 0,
          fillStyle: "#000000",
          globalAlpha: 0
        }
      });
      this.sprite.addChild(this.induce);
      var _mosedownIng = false; //滚轮缩放相关

      var _wheelHandleTimeLen = 32; //16*2

      var _wheelHandleTimeer = null;
      var _deltaY = 0;
      this.induce.on(event.types.get(), function (e) {
        if (me.status.transform.enabled) {
          var _contextmenu = me.app.getComponent({
            name: 'contextmenu'
          });

          if (!_contextmenu || !_contextmenu.isShow) {
            e.preventDefault();
            var point = e.target.localToGlobal(e.point, me.sprite); //鼠标拖拽移动

            if (e.type == "mousedown") {
              me.induce.toFront();
              _mosedownIng = true;
              me.app.canvax.domView && (me.app.canvax.domView.style.cursor = "move");
              me.zoom.mouseMoveTo(point);
            }

            if (e.type == "mouseup" || e.type == "mouseout") {
              me.induce.toBack();
              _mosedownIng = false;
              me.app.canvax.domView && (me.app.canvax.domView.style.cursor = '');
            }

            if (e.type == "mousemove") {
              if (_mosedownIng) {
                var _me$zoom$move = me.zoom.move(point),
                    x = _me$zoom$move.x,
                    y = _me$zoom$move.y;

                me.graphsView.context.x = parseInt(x);
                me.graphsView.context.y = parseInt(y);
              }
            }

            if (e.type == "wheel") {
              //console.log( _deltaY, e.deltaY )
              if (Math.abs(e.deltaY) > Math.abs(_deltaY)) {
                _deltaY = e.deltaY;
              }

              if (!_wheelHandleTimeer) {
                _wheelHandleTimeer = setTimeout(function () {
                  if (me.status.transform.wheelAction == 'offset') {
                    //移动的话用offset,偏移多少像素
                    var offsetPoint = {
                      x: -e.deltaX * 2,
                      y: -e.deltaY * 2
                    };
                    var leftDiss = parseInt(me.graphsView.context.x + me.graphsSp.context.x + me.data.viewPort.maxLeft + offsetPoint.x + me.app.padding.left);

                    if (leftDiss < 0) {
                      offsetPoint.x = parseInt(offsetPoint.x - leftDiss);
                    }

                    var rightDiss = parseInt(me.graphsView.context.x + me.graphsSp.context.x + me.data.viewPort.maxRight + offsetPoint.x + me.app.padding.right);

                    if (rightDiss >= me.app.width) {
                      offsetPoint.x = parseInt(offsetPoint.x - (rightDiss - me.app.width));
                    }

                    var topDiss = parseInt(me.graphsView.context.y + me.graphsSp.context.y + me.data.viewPort.maxTop + offsetPoint.y + me.app.padding.top);

                    if (topDiss < 0) {
                      offsetPoint.y = parseInt(offsetPoint.y - topDiss);
                    }

                    var bottomDiss = parseInt(me.graphsView.context.y + me.graphsSp.context.y + me.data.viewPort.maxBottom + offsetPoint.y + me.app.padding.bottom);

                    if (bottomDiss >= me.app.height) {
                      offsetPoint.y = parseInt(offsetPoint.y - (bottomDiss - me.app.height));
                    } //console.log( offsetPoint )


                    var _me$zoom$offset = me.zoom.offset(offsetPoint),
                        _x = _me$zoom$offset.x,
                        _y = _me$zoom$offset.y; //me.zoom.move( {x:zx, y:zy} );


                    me.graphsView.context.x = _x;
                    me.graphsView.context.y = _y;
                  }

                  if (me.status.transform.wheelAction == 'scale') {
                    // 缩放         
                    var _me$zoom$wheel = me.zoom.wheel(e, point),
                        scale = _me$zoom$wheel.scale,
                        _x2 = _me$zoom$wheel.x,
                        _y2 = _me$zoom$wheel.y;

                    me.graphsView.context.x = _x2;
                    me.graphsView.context.y = _y2;
                    me.graphsView.context.scaleX = scale;
                    me.graphsView.context.scaleY = scale;
                    me.status.transform.scale = scale;
                  }

                  _wheelHandleTimeer = null;
                  _deltaY = 0;
                }, _wheelHandleTimeLen);
              }
            }
          }
        }

        e.eventInfo = {
          trigger: me,
          iNode: -1 //TODO:这里设置了的话，会导致多graphs里获取不到别的graphs的nodes信息了
          //nodes : me.getNodesAt( this.iNode ) 

        };
        me.app.fire(e.type, e);
      });
    }
  }, {
    key: "_resetData",
    value: function _resetData(data, dataTrigger) {
      var _this2 = this;

      var me = this;
      this._preData = this.data;
      return new Promise(function (resolve) {
        _this2.initData(data, dataTrigger).then(function (_data) {
          _this2.data = _data;

          _this2.layoutData();

          var _preNodes = _this2._preData && _this2._preData.nodes || [];

          var _preEdges = _this2._preData && _this2._preData.edges || [];

          _.each(_preNodes, function (preNode) {
            var nodeData = _.find(me.data.nodes, function (node) {
              return preNode.key == node.key;
            });

            if (!nodeData) {
              me._destroy(preNode);
            } else {
              //如果找到了，要从前面 复制几个属性过来
              nodeData.focused = preNode.focused;
              nodeData.selected = preNode.selected; //TODO:把原来的对象的 contentElement 搞过来， 就可以减少getChild的消耗
              //还有个更加重要的原因，这段代码解决了展开收起的抖动

              if (nodeData.ctype == preNode.ctype) {
                //类型没变， 就可以用同一个 contentElement
                nodeData.contentElement = preNode.contentElement;
              }
            }
          });

          _.each(_preEdges, function (preEdge) {
            if (!_.find(me.data.edges, function (edge) {
              return preEdge.key.join('_') == edge.key.join('_');
            })) {
              me._destroy(preEdge);
            }
          });

          _this2.widget();

          if (dataTrigger) {
            var origin = dataTrigger.origin || (dataTrigger.params || {}).origin; //兼容老的配置里面没有params，直接传origin的情况
            //钉住某个node为参考点（不移动)

            if (origin != undefined) {
              var preOriginNode = _.find(_preNodes, function (node) {
                return node.key == origin;
              });

              var originNode = _.find(_this2.data.nodes, function (node) {
                return node.key == origin;
              });

              if (preOriginNode && originNode) {
                var offsetPos = {
                  x: parseInt(preOriginNode.x) - parseInt(originNode.x),
                  y: parseInt(preOriginNode.y) - parseInt(originNode.y)
                };

                var _this2$zoom$offset = _this2.zoom.offset(offsetPos),
                    x = _this2$zoom$offset.x,
                    y = _this2$zoom$offset.y;

                me.graphsView.context.x = parseInt(x);
                me.graphsView.context.y = parseInt(y);
              }
            }
          }
          resolve();
        });
      });
    }
  }, {
    key: "_destroy",
    value: function _destroy(item) {}
  }, {
    key: "_drawEdges",
    value: function _drawEdges() {
      var me = this;

      _.each(this.data.edges, function (edge) {
        //console.log(edge.points)
        var lineShapeOpt = me._getLineShape(edge, me.line.inflectionRadius);

        var key = edge.key.join('_');
        var type = lineShapeOpt.type;
        var path = lineShapeOpt.path;
        var pointList = lineShapeOpt.pointList;
        var shape = type == 'path' ? Path : BrokenLine;
        var lineWidth = me.getProp(me.line.lineWidth, edge);
        var strokeStyle = me.getProp(me.line.strokeStyle, edge);
        var lineType = me.getProp(me.line.lineType, edge);
        var cursor = me.getProp(me.line.cursor, edge);
        var edgeId = 'edge_' + key;

        var _path = me.edgesSp.getChildById(edgeId);

        if (_path) {
          if (type == 'path') {
            _path.context.path = path;
          }

          if (type == 'brokenLine') {
            _path.context.pointList = pointList;
          }

          _path.context.lineWidth = lineWidth;
          _path.context.strokeStyle = strokeStyle;
          _path.context.lineType = lineType;
        } else {
          var _ctx = {
            lineWidth: lineWidth,
            strokeStyle: strokeStyle,
            lineType: lineType,
            cursor: cursor
          };

          if (type == 'path') {
            _ctx.path = path;
          }

          if (type == 'brokenLine') {
            //_ctx.smooth = true;
            //_ctx.curvature = 0.25;
            _ctx.pointList = pointList;
          }

          _path = new shape({
            id: edgeId,
            context: _ctx
          });

          _path.on(event.types.get(), function (e) {
            var node = this.nodeData;
            node.__no_value = true;
            e.eventInfo = {
              trigger: me.line,
              nodes: [node]
            };
            me.app.fire(e.type, e);
          });

          me.edgesSp.addChild(_path);
        }
        edge.pathElement = _path;
        _path.nodeData = edge; //edge也是一个node数据

        var arrowControl = edge.points.slice(-2, -1)[0];

        if (me.line.shapeType == "bezier") {
          if (me.rankdir == "TB" || me.rankdir == "BT") {
            arrowControl.x += (edge.source.x - edge.target.x) / 20;
          }

          if (me.rankdir == "LR" || me.rankdir == "RL") {
            arrowControl.y += (edge.source.y - edge.target.y) / 20;
          }
        }
        var edgeLabelId = 'label_' + key;
        var enabled = me.getProp(me.line.edgeLabel.enabled, edge);

        if (enabled) {
          var textAlign = me.getProp(me.node.content.textAlign, edge);
          var textBaseline = me.getProp(me.node.content.textBaseline, edge);
          var fontSize = me.getProp(me.line.edgeLabel.fontSize, edge);
          var fontColor = me.getProp(me.line.edgeLabel.fontColor, edge); // let offsetX      = me.getProp( me.line.edgeLabel.offsetX    , edge );
          // let offsetY      = me.getProp( me.line.edgeLabel.offsetY    , edge );

          var offset = me.getProp(me.line.icon.offset, edge);

          if (!offset) {
            //default 使用edge.x edge.y 也就是edge label的位置
            offset = {
              x: edge.x,
              y: edge.y
            };
          }

          var _edgeLabel = me.labelsSp.getChildById(edgeLabelId);

          if (_edgeLabel) {
            _edgeLabel.resetText(edge.content);

            _edgeLabel.context.x = offset.x;
            _edgeLabel.context.y = offset.y;
            _edgeLabel.context.fontSize = fontSize;
            _edgeLabel.context.fillStyle = fontColor;
            _edgeLabel.context.textAlign = textAlign;
            _edgeLabel.context.textBaseline = textBaseline;
          } else {
            _edgeLabel = new _canvax["default"].Display.Text(edge.content, {
              id: edgeLabelId,
              context: {
                x: offset.x,
                y: offset.y,
                fontSize: fontSize,
                fillStyle: fontColor,
                textAlign: textAlign,
                textBaseline: textBaseline
              }
            });

            _edgeLabel.on(event.types.get(), function (e) {
              var node = this.nodeData;
              node.__no_value = true;
              e.eventInfo = {
                trigger: me.line,
                nodes: [node]
              };
              me.app.fire(e.type, e);
            });

            me.labelsSp.addChild(_edgeLabel);
          }

          edge.labelElement = _edgeLabel;
          _edgeLabel.nodeData = edge;
        }
        var edgeIconEnabled = me.getProp(me.line.icon.enabled, edge);

        if (edgeIconEnabled) {
          var _chartCode = me.getProp(me.line.icon.charCode, edge);

          var charCode = String.fromCharCode(parseInt(_chartCode, 16));

          if (_chartCode != '') {
            var _lineWidth = me.getProp(me.line.icon.lineWidth, edge);

            var _strokeStyle = me.getProp(me.line.icon.strokeStyle, edge);

            var fontFamily = me.getProp(me.line.icon.fontFamily, edge);

            var _fontSize = me.getProp(me.line.icon.fontSize, edge);

            var _fontColor = me.getProp(me.line.icon.fontColor, edge);

            var background = me.getProp(me.line.icon.background, edge);
            var _textAlign = 'center';
            var _textBaseline = 'middle';

            var _offset2 = me.getProp(me.line.icon.offset, edge);

            var offsetX = me.getProp(me.line.icon.offsetX, edge);
            var offsetY = me.getProp(me.line.icon.offsetY, edge);

            if (!_offset2) {
              //default 使用edge.x edge.y 也就是edge label的位置
              _offset2 = {
                x: parseInt(edge.x) + offsetX,
                y: parseInt(edge.y) + offsetY
              };
            }
            var _iconBackCtx = {
              x: _offset2.x,
              y: _offset2.y - 1,
              r: parseInt(_fontSize * 0.5) + 2,
              fillStyle: background,
              strokeStyle: _strokeStyle,
              lineWidth: _lineWidth
            };
            var edgeIconBackId = 'edge_item_icon_back_' + key;

            var _iconBack = me.labelsSp.getChildById(edgeIconBackId);

            if (_iconBack) {
              //_.extend( true, _iconBack.context, _iconBackCtx )
              Object.assign(_iconBack.context, _iconBackCtx);
            } else {
              _iconBack = new Circle({
                id: edgeIconBackId,
                context: _iconBackCtx
              });
              me.labelsSp.addChild(_iconBack);
            }
            edge.edgeIconBack = _iconBack;
            _iconBack.nodeData = edge;
            var edgeIconId = 'edge_item_icon_' + key;

            var _edgeIcon = me.labelsSp.getChildById(edgeIconId);

            if (_edgeIcon) {
              _edgeIcon.resetText(charCode);

              _edgeIcon.context.x = _offset2.x;
              _edgeIcon.context.y = _offset2.y;
              _edgeIcon.context.fontSize = _fontSize;
              _edgeIcon.context.fillStyle = _fontColor;
              _edgeIcon.context.textAlign = _textAlign;
              _edgeIcon.context.textBaseline = _textBaseline;
              _edgeIcon.context.fontFamily = fontFamily; //_edgeIcon.context.lineWidth    = lineWidth;
              //_edgeIcon.context.strokeStyle  = strokeStyle;
            } else {
              _edgeIcon = new _canvax["default"].Display.Text(charCode, {
                id: edgeIconId,
                context: {
                  x: _offset2.x,
                  y: _offset2.y,
                  fillStyle: _fontColor,
                  cursor: 'pointer',
                  fontSize: _fontSize,
                  textAlign: _textAlign,
                  textBaseline: _textBaseline,
                  fontFamily: fontFamily
                }
              });

              _edgeIcon.on(event.types.get(), function (e) {
                var node = this.nodeData;
                node.__no_value = true;
                var trigger = me.line;

                if (me.line.icon['on' + e.type]) {
                  trigger = me.line.icon;
                }
                e.eventInfo = {
                  trigger: trigger,
                  nodes: [node]
                };
                me.app.fire(e.type, e);
              });

              me.labelsSp.addChild(_edgeIcon);
            }

            edge.edgeIconElement = _edgeIcon;
            _edgeIcon.nodeData = edge;
          }
        }

        if (me.line.arrow.enabled) {
          var arrowId = "arrow_" + key;

          var _arrow = me.arrowsSp.getChildById(arrowId);

          if (_arrow) {
            //arrow 只监听了x y 才会重绘，，，暂时只能这样处理,手动的赋值control.x control.y
            //而不是直接把 arrowControl 赋值给 control
            _arrow.context.x = me.line.arrow.offsetX;
            _arrow.context.y = me.line.arrow.offsetY;
            _arrow.context.fillStyle = strokeStyle;
            _arrow.context.control.x = arrowControl.x;
            _arrow.context.control.y = arrowControl.y;
            _arrow.context.point = edge.points.slice(-1)[0];
            _arrow.context.strokeStyle = strokeStyle;
            _arrow.context.fillStyle = strokeStyle; // _.extend(true, _arrow, {
            //     control: arrowControl,
            //     point: edge.points.slice(-1)[0],
            //     strokeStyle: strokeStyle
            // } );
          } else {
            _arrow = new Arrow({
              id: arrowId,
              context: {
                x: me.line.arrow.offsetX,
                y: me.line.arrow.offsetY,
                control: arrowControl,
                point: edge.points.slice(-1)[0],
                strokeStyle: strokeStyle,
                fillStyle: strokeStyle
              }
            });
            me.arrowsSp.addChild(_arrow);
          }
          edge.arrowElement = _arrow;
        }
      });
    }
  }, {
    key: "_drawNode",
    value: function _drawNode(node) {
      var me = this;
      var shape = Rect;
      var nodeId = "node_" + node.key;
      var cursor = me.node.cursor;

      var _me$_getNodeStyle = me._getNodeStyle(node),
          lineWidth = _me$_getNodeStyle.lineWidth,
          fillStyle = _me$_getNodeStyle.fillStyle,
          strokeStyle = _me$_getNodeStyle.strokeStyle,
          radius = _me$_getNodeStyle.radius,
          shadowOffsetX = _me$_getNodeStyle.shadowOffsetX,
          shadowOffsetY = _me$_getNodeStyle.shadowOffsetY,
          shadowBlur = _me$_getNodeStyle.shadowBlur,
          shadowColor = _me$_getNodeStyle.shadowColor;

      var context = {
        x: parseInt(node.x) - parseInt(node.boundingClientWidth / 2),
        y: parseInt(node.y) - parseInt(node.height / 2),
        width: node.boundingClientWidth,
        height: node.height,
        cursor: cursor,
        lineWidth: lineWidth,
        fillStyle: fillStyle,
        strokeStyle: strokeStyle,
        radius: radius,
        shadowOffsetX: shadowOffsetX,
        shadowOffsetY: shadowOffsetY,
        shadowBlur: shadowBlur,
        shadowColor: shadowColor
      };

      if (node.shapeType == 'diamond') {
        shape = Diamond;
        context = {
          x: parseInt(node.x),
          y: parseInt(node.y),
          cursor: cursor,
          innerRect: node._innerBound,
          lineWidth: lineWidth,
          fillStyle: fillStyle,
          strokeStyle: strokeStyle,
          shadowOffsetX: shadowOffsetX,
          shadowOffsetY: shadowOffsetY,
          shadowBlur: shadowBlur,
          shadowColor: shadowColor
        };
      }

      var _boxShape = me.nodesSp.getChildById(nodeId);

      if (_boxShape) {
        _.extend(_boxShape.context, context);

        _boxShape.nodeData = node;

        _boxShape.fire('transform');
      } else {
        _boxShape = new shape({
          id: nodeId,
          hoverClone: false,
          context: context
        });
        me.nodesSp.addChild(_boxShape);

        _boxShape.on(event.types.get(), function (e) {
          var node = this.nodeData;
          node.__no_value = true;
          e.eventInfo = {
            trigger: me.node,
            nodes: [node]
          };

          if (me.node.focus.enabled) {
            if (e.type == "mouseover") {
              me.focusAt(this.nodeData);
            }

            if (e.type == "mouseout") {
              me.unfocusAt(this.nodeData);
            }
          }

          if (me.node.select.enabled && me.node.select.triggerEventType.indexOf(e.type) > -1) {
            //如果开启了图表的选中交互
            //TODO:这里不能
            var onbefore = me.node.select.onbefore;
            var onend = me.node.select.onend;

            if (!onbefore || typeof onbefore == 'function' && onbefore.apply(me, [this.nodeData, e]) !== false) {
              if (this.nodeData.selected) {
                //说明已经选中了
                me.unselectAt(this.nodeData);
              } else {
                me.selectAt(this.nodeData);
              }

              onend && typeof onend == 'function' && onend.apply(me, [this.nodeData, e]);
            }
          }
          me.app.fire(e.type, e);
        });

        _boxShape.nodeData = node;
      }
      node.shapeElement = _boxShape;

      if (me.node.select.list.indexOf(node.key) > -1) {
        me.selectAt(node);
      }

      if (node.ctype == "canvas") {
        node.contentElement.context.visible = true;
      }

      _boxShape.on("transform", function () {
        var node = this.nodeData;

        if (node.ctype == "canvas") {
          node.contentElement.context.x = parseInt(node.x - node.boundingClientWidth / 2 + me.node.padding + (node.preIconCharCode ? iconWidth : 0));
          node.contentElement.context.y = parseInt(node.y);
        } else if (node.ctype == "html") {
          var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;

          var contentMatrix = _boxShape.worldTransform.clone();

          contentMatrix = contentMatrix.scale(1 / devicePixelRatio, 1 / devicePixelRatio);
          node.contentElement.style.transform = "matrix(" + contentMatrix.toArray().join() + ")";
          node.contentElement.style.transformOrigin = "left top"; //修改为左上角为旋转中心点来和canvas同步

          if (node.shapeType == 'diamond') {
            //菱形的位置
            node.contentElement.style.left = -parseInt((node.boundingClientWidth - node._innerBound.width) / 2 * me.status.transform.scale) + "px";
            node.contentElement.style.top = -parseInt(node.height / 2 * me.status.transform.scale) + "px";
          }
          node.contentElement.style.visibility = "visible";
        }
      });
    }
  }, {
    key: "_getNodeStyle",
    value: function _getNodeStyle(nodeData, targetPath) {
      var me = this;

      var radius = _.flatten([me.getProp(me.node.radius, nodeData)]);

      var target = me.node;

      if (targetPath == 'select') {
        target = me.node.select;
      }

      if (targetPath == 'focus') {
        target = me.node.focus;
      }

      var lineWidth = me.getProp(target.lineWidth, nodeData);
      var fillStyle = me.getProp(target.fillStyle, nodeData);
      var strokeStyle = me.getProp(target.strokeStyle, nodeData);
      var shadowOffsetX = me.getProp(target.shadow.shadowOffsetX, nodeData);
      var shadowOffsetY = me.getProp(target.shadow.shadowOffsetY, nodeData);
      var shadowBlur = me.getProp(target.shadow.shadowBlur, nodeData);
      var shadowColor = me.getProp(target.shadow.shadowColor, nodeData);
      return {
        lineWidth: lineWidth,
        fillStyle: fillStyle,
        strokeStyle: strokeStyle,
        radius: radius,
        shadowOffsetX: shadowOffsetX,
        shadowOffsetY: shadowOffsetY,
        shadowBlur: shadowBlur,
        shadowColor: shadowColor
      };
    }
  }, {
    key: "_setNodeStyle",
    value: function _setNodeStyle(nodeData, targetPath) {
      var _this$_getNodeStyle = this._getNodeStyle(nodeData, targetPath),
          lineWidth = _this$_getNodeStyle.lineWidth,
          fillStyle = _this$_getNodeStyle.fillStyle,
          strokeStyle = _this$_getNodeStyle.strokeStyle,
          shadowOffsetX = _this$_getNodeStyle.shadowOffsetX,
          shadowOffsetY = _this$_getNodeStyle.shadowOffsetY,
          shadowBlur = _this$_getNodeStyle.shadowBlur,
          shadowColor = _this$_getNodeStyle.shadowColor;

      if (nodeData.shapeElement && nodeData.shapeElement.context) {
        var ctx = nodeData.shapeElement.context;
        ctx.lineWidth = lineWidth;
        ctx.fillStyle = fillStyle;
        ctx.strokeStyle = strokeStyle;
        ctx.shadowOffsetX = shadowOffsetX;
        ctx.shadowOffsetY = shadowOffsetY;
        ctx.shadowBlur = shadowBlur;
        ctx.shadowColor = shadowColor;
      }
    } //画布偏移量

  }, {
    key: "offset",
    value: function offset() {
      var _offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        x: 0,
        y: 0
      };

      var _this$zoom$offset = this.zoom.offset(_offset),
          x = _this$zoom$offset.x,
          y = _this$zoom$offset.y;

      this.graphsView.context.x = parseInt(x);
      this.graphsView.context.y = parseInt(y);
    } //把某个节点移动到居中位置

  }, {
    key: "setNodeToCenter",
    value: function setNodeToCenter(key) {
      var nodeData = this.getNodeDataAt(key);

      if (nodeData) {
        var globalPos = nodeData.shapeElement.localToGlobal();
        var toGlobalPos = {
          x: this.app.width / 2 - nodeData.width / 2,
          y: this.app.height / 2 - nodeData.height / 2
        };
        var toCenterOffset = {
          x: parseInt(toGlobalPos.x - globalPos.x),
          y: parseInt(toGlobalPos.y - globalPos.y)
        };
        this.offset(toCenterOffset);
      }
    }
  }, {
    key: "focusAt",
    value: function focusAt(key) {
      var nodeData = this.getNodeDataAt(key);

      if (nodeData) {
        !nodeData.selected && this._setNodeStyle(nodeData, 'focus');
        nodeData.focused = true;
      }
    }
  }, {
    key: "unfocusAt",
    value: function unfocusAt(key) {
      var nodeData = this.getNodeDataAt(key);

      if (nodeData) {
        !nodeData.selected && this._setNodeStyle(nodeData);
        nodeData.focused = false;
      }
    }
  }, {
    key: "selectAt",
    value: function selectAt(key) {
      var nodeData = this.getNodeDataAt(key);

      if (nodeData) {
        this._setNodeStyle(nodeData, 'select');

        nodeData.selected = true;

        if (this.node.select.list.indexOf(nodeData.key) == -1) {
          this.node.select.list.push(nodeData.key);
        }
      }
    }
  }, {
    key: "selectAll",
    value: function selectAll() {
      var _this3 = this;

      this.data.nodes.forEach(function (nodeData) {
        _this3.selectAt(nodeData);
      });
    }
  }, {
    key: "unselectAt",
    value: function unselectAt(key) {
      var nodeData = this.getNodeDataAt(key);

      if (nodeData) {
        nodeData.focused ? this._setNodeStyle(nodeData, 'focus') : this._setNodeStyle(nodeData);
        nodeData.selected = false;
        var selectedKeyInd = this.node.select.list.indexOf(nodeData.key);

        if (selectedKeyInd > -1) {
          this.node.select.list.splice(selectedKeyInd, 1);
        }
      }
    }
  }, {
    key: "unselectAll",
    value: function unselectAll() {
      var _this4 = this;

      this.data.nodes.forEach(function (nodeData) {
        _this4.unselectAt(nodeData);
      }); //有些被折叠了的selected也要清除干净的话，必须多做一步list = []

      this.node.select.list = [];
    }
  }, {
    key: "getNodeDataAt",
    value: function getNodeDataAt(key) {
      if (key.type && (key.type == "relation" || key.type == "tree")) {
        return key;
      }

      if (typeof key == 'string') {
        var keys = key.split(',');

        if (keys.length == 1) {
          return this.data.nodes.find(function (item) {
            return item.key == key;
          });
        }

        if (keys.length == 2) {
          return this.data.edges.find(function (item) {
            return item.key.join() == keys.join();
          });
        }
      }
    }
    /**
     * 
     * @param {shapeType,points} edge 
     * @param {number} inflectionRadius 拐点的圆角半径
     */

  }, {
    key: "_getLineShape",
    value: function _getLineShape(edge, inflectionRadius) {
      var points = edge.points;
      var line = {
        type: 'path',
        // pah or brokenLine
        pointList: null,
        path: str
      };
      var head = points.splice(0, 1)[0];
      var str = "M" + head.x + " " + head.y;
      var start = points[0];
      str += ",L" + start.x + " " + start.y;
      var end = points.slice(-1)[0];

      if (edge.shapeType == "bezier") {
        if (points.length == 3) {
          str += ",Q" + points[1].x + " " + points[1].y + " " + end.x + " " + end.y;
        }

        if (points.length == 4) {
          str += ",C" + points[1].x + " " + points[1].y + " " + points[2].x + " " + points[2].y + " " + end.x + " " + end.y;
        }

        if (points.length >= 5) {
          line.type = 'brokenLine';
          line.pointList = points.map(function (item) {
            return [item.x, item.y];
          });
          return line;
        }
      }

      if (edge.shapeType == "brokenLine") {
        if (points.length == 3) {
          points.splice(1, 0, {
            x: points[1].x,
            y: start.y
          });
        }

        _.each(points, function (point, i) {
          if (i) {
            if (inflectionRadius && i < points.length - 1) {
              //圆角连线
              var prePoint = points[i - 1];
              var nextPoint = points[i + 1]; //要从这个点到上个点的半径距离，已point为控制点，绘制nextPoint的半径距离

              var radius = inflectionRadius; //radius要做次二次校验，取radius 以及 point 和prePoint距离以及和 nextPoint 的最小值
              //let _disPre = Math.abs(Math.sqrt( (prePoint.x - point.x)*(prePoint.x - point.x) + (prePoint.y - point.y)*(prePoint.y - point.y) ));
              //let _disNext = Math.abs(Math.sqrt( (nextPoint.x - point.x)*(nextPoint.x - point.x) + (nextPoint.y - point.y)*(nextPoint.y - point.y) ));

              var _disPre = Math.max(Math.abs(prePoint.x - point.x) / 2, Math.abs(prePoint.y - point.y) / 2);

              var _disNext = Math.max(Math.abs(nextPoint.x - point.x) / 2, Math.abs(nextPoint.y - point.y) / 2);

              radius = _.min([radius, _disPre, _disNext]); //console.log(Math.atan2( point.y - prePoint.y , point.x - prePoint.x ),Math.atan2( nextPoint.y - point.y , nextPoint.x - point.x ))

              if (point.x == prePoint.x && point.y == prePoint.y || point.x == nextPoint.x && point.y == nextPoint.y || Math.atan2(point.y - prePoint.y, point.x - prePoint.x) == Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x)) {
                //如果中间的这个点 ， 和前后的点在一个直线上面，就略过
                return;
              } else {
                var getPointOf = function getPointOf(p) {
                  var _atan2 = Math.atan2(p.y - point.y, p.x - point.x);

                  return {
                    x: point.x + radius * Math.cos(_atan2),
                    y: point.y + radius * Math.sin(_atan2)
                  };
                };
                var bezierBegin = getPointOf(prePoint);
                var bezierEnd = getPointOf(nextPoint);
                str += ",L" + bezierBegin.x + " " + bezierBegin.y + ",Q" + point.x + " " + point.y + " " + bezierEnd.x + " " + bezierEnd.y;
              }
            } else {
              //直角连线
              str += ",L" + point.x + " " + point.y;
            }
          }
        });
      }

      if (edge.target.shapeType == 'underLine') {
        var w = edge.target.rowData._node.boundingClientWidth;
        var x = parseInt(edge.target.x) + parseInt(w / 2);
        str += ",L" + x + " " + (parseInt(edge.target.y) + parseInt(edge.target.height / 2));
      }
      line.path = str; //str += "z"

      return line;
    }
    /**
     * 字符串是否含有html标签的检测
     */

  }, {
    key: "_checkHtml",
    value: function _checkHtml(str) {
      var reg = /<[^>]+>/g;
      return reg.test(str);
    }
  }, {
    key: "_getContent",
    value: function _getContent(rowData) {
      var me = this;

      var _c; //this.node.content;


      var field = this.node.content.field;

      if (this._isField(field)) {
        _c = rowData[field];
      }

      if (me.node.content.format && _.isFunction(me.node.content.format)) {
        _c = me.node.content.format.apply(this, [_c, rowData]);
      } else {
        //否则用fieldConfig上面的
        var _coord = me.app.getComponent({
          name: 'coord'
        });

        var fieldConfig = _coord.getFieldConfig(field);

        if (fieldConfig) {
          _c = fieldConfig.getFormatValue(_c);
        }
      }

      return _c;
    }
  }, {
    key: "_isField",
    value: function _isField(str) {
      return ~this.dataFrame.fields.indexOf(str);
    }
  }, {
    key: "_getEleAndsetCanvasSize",
    value: function _getEleAndsetCanvasSize(node) {
      var _this5 = this;

      var me = this;
      return new Promise(function (resolve) {
        var content = node.content;
        var width = me.getProp(me.node.width, node);

        if (!width && node.width) {
          width = node.width;
        }

        var height = me.getProp(me.node.height, node);

        if (!height && node.height) {
          height = node.height;
        }

        var fontColor = me.getProp(me.node.content.fontColor, node);

        if (node.rowData.fontColor) {
          fontColor = node.rowData.fontColor;
        }

        if (node.rowData.style && node.rowData.style.fontColor) {
          fontColor = node.rowData.style.fontColor;
        }

        var context = {
          fillStyle: fontColor,
          textAlign: me.getProp(me.node.content.textAlign, node),
          textBaseline: me.getProp(me.node.content.textBaseline, node),
          fontSize: me.getProp(me.node.content.fontSize, node)
        };
        var contentLabelId = "content_label_" + node.key;

        var _contentLabel = node.contentElement || me.nodesContentSp.getChildById(contentLabelId);

        if (_contentLabel) {
          //已经存在的label
          _contentLabel.resetText(content);

          _.extend(_contentLabel.context, context);
        } else {
          //新创建text，根据 text 来计算node需要的width和height
          _contentLabel = new _canvax["default"].Display.Text(content, {
            id: contentLabelId,
            context: context
          });
          _contentLabel.context.visible = false;

          if (!_.isArray(node.key)) {
            me.nodesContentSp.addChild(_contentLabel);
          }
        }
        var inited;

        if (_this5.node.content.init && typeof _this5.node.content.init === 'function') {
          inited = _this5.node.content.init(node, _contentLabel);
        }

        var _handle = function _handle() {
          if (!width) {
            width = _contentLabel.getTextWidth() + me.getProp(me.node.padding, node) * me.status.transform.scale * 2;
          }

          if (!height) {
            height = _contentLabel.getTextHeight() + me.getProp(me.node.padding, node) * me.status.transform.scale * 2;
          }
          resolve({
            contentElement: _contentLabel,
            width: parseInt(width),
            height: parseInt(height)
          });
        };

        if (inited && typeof inited.then == 'function') {
          inited.then(function () {
            _handle();
          });
        } else {
          _handle();
        }
      });
    }
  }, {
    key: "_getEleAndsetHtmlSize",
    value: function _getEleAndsetHtmlSize(node) {
      var _this6 = this;

      var me = this;
      return new Promise(function (resolve) {
        var content = node.content;
        var width = me.getProp(me.node.width, node);

        if (!width && me.node.rowData && node.rowData.width) {
          width = node.rowData.width;
        }

        var height = me.getProp(me.node.height, node);

        if (!height && me.node.rowData && node.rowData.height) {
          height = node.rowData.height;
        }

        var contentLabelClass = "__content_label_" + node.key;

        var _dom = node.contentElement || _this6.domContainer.getElementsByClassName(contentLabelClass)[0];

        if (!_dom) {
          _dom = document.createElement("div");
          _dom.className = "chartx_relation_node " + contentLabelClass;
          _dom.style.cssText += "; position:absolute;visibility:hidden;";

          _this6.domContainer.appendChild(_dom);
        } // else {
        //     _dom = _dom[0]
        // };


        _dom.style.cssText += "; color:" + me.getProp(me.node.content.fontColor, node) + ";";
        _dom.style.cssText += "; text-align:" + me.getProp(me.node.content.textAlign, node) + ";";
        _dom.style.cssText += "; vertical-align:" + me.getProp(me.node.content.textBaseline, node) + ";"; //TODO 这里注释掉， 就让dom自己内部去控制padding吧
        //_dom.style.cssText += "; padding:"+me.getProp(me.node.padding, node)+"px;"; 

        _dom.innerHTML = content;
        var inited;

        if (_this6.node.content.init && typeof _this6.node.content.init === 'function') {
          inited = _this6.node.content.init(node, _dom);
        }

        var _handle = function _handle() {
          if (!width) {
            width = _dom.offsetWidth; // + me.getProp(me.node.padding, node) * me.status.transform.scale * 2;
          }

          if (!height) {
            height = _dom.offsetHeight; // + me.getProp(me.node.padding, node) * me.status.transform.scale * 2;
          }
          resolve({
            contentElement: _dom,
            width: parseInt(width),
            height: parseInt(height)
          });
        };

        if (inited && typeof inited.then == 'function') {
          inited.then(function (opt) {
            _handle();
          });
        } else {
          _handle();
        }
      });
    }
  }, {
    key: "getNodesAt",
    value: function getNodesAt() {}
  }, {
    key: "getProp",
    value: function getProp(prop, nodeData) {
      var _prop = prop;

      if (this._isField(prop)) {
        _prop = nodeData.rowData[prop];
      } else {
        if (_.isArray(prop)) {
          _prop = prop[nodeData.iNode];
        }

        if (_.isFunction(prop)) {
          _prop = prop.apply(this, Array.prototype.slice.call(arguments).slice(1));
        }
      }
      return _prop;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: 'key字段设置',
          documentation: '',
          "default": null
        },
        //rankdir: "TB",
        //align: "DR",
        //nodesep: 0,//同级node之间的距离
        //edgesep: 0,
        //ranksep: 0, //排与排之间的距离
        rankdir: {
          detail: '布局方向',
          "default": null
        },
        ranksep: {
          detail: '排与排之间的距离',
          "default": 40
        },
        nodesep: {
          detail: '同级node之间的距离',
          "default": 20
        },
        node: {
          detail: '单个节点的配置',
          propertys: {
            shapeType: {
              detail: '节点图形，支持rect,diamond,underLine(adc用)',
              "default": 'rect'
            },
            maxWidth: {
              detail: '节点最大的width',
              "default": 200
            },
            cursor: {
              detail: '节点的鼠标样式',
              "default": 'pointer'
            },
            width: {
              detail: '节点的width,默认null（系统自动计算）, 也可以是个function，用户来计算每一个节点的width',
              "default": null
            },
            height: {
              detail: '节点的height,默认null（系统自动计算）, 也可以是个function，用户来计算每一个节点的height',
              "default": null
            },
            radius: {
              detail: '圆角角度，对rect生效',
              "default": 4
            },
            includedAngle: {
              detail: 'shapeType为 diamond (菱形)的时候生效,x方向的夹角',
              "default": 60
            },
            fillStyle: {
              detail: '节点背景色',
              "default": '#ffffff'
            },
            lineWidth: {
              detail: '描边宽度',
              "default": 1
            },
            strokeStyle: {
              detail: '描边颜色',
              "default": '#e5e5e5'
            },
            shadow: {
              detail: '阴影设置',
              propertys: {
                shadowOffsetX: {
                  detail: 'x偏移量',
                  "default": 0
                },
                shadowOffsetY: {
                  detail: 'y偏移量',
                  "default": 0
                },
                shadowBlur: {
                  detail: '阴影模糊值',
                  "default": 0
                },
                shadowColor: {
                  detail: '阴影颜色',
                  "default": '#000000'
                }
              }
            },
            select: {
              detail: '选中效果',
              propertys: {
                enabled: {
                  detail: '是否开启选中',
                  "default": false
                },
                list: {
                  detail: '选中的node.key的集合,外部传入可以选中',
                  "default": []
                },
                triggerEventType: {
                  detail: '触发事件',
                  "default": 'click,tap'
                },
                shadow: {
                  detail: '选中效果的阴影设置',
                  propertys: {
                    shadowOffsetX: {
                      detail: 'x偏移量',
                      "default": 0
                    },
                    shadowOffsetY: {
                      detail: 'y偏移量',
                      "default": 0
                    },
                    shadowBlur: {
                      detail: '阴影模糊值',
                      "default": 0
                    },
                    shadowColor: {
                      detail: '阴影颜色',
                      "default": '#000000'
                    }
                  }
                },
                fillStyle: {
                  detail: 'hover节点背景色',
                  "default": '#ffffff'
                },
                lineWidth: {
                  detail: 'hover描边宽度',
                  "default": 1
                },
                strokeStyle: {
                  detail: 'hover描边颜色',
                  "default": '#e5e5e5'
                },
                onbefore: {
                  detail: '执行select处理函数的前处理函数，返回false则取消执行select',
                  "default": null
                },
                onend: {
                  detail: '执行select处理函数的后处理函数',
                  "default": null
                },
                content: {
                  detail: '选中后节点内容配置',
                  propertys: {
                    fontColor: {
                      detail: '内容文本颜色',
                      "default": '#666'
                    },
                    fontSize: {
                      detail: '内容文本大小（在canvas格式下有效）',
                      "default": 14
                    },
                    format: {
                      detail: '内容格式化处理函数',
                      "default": null
                    }
                  }
                }
              }
            },
            focus: {
              detail: 'hover效果',
              propertys: {
                enabled: {
                  detail: '是否开启hover效果',
                  "default": false
                },
                shadow: {
                  detail: '选中效果的阴影设置',
                  propertys: {
                    shadowOffsetX: {
                      detail: 'x偏移量',
                      "default": 0
                    },
                    shadowOffsetY: {
                      detail: 'y偏移量',
                      "default": 0
                    },
                    shadowBlur: {
                      detail: '阴影模糊值',
                      "default": 0
                    },
                    shadowColor: {
                      detail: '阴影颜色',
                      "default": '#000000'
                    }
                  }
                },
                fillStyle: {
                  detail: 'hover节点背景色',
                  "default": '#ffffff'
                },
                content: {
                  detail: 'hover后节点内容配置',
                  propertys: {
                    fontColor: {
                      detail: '内容文本颜色',
                      "default": '#666'
                    },
                    fontSize: {
                      detail: '内容文本大小（在canvas格式下有效）',
                      "default": 14
                    },
                    format: {
                      detail: '内容格式化处理函数',
                      "default": null
                    }
                  }
                },
                lineWidth: {
                  detail: 'hover描边宽度',
                  "default": 1
                },
                strokeStyle: {
                  detail: 'hover描边颜色',
                  "default": '#e5e5e5'
                }
              }
            },
            padding: {
              detail: 'node节点容器到内容的边距,节点内容是canvas的时候生效，dom节点不生效',
              "default": 10
            },
            content: {
              detail: '节点内容配置',
              propertys: {
                field: {
                  detail: '内容字段',
                  documentation: '默认content字段',
                  "default": 'content'
                },
                fontColor: {
                  detail: '内容文本颜色',
                  "default": '#666'
                },
                fontSize: {
                  detail: '内容文本大小（在canvas格式下有效）',
                  "default": 14
                },
                format: {
                  detail: '内容格式化处理函数',
                  "default": null
                },
                textAlign: {
                  detail: "textAlign",
                  "default": "center"
                },
                textBaseline: {
                  detail: 'textBaseline',
                  "default": "middle"
                },
                init: {
                  detail: '内容节点的初始化完成回调',
                  documentation: '在节点内容配置为需要异步完成的时候，比如节点内容配置为一个magix的view',
                  "default": null
                }
              }
            }
          }
        },
        line: {
          detail: '两个节点连线配置',
          propertys: {
            isTree: {
              detail: '是否树结构的连线',
              documentation: '非树结构启用该配置可能会有意想不到的惊喜，慎用',
              "default": false
            },
            inflectionRadius: {
              detail: '树状连线的拐点圆角半径',
              "default": 0
            },
            shapeType: {
              detail: '连线的图形样式 brokenLine or bezier',
              "default": 'bezier'
            },
            lineWidth: {
              detail: '线宽',
              "default": 1
            },
            strokeStyle: {
              detail: '连线的颜色',
              "default": '#e5e5e5'
            },
            lineType: {
              detail: '连线样式（虚线等）',
              "default": 'solid'
            },
            arrow: {
              detail: '连线箭头配置',
              propertys: {
                enabled: {
                  detail: '是否开启arrow设置',
                  "default": true
                },
                offsetX: {
                  detail: 'x方向偏移',
                  "default": 0
                },
                offsetY: {
                  detail: 'y方向偏移',
                  "default": 0
                }
              }
            },
            edgeLabel: {
              detail: '连线上面的label配置',
              propertys: {
                enabled: {
                  detail: '是否开启label设置',
                  "default": true
                },
                fontColor: {
                  detail: '文本颜色',
                  "default": '#ccc'
                },
                fontSize: {
                  detail: '文本大小',
                  "default": 12
                },
                // offsetX: {
                //     detail: 'x方向偏移量',
                //     default:0
                // },
                // offsetY: {
                //     detail: 'y方向偏移量',
                //     default:0
                // },
                offset: {
                  detail: 'label的位置，函数，参数是整个edge对象',
                  "default": null
                }
              }
            },
            icon: {
              detail: '连线上面的操作icon',
              propertys: {
                enabled: {
                  detail: '是否开启线上的icon设置',
                  "default": false
                },
                charCode: {
                  detail: 'iconfont上面对应的unicode中&#x后面的字符',
                  "default": null
                },
                lineWidth: {
                  detail: 'icon描边线宽',
                  "default": 1
                },
                strokeStyle: {
                  detail: 'icon的描边颜色',
                  "default": '#e5e5e5'
                },
                fontColor: {
                  detail: 'icon的颜色',
                  "default": '#e5e5e5'
                },
                fontFamily: {
                  detail: 'font-face的font-family设置',
                  "default": 'iconfont'
                },
                fontSize: {
                  detail: 'icon的字体大小',
                  "default": 14
                },
                offset: {
                  detail: 'icon的位置，函数，参数是整个edge对象',
                  "default": null
                },
                offsetX: {
                  detail: '在计算出offset后的X再次便宜量',
                  "default": 1
                },
                offsetY: {
                  detail: '在计算出offset后的Y再次便宜量',
                  "default": 2
                },
                background: {
                  detail: 'icon的背景颜色，背景为圆形',
                  "default": "#fff"
                }
              }
            },
            cursor: 'default'
          }
        },
        status: {
          detail: '一些开关配置',
          propertys: {
            transform: {
              detail: "是否启动拖拽缩放整个画布",
              propertys: {
                fitView: {
                  detail: "自动缩放",
                  "default": '' //autoZoom

                },
                enabled: {
                  detail: "是否开启",
                  "default": true
                },
                scale: {
                  detail: "缩放值",
                  "default": 1
                },
                scaleOrigin: {
                  detail: "缩放原点",
                  "default": {
                    x: 0,
                    y: 0
                  }
                },
                wheelAction: {
                  detail: "滚轮触屏滑动触发的行为，可选有scale和offset，默认offset",
                  "default": "offset"
                }
              }
            }
          }
        } //可以在这里注册所有的事件监听，会从induce上面派发

      };
    }
  }]);
  return RelationBase;
}(_index["default"]);

var _default = RelationBase;
exports["default"] = _default;
});

unwrapExports(base);

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

function cluster() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
}

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

function node_count() {
  return this.eachAfter(count);
}

function node_each(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
}

function node_eachBefore(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
}

function node_eachAfter(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
}

function node_sum(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}

function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

function node_path(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

function node_descendants() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
}

function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

function node_links() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}

function hierarchy$1(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy$1(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy$1.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

var slice$1 = Array.prototype.slice;

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

function enclose(circles) {
  var i = 0, n = (circles = shuffle(slice$1.call(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

function place(a, b, c) {
  var ax = a.x,
      ay = a.y,
      da = b.r + c.r,
      db = a.r + c.r,
      dx = b.x - ax,
      dy = b.y - ay,
      dc = dx * dx + dy * dy;
  if (dc) {
    var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
    c.x = ax + x * dx + y * dy;
    c.y = ay + x * dy - y * dx;
  } else {
    c.x = ax + db;
    c.y = ay;
  }
}

function intersects(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r + b.r;
  return dr * dr - 1e-6 > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle…
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node$1(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

function siblings(circles) {
  packEnclose(circles);
  return circles;
}

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

function constantZero() {
  return 0;
}

function constant$1(x) {
  return function() {
    return x;
  };
}

function defaultRadius(d) {
  return Math.sqrt(d.value);
}

function index() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius))
          .eachAfter(packChildren(constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant$1(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

function roundNode(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

function treemapDice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

function partition$2() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}

var keyPrefix = "$", // Protect against keys like “__proto__”.
    preroot = {depth: -1},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function stratify() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
}

function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
function tree$1() {
  var separation = defaultSeparation$1,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.’s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
}

function treemapSlice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var squarify = (function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi);

function index$1() {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$1(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$1(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$1(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$1(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$1(+x), treemap) : paddingLeft;
  };

  return treemap;
}

function binary(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}

function sliceDice(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
}

var resquarify = (function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
})(phi);



var d3Hierarchy = /*#__PURE__*/Object.freeze({
	__proto__: null,
	cluster: cluster,
	hierarchy: hierarchy$1,
	pack: index,
	packSiblings: siblings,
	packEnclose: enclose,
	partition: partition$2,
	stratify: stratify,
	tree: tree$1,
	treemap: index$1,
	treemapBinary: binary,
	treemapDice: treemapDice,
	treemapSlice: treemapSlice,
	treemapSliceDice: sliceDice,
	treemapSquarify: squarify,
	treemapResquarify: resquarify
});

var tree$2 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = flextree;

var _slicedToArray2 = interopRequireDefault(slicedToArray);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var defaults = Object.freeze({
  children: function children(data) {
    return data.children;
  },
  nodeSize: function nodeSize(node) {
    return node.data.size;
  },
  spacing: 0
}); // Create a layout function with customizable options. Per D3-style, the
// options can be set at any time using setter methods. The layout function
// will compute the tree node positions based on the options in effect at the
// time it is called.

function flextree(options) {
  var opts = Object.assign({}, defaults, options);

  function accessor(name) {
    var opt = opts[name];
    return typeof opt === 'function' ? opt : function () {
      return opt;
    };
  }

  function layout(tree) {
    var wtree = wrap(getWrapper(), tree, function (node) {
      return node.children;
    });
    wtree.update();
    return wtree.data;
  }

  function getFlexNode() {
    var nodeSize = accessor('nodeSize');

    var _spacing = accessor('spacing');

    return /*#__PURE__*/function (_hierarchy$prototype$) {
      (0, _inherits2["default"])(FlexNode, _hierarchy$prototype$);

      var _super = _createSuper(FlexNode);

      function FlexNode(data) {
        (0, _classCallCheck2["default"])(this, FlexNode);
        return _super.call(this, data);
      }

      (0, _createClass2["default"])(FlexNode, [{
        key: "copy",
        value: function copy() {
          var c = wrap(this.constructor, this, function (node) {
            return node.children;
          });
          c.each(function (node) {
            return node.data = node.data.data;
          });
          return c;
        }
      }, {
        key: "size",
        get: function get() {
          return nodeSize(this);
        }
      }, {
        key: "spacing",
        value: function spacing(oNode) {
          return _spacing(this, oNode);
        }
      }, {
        key: "nodes",
        get: function get() {
          return this.descendants();
        }
      }, {
        key: "xSize",
        get: function get() {
          return this.size[0];
        }
      }, {
        key: "ySize",
        get: function get() {
          return this.size[1];
        }
      }, {
        key: "top",
        get: function get() {
          return this.y;
        }
      }, {
        key: "bottom",
        get: function get() {
          return this.y + this.ySize;
        }
      }, {
        key: "left",
        get: function get() {
          return this.x - this.xSize / 2;
        }
      }, {
        key: "right",
        get: function get() {
          return this.x + this.xSize / 2;
        }
      }, {
        key: "root",
        get: function get() {
          var ancs = this.ancestors();
          return ancs[ancs.length - 1];
        }
      }, {
        key: "numChildren",
        get: function get() {
          return this.hasChildren ? this.children.length : 0;
        }
      }, {
        key: "hasChildren",
        get: function get() {
          return !this.noChildren;
        }
      }, {
        key: "noChildren",
        get: function get() {
          return this.children === null;
        }
      }, {
        key: "firstChild",
        get: function get() {
          return this.hasChildren ? this.children[0] : null;
        }
      }, {
        key: "lastChild",
        get: function get() {
          return this.hasChildren ? this.children[this.numChildren - 1] : null;
        }
      }, {
        key: "extents",
        get: function get() {
          return (this.children || []).reduce(function (acc, kid) {
            return FlexNode.maxExtents(acc, kid.extents);
          }, this.nodeExtents);
        }
      }, {
        key: "nodeExtents",
        get: function get() {
          return {
            top: this.top,
            bottom: this.bottom,
            left: this.left,
            right: this.right
          };
        }
      }], [{
        key: "maxExtents",
        value: function maxExtents(e0, e1) {
          return {
            top: Math.min(e0.top, e1.top),
            bottom: Math.max(e0.bottom, e1.bottom),
            left: Math.min(e0.left, e1.left),
            right: Math.max(e0.right, e1.right)
          };
        }
      }]);
      return FlexNode;
    }(d3Hierarchy.hierarchy.prototype.constructor);
  }

  function getWrapper() {
    var FlexNode = getFlexNode();
    var nodeSize = accessor('nodeSize');

    var _spacing2 = accessor('spacing');

    return /*#__PURE__*/function (_FlexNode) {
      (0, _inherits2["default"])(_class, _FlexNode);

      var _super2 = _createSuper(_class);

      function _class(data) {
        var _this;

        (0, _classCallCheck2["default"])(this, _class);
        _this = _super2.call(this, data);
        Object.assign((0, _assertThisInitialized2["default"])(_this), {
          x: 0,
          y: 0,
          relX: 0,
          prelim: 0,
          shift: 0,
          change: 0,
          lExt: (0, _assertThisInitialized2["default"])(_this),
          lExtRelX: 0,
          lThr: null,
          rExt: (0, _assertThisInitialized2["default"])(_this),
          rExtRelX: 0,
          rThr: null
        });
        return _this;
      }

      (0, _createClass2["default"])(_class, [{
        key: "size",
        get: function get() {
          return nodeSize(this.data);
        }
      }, {
        key: "spacing",
        value: function spacing(oNode) {
          return _spacing2(this.data, oNode.data);
        }
      }, {
        key: "x",
        get: function get() {
          return this.data.x;
        },
        set: function set(v) {
          this.data.x = v;
        }
      }, {
        key: "y",
        get: function get() {
          return this.data.y;
        },
        set: function set(v) {
          this.data.y = v;
        }
      }, {
        key: "update",
        value: function update() {
          layoutChildren(this);
          resolveX(this);
          return this;
        }
      }]);
      return _class;
    }(FlexNode);
  }

  function wrap(FlexClass, treeData, children) {
    var _wrap = function _wrap(data, parent) {
      var node = new FlexClass(data);
      Object.assign(node, {
        parent: parent,
        depth: parent === null ? 0 : parent.depth + 1,
        height: 0,
        length: 1
      });
      var kidsData = children(data) || [];
      node.children = kidsData.length === 0 ? null : kidsData.map(function (kd) {
        return _wrap(kd, node);
      });

      if (node.children) {
        Object.assign(node, node.children.reduce(function (hl, kid) {
          return {
            height: Math.max(hl.height, kid.height + 1),
            length: hl.length + kid.length
          };
        }, node));
      }

      return node;
    };

    return _wrap(treeData, null);
  }

  Object.assign(layout, {
    nodeSize: function nodeSize(arg) {
      return arguments.length ? (opts.nodeSize = arg, layout) : opts.nodeSize;
    },
    spacing: function spacing(arg) {
      return arguments.length ? (opts.spacing = arg, layout) : opts.spacing;
    },
    children: function children(arg) {
      return arguments.length ? (opts.children = arg, layout) : opts.children;
    },
    hierarchy: function hierarchy(treeData, children) {
      var kids = typeof children === 'undefined' ? opts.children : children;
      return wrap(getFlexNode(), treeData, kids);
    },
    dump: function dump(tree) {
      var nodeSize = accessor('nodeSize');

      var _dump = function _dump(i0) {
        return function (node) {
          var i1 = i0 + '  ';
          var i2 = i0 + '    ';
          var x = node.x,
              y = node.y;
          var size = nodeSize(node);
          var kids = node.children || [];
          var kdumps = kids.length === 0 ? ' ' : ",".concat(i1, "children: [").concat(i2).concat(kids.map(_dump(i2)).join(i2)).concat(i1, "],").concat(i0);
          return "{ size: [".concat(size.join(', '), "],").concat(i1, "x: ").concat(x, ", y: ").concat(y).concat(kdumps, "},");
        };
      };

      return _dump('\n')(tree);
    }
  });
  return layout;
}

var layoutChildren = function layoutChildren(w) {
  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  w.y = y;
  (w.children || []).reduce(function (acc, kid) {
    var _acc = (0, _slicedToArray2["default"])(acc, 2),
        i = _acc[0],
        lastLows = _acc[1];

    layoutChildren(kid, w.y + w.ySize); // The lowest vertical coordinate while extreme nodes still point
    // in current subtree.

    var lowY = (i === 0 ? kid.lExt : kid.rExt).bottom;
    if (i !== 0) separate(w, i, lastLows);
    var lows = updateLows(lowY, i, lastLows);
    return [i + 1, lows];
  }, [0, null]);
  shiftChange(w);
  positionRoot(w);
  return w;
}; // Resolves the relative coordinate properties - relX and prelim --
// to set the final, absolute x coordinate for each node. This also sets
// `prelim` to 0, so that `relX` for each node is its x-coordinate relative
// to its parent.


var resolveX = function resolveX(w, prevSum, parentX) {
  // A call to resolveX without arguments is assumed to be for the root of
  // the tree. This will set the root's x-coord to zero.
  if (typeof prevSum === 'undefined') {
    prevSum = -w.relX - w.prelim;
    parentX = 0;
  }

  var sum = prevSum + w.relX;
  w.relX = sum + w.prelim - parentX;
  w.prelim = 0;
  w.x = parentX + w.relX;
  (w.children || []).forEach(function (k) {
    return resolveX(k, sum, w.x);
  });
  return w;
}; // Process shift and change for all children, to add intermediate spacing to
// each child's modifier.


var shiftChange = function shiftChange(w) {
  (w.children || []).reduce(function (acc, child) {
    var _acc2 = (0, _slicedToArray2["default"])(acc, 2),
        lastShiftSum = _acc2[0],
        lastChangeSum = _acc2[1];

    var shiftSum = lastShiftSum + child.shift;
    var changeSum = lastChangeSum + shiftSum + child.change;
    child.relX += changeSum;
    return [shiftSum, changeSum];
  }, [0, 0]);
}; // Separates the latest child from its previous sibling

/* eslint-disable complexity */


var separate = function separate(w, i, lows) {
  var lSib = w.children[i - 1];
  var curSubtree = w.children[i];
  var rContour = lSib;
  var rSumMods = lSib.relX;
  var lContour = curSubtree;
  var lSumMods = curSubtree.relX;
  var isFirst = true;

  while (rContour && lContour) {
    if (rContour.bottom > lows.lowY) lows = lows.next; // How far to the left of the right side of rContour is the left side
    // of lContour? First compute the center-to-center distance, then add
    // the "spacing"

    var dist = rSumMods + rContour.prelim - (lSumMods + lContour.prelim) + rContour.xSize / 2 + lContour.xSize / 2 + rContour.spacing(lContour);

    if (dist > 0 || dist < 0 && isFirst) {
      lSumMods += dist; // Move subtree by changing relX.

      moveSubtree(curSubtree, dist);
      distributeExtra(w, i, lows.index, dist);
    }

    isFirst = false; // Advance highest node(s) and sum(s) of modifiers

    var rightBottom = rContour.bottom;
    var leftBottom = lContour.bottom;

    if (rightBottom <= leftBottom) {
      rContour = nextRContour(rContour);
      if (rContour) rSumMods += rContour.relX;
    }

    if (rightBottom >= leftBottom) {
      lContour = nextLContour(lContour);
      if (lContour) lSumMods += lContour.relX;
    }
  } // Set threads and update extreme nodes. In the first case, the
  // current subtree is taller than the left siblings.


  if (!rContour && lContour) setLThr(w, i, lContour, lSumMods); // In the next case, the left siblings are taller than the current subtree
  else if (rContour && !lContour) setRThr(w, i, rContour, rSumMods);
};
/* eslint-enable complexity */
// Move subtree by changing relX.


var moveSubtree = function moveSubtree(subtree, distance) {
  subtree.relX += distance;
  subtree.lExtRelX += distance;
  subtree.rExtRelX += distance;
};

var distributeExtra = function distributeExtra(w, curSubtreeI, leftSibI, dist) {
  var curSubtree = w.children[curSubtreeI];
  var n = curSubtreeI - leftSibI; // Are there intermediate children?

  if (n > 1) {
    var delta = dist / n;
    w.children[leftSibI + 1].shift += delta;
    curSubtree.shift -= delta;
    curSubtree.change -= dist - delta;
  }
};

var nextLContour = function nextLContour(w) {
  return w.hasChildren ? w.firstChild : w.lThr;
};

var nextRContour = function nextRContour(w) {
  return w.hasChildren ? w.lastChild : w.rThr;
};

var setLThr = function setLThr(w, i, lContour, lSumMods) {
  var firstChild = w.firstChild;
  var lExt = firstChild.lExt;
  var curSubtree = w.children[i];
  lExt.lThr = lContour; // Change relX so that the sum of modifier after following thread is correct.

  var diff = lSumMods - lContour.relX - firstChild.lExtRelX;
  lExt.relX += diff; // Change preliminary x coordinate so that the node does not move.

  lExt.prelim -= diff; // Update extreme node and its sum of modifiers.

  firstChild.lExt = curSubtree.lExt;
  firstChild.lExtRelX = curSubtree.lExtRelX;
}; // Mirror image of setLThr.


var setRThr = function setRThr(w, i, rContour, rSumMods) {
  var curSubtree = w.children[i];
  var rExt = curSubtree.rExt;
  var lSib = w.children[i - 1];
  rExt.rThr = rContour;
  var diff = rSumMods - rContour.relX - curSubtree.rExtRelX;
  rExt.relX += diff;
  rExt.prelim -= diff;
  curSubtree.rExt = lSib.rExt;
  curSubtree.rExtRelX = lSib.rExtRelX;
}; // Position root between children, taking into account their modifiers


var positionRoot = function positionRoot(w) {
  if (w.hasChildren) {
    var k0 = w.firstChild;
    var kf = w.lastChild;
    var prelim = (k0.prelim + k0.relX - k0.xSize / 2 + kf.relX + kf.prelim + kf.xSize / 2) / 2;
    Object.assign(w, {
      prelim: prelim,
      lExt: k0.lExt,
      lExtRelX: k0.lExtRelX,
      rExt: kf.rExt,
      rExtRelX: kf.rExtRelX
    });
  }
}; // Make/maintain a linked list of the indexes of left siblings and their
// lowest vertical coordinate.


var updateLows = function updateLows(lowY, index, lastLows) {
  // Remove siblings that are hidden by the new subtree.
  while (lastLows !== null && lowY >= lastLows.lowY) {
    lastLows = lastLows.next;
  } // Prepend the new subtree.


  return {
    lowY: lowY,
    index: index,
    next: lastLows
  };
};
});

unwrapExports(tree$2);

var compacttree = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _base = interopRequireDefault(base);



var _trigger2 = interopRequireDefault(trigger);

var _tree2 = interopRequireDefault(tree$2);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Circle = _canvax["default"].Shapes.Circle;
var Rect = _canvax["default"].Shapes.Rect; //内部交互需要同步回源数据的属性， 树状图要实现文本的编辑，所以content也要加入进来

var syncToOriginKeys = ['collapsed', 'style', 'content'];
var iconWidth = 20;
/**
 * 关系图中 包括了  配置，数据，和布局数据，
 * 默认用配置和数据可以完成绘图， 但是如果有布局数据，就绘图玩额外调用一次绘图，把布局数据传入修正布局效果
 */

var compactTree = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(compactTree, _GraphsBase);

  var _super = _createSuper(compactTree);

  function compactTree(opt, app, preComp) {
    var _this;

    (0, _classCallCheck2["default"])(this, compactTree);
    _this = _super.call(this, opt, app, preComp);
    _this.type = "compacttree";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(compactTree.defaultProps()), opt);

    return _this;
  }

  (0, _createClass2["default"])(compactTree, [{
    key: "draw",
    value: function draw(opt) {
      var _this2 = this;

      !opt && (opt = {});

      _.extend(true, this, opt);

      this.initData(opt.data).then(function (data) {
        _this2.data = data;

        _this2.layoutData();

        _this2.widget();

        _this2.induce.context.width = _this2.width;
        _this2.induce.context.height = _this2.height;
        _this2.sprite.context.x = parseInt(_this2.origin.x);
        _this2.sprite.context.y = parseInt(_this2.origin.y); //test bound
        // this._bound = new Rect({
        //     context: {
        //         x: this.data.extents.left,
        //         y: this.data.extents.top,
        //         width: this.data.size.width,
        //         height: this.data.size.height,
        //         lineWidth:1,
        //         strokeStyle: 'red'
        //     }
        // });
        // this.graphsSp.addChild( this._bound )

        if (!_this2.preGraphsSpPosition) {
          _this2.graphsSpPosition = {
            x: Math.max((_this2.width - _this2.data.size.width) / 2, _this2.app.padding.left),
            y: _this2.height / 2
          };
        } else {
          _this2.graphsSpPosition = {
            x: _this2.preGraphsSpPosition.x,
            y: _this2.preGraphsSpPosition.y
          };
        }

        _this2.graphsSp.context.x = _this2.graphsSpPosition.x;
        _this2.graphsSp.context.y = _this2.graphsSpPosition.y;

        _this2.fire("complete");
      });
    } //如果dataTrigger.origin 有传入， 则已经这个origin为参考点做重新布局
    //TODO， 如果这个图的options中有配置 一个 符合 关系图的数据{nodes, edges, size}
    //那么这个时候的resetData还不能满足，因为resetData的第一个个参数是dataFrame， 而options.data其实已经算是配置了，
    //后面遇到这个情况再调整吧

  }, {
    key: "resetData",
    value: function resetData(dataFrame, dataTrigger) {
      var _this3 = this;

      this._resetData(dataFrame, dataTrigger).then(function () {
        _this3.fire("complete"); //test bound
        // Object.assign( this._bound.context, {
        //     x: this.data.extents.left,
        //     y: this.data.extents.top,
        //     width: this.data.size.width,
        //     height: this.data.size.height
        // } );

      });
    }
  }, {
    key: "widget",
    value: function widget() {
      this._drawEdges();

      this._drawNodes();
    } //$data如果用户设置了符合data的数据格式数据{nodes, edges, size, extents}，那就直接返回

  }, {
    key: "initData",
    value: function initData($data, $dataTrigger) {
      var _this4 = this;

      return new Promise(function (resolve) {
        if ($data && $data.nodes && $data.edges) {
          resolve($data);
          return;
        }
        var data = {
          // relation 也好，  tree也好， 最后都要转换成 nodes edges  渲染统一依赖 nodes 和 edges
          //{ type,key,content,ctype,width,height,x,y }
          nodes: [],
          //{ type,key[],content,ctype,width,height,x,y }
          edges: [],
          size: {
            width: 0,
            height: 0
          },
          treeOriginData: null,
          //原始全量的treeData
          treeData: null,
          //折叠过滤掉后的需要渲染的treeData
          nodesLength: 0
        };
        var originData = _this4.app._data;
        data.treeOriginData = originData; //TODO 这里可以 判断 $dataTrigger 如果是来自图表内部的 collapse 等， 
        //就可以不用走下面的 arrayToTreeJsonForRelation ， 后续优化
        //项目里一般都建议直接使用treeData的格式，但是这里要做一次判断是因为chartpark上面做的demo只能下面的格式

        /**
         * [ {id:1,label:''},{id:2,label:''},{id:'1,2',label:''} ]
         */
        //要把这个格式转成 {id:1,children: [{id:2}]} 这样的格式
        //注意，这里不能用dataFrame去做判断，判断不出来的，只能用原始的 originData

        if (Array.isArray(originData)) {
          data.treeOriginData = _this4.arrayToTreeJsonForRelation(_this4.app.dataFrame.jsonOrg, _this4);
        }

        var t = new Date().getTime(); //然后从treeOriginData 过滤掉 需要显示的子树 到 treeData
        //{treeData, nodeLength}这里设置了这两个属性

        Object.assign(data, _this4._filterTreeData(data.treeOriginData));
        var t1 = new Date().getTime();

        _this4._initAllDataSize(data).then(function () {
          //这个时候已经设置好了 treeData 的 size 属性width、height
          //可以开始布局了，布局完就可以设置好 data 的 nodes edges 和 size 属性
          resolve(data);
        });
      });
    } //treeOriginData 一定是一个 树结构的

  }, {
    key: "_filterTreeData",
    value: function _filterTreeData(treeOriginData) {
      var _this5 = this,
          _this$data;

      var nodesLength = 1;
      var collapsedField = this.node.collapse.field;
      var childrenField = this.childrenField;
      var nodes = [];
      var edges = []; // let treeData = {};
      // Object.assign( treeData, treeOriginData );
      // let childrenField = this.childrenField;
      // let children = treeOriginData[ childrenField ];
      // treeData[ childrenField ] = [];
      //parent指向的是treeData不是originData，这里要注意下

      var filter = function filter(treeOriginData, parent, depth, rowInd, treeData) {
        if (treeOriginData) {
          var _treeData$style;

          Object.assign(treeData, {
            depth: depth || 0,
            parent: parent,
            rowInd: rowInd //在parent中的Index

          }); //resetData的时候，有些节点原本有数据的

          var preChildrenList = treeData[childrenField] || [];
          Object.assign(treeData, treeOriginData);
          treeData['__originData'] = treeOriginData; //和原数据建立下关系，比如 treeData 中的一些数据便跟了要同步到原数据中去

          treeData[childrenField] = [];

          if ((treeData === null || treeData === void 0 ? void 0 : (_treeData$style = treeData.style) === null || _treeData$style === void 0 ? void 0 : _treeData$style.visible) == 'hidden') {
            return;
          } //开始构建nodes


          var content = _this5._getContent(treeData); //下面这个判断逻辑主要用在resetData的时候用


          if (treeData._node && content != treeData._node.content) {
            treeData._node = null;
            delete treeData._node;

            if (!treeData.style) {
              treeData.style = {
                width: 0,
                height: 0
              };
            }

            if (!treeOriginData.style || treeOriginData.style && (!treeOriginData.style.width || !treeOriginData.style.height)) {
              treeData.style.width = 0;
              treeData.style.height = 0;
            }
          }

          var node = _this5.getDefNode({
            type: 'tree'
          });

          Object.assign(node, {
            iNode: nodes.length,
            rowData: treeData,
            key: treeData[_this5.field],
            content: content,
            ctype: _this5._checkHtml(content) ? 'html' : 'canvas',
            width: 0,
            height: 0,
            depth: depth || 0 //深度

          }); //不能放到assign中去，  getProp的处理中可能依赖node.rowData

          node.shapeType = _this5.getProp(_this5.node.shapeType, node);
          node.preIconCharCode = _this5.getProp(_this5.node.preIcon.charCode, node);
          node.icons = _this5.getProp(_this5.node.icons, node) || [];

          if (!Array.isArray(node.icons)) {
            node.icons = [node.icons];
          }
          node.icons.forEach(function (icon) {
            var _icon = Object.assign({}, _this5.node.iconsDefault, icon);

            _icon.charCode = _this5.getProp(icon.charCode, node);
            Object.assign(icon, _icon);
          });
          nodes.push(node);
          treeData._node = node;

          if (!treeData[collapsedField]) {
            //如果这个节点未折叠
            //检查他的子节点
            (treeOriginData[childrenField] || []).forEach(function (child, rowInd) {
              var preChildTreeData = preChildrenList.find(function (item) {
                return item[_this5.field] == child[_this5.field];
              }) || {};
              var childTreeData = filter(child, treeData, depth + 1, rowInd, preChildTreeData);

              if (childTreeData) {
                treeData[childrenField].push(childTreeData);
                nodesLength++; //开始构建edges

                var rowData = {};
                var _content = ''; //this._getContent(rowData);

                var edge = _this5.getDefNode({
                  type: 'tree'
                });

                Object.assign(edge, {
                  isTree: true,
                  iNode: edges.length,
                  rowData: rowData,
                  key: [treeData[_this5.field], childTreeData[_this5.field]],
                  //treeData[ this.field ]+","+child[ this.field ],
                  content: _content,
                  ctype: _this5._checkHtml(_content) ? 'html' : 'canvas',
                  //如果是edge，要有source 和 target
                  source: treeData._node,
                  target: childTreeData._node,
                  sourceTreeData: treeData,
                  targetTreeData: childTreeData
                });
                edge.shapeType = _this5.getProp(_this5.line.shapeType, edge);
                edges.push(edge);
              }
            });
          }
        }

        return treeData;
      };

      var preTreeData = ((_this$data = this.data) === null || _this$data === void 0 ? void 0 : _this$data.treeData) || {};
      var treeData = filter(treeOriginData, null, 0, 0, preTreeData);
      return {
        treeData: treeData,
        nodesLength: nodesLength,
        nodes: nodes,
        edges: edges
      };
    } //所有对nodeData原始数据的改变都需要同步到原数据, 比如 collapsed 折叠状态, 还有动态计算出来的width 和 height

  }, {
    key: "_syncToOrigin",
    value: function _syncToOrigin(treeData) {
      for (var k in treeData) {
        if (syncToOriginKeys.indexOf(k) > -1) {
          treeData.__originData[k] = treeData[k];
        }
      }
    }
  }, {
    key: "_eachTreeDataHandle",
    value: function _eachTreeDataHandle(treeData, handle) {
      var _this6 = this;

      handle && handle(treeData);
      (treeData[this.childrenField] || []).forEach(function (nodeData) {
        _this6._eachTreeDataHandle(nodeData, handle);
      });
    }
  }, {
    key: "_initAllDataSize",
    value: function _initAllDataSize(data) {
      var _this7 = this;

      var treeData = data.treeData,
          nodesLength = data.nodesLength;
      var initNum = 0;
      return new Promise(function (resolve) {
        _this7._eachTreeDataHandle(treeData, function (treeDataItem) {
          //计算和设置node的尺寸
          _this7._setSize(treeDataItem).then(function () {
            _this7._setNodeBoundingClientWidth(treeDataItem); // 重新校验一下size， 比如菱形的 外界矩形是不一样的


            _this7.checkNodeSizeForShapeType(treeDataItem._node);

            initNum++;

            if (initNum == nodesLength) {
              //全部处理完毕了
              resolve(data);
            }
          });
        });
      });
    }
  }, {
    key: "_setNodeBoundingClientWidth",
    value: function _setNodeBoundingClientWidth(treeData) {
      var node = treeData._node;
      var boundingClientWidth = node.width || 0;

      if (node.shapeType != 'diamond' && node.depth) {
        if (treeData.__originData[this.childrenField] && treeData.__originData[this.childrenField].length) {
          boundingClientWidth += iconWidth;
        }
      }

      if (node.preIconCharCode) {
        boundingClientWidth += iconWidth;
      }

      if (node.icons && node.icons.length) {
        boundingClientWidth += iconWidth * node.icons.length;
      }
      node.boundingClientWidth = boundingClientWidth;
    }
  }, {
    key: "_setSize",
    value: function _setSize(treeData) {
      var _this8 = this;

      return new Promise(function (resolve) {
        var node = treeData._node; //这里的width都是指内容的size

        var width = treeData.width || treeData.style && treeData.style.width || _this8.getProp(_this8.node.width, treeData);

        var height = treeData.height || treeData.style && treeData.style.height || _this8.getProp(_this8.node.height, treeData);

        if (width && height) {
          //如果node上面已经有了 尺寸 
          //（treeData中自己带了尺寸数据，或者node.width node.height设置了固定的尺寸配置）
          // 这个时候 contentElement 可能就是空（可以有可视范围内渲染优化，布局阶段不需要初始化contentElement），
          var sizeOpt = {
            width: width,
            height: height,
            contentElement: node.contentElement
          }; // opt -> contentElement,width,height 

          _.extend(node, sizeOpt);

          resolve(sizeOpt);
          return;
        }

        _this8._initcontentElementAndSize(treeData).then(function (sizeOpt) {
          _.extend(node, sizeOpt);

          resolve(sizeOpt);
        });
      });
    } //通过 初始化 contnt 来动态计算 size 的走这里

  }, {
    key: "_initcontentElementAndSize",
    value: function _initcontentElementAndSize(treeData) {
      var _this9 = this;

      return new Promise(function (resolve) {
        var node = treeData._node; //那么，走到这里， 就说明需要动态的计算size尺寸，动态计算， 是一定要有contentElement的

        var contentType = node.ctype;

        if (_this9._isField(contentType)) {
          contentType = node.rowData[contentType];
        }
        !contentType && (contentType = 'canvas');

        var _initEle;

        if (contentType == 'canvas') {
          _initEle = _this9._getEleAndsetCanvasSize;
        }

        if (contentType == 'html') {
          _initEle = _this9._getEleAndsetHtmlSize;
        }

        _initEle.apply(_this9, [node]).then(function (sizeOpt) {
          // sizeOpt -> contentElement,width,height 
          _.extend(node, sizeOpt); //动态计算的尺寸，要写入到treeData中去，然后同步到 treeData的 originData，
          //这样就可以 和 整个originData一起存入数据库，后续可以加快再次打开的渲染速度


          if (!treeData.style) {
            treeData.style = {};
          }
          treeData.style.width = node.width;
          treeData.style.height = node.height;

          _this9._syncToOrigin(treeData);

          resolve(sizeOpt);
        });
      });
    }
  }, {
    key: "layoutData",
    value: function layoutData() {
      if (_.isFunction(this.layout)) {
        //layout需要设置好data中nodes的xy， 以及edges的points，和 size的width，height
        this.layout(this.data);
      } else {
        this.treeLayout(this.data); //tree中自己实现layout
      }
    }
  }, {
    key: "treeLayout",
    value: function treeLayout(data) {
      var _this10 = this;

      var childrenField = this.childrenField;
      var layoutIsHorizontal = this.rankdir == 'LR' || this.rankdir == 'RL'; //layoutIsHorizontal = false;

      var t1 = new Date().getTime();
      var spaceX = this.nodesep; //20;

      var spaceY = this.ranksep; //20;

      var layout = (0, _tree2["default"])({
        spacing: spaceX,
        nodeSize: function nodeSize(node) {
          //计算的尺寸已经node的数据为准， 不取treeData的
          var height = node.data._node.height || 0;
          var boundingClientWidth = node.data._node.boundingClientWidth || 0;

          if (layoutIsHorizontal) {
            return [height, boundingClientWidth + spaceY];
          }

          return [boundingClientWidth, height + spaceY]; //因为节点高度包含节点下方的间距
        },
        children: function children(data) {
          return data[childrenField];
        }
      });

      var _tree = layout.hierarchy(data.treeData);

      var _layout = layout(_tree);

      var left = 0,
          top = 0,
          right = 0,
          bottom = 0;
      var maxRight = 0,
          maxLeft = 0,
          maxTop = 0,
          maxBottom = 0;
      var width = 0,
          height = 0;

      _layout.each(function (node) {
        if (layoutIsHorizontal) {
          var x = node.x;
          node.x = node.y;
          node.y = x;
        }

        if (node.x <= left) {
          maxRight = node.x + node.data._node.boundingClientWidth;
        }
        left = Math.min(left, node.x);

        if (node.x + node.data._node.boundingClientWidth >= right) {
          maxLeft = node.x;
        }
        right = Math.max(right, node.x + node.data._node.boundingClientWidth);

        if (node.y <= top) {
          maxBottom = node.y + node.data._node.height;
        }
        top = Math.min(top, node.y);

        if (node.y + node.data._node.height + spaceY >= bottom) {
          maxTop = node.y;
        }

        bottom = Math.max(bottom, node.y + node.data._node.height + spaceY); //node的x y 都是矩形的中心点

        node.data._node.x = node.x + node.data._node.boundingClientWidth / 2;
        node.data._node.y = node.y + node.data._node.height / 2;
        node.data._node.depth = node.depth;
      });

      width = right - left;
      height = bottom - top - spaceY; ////设置edge的points

      data.edges.forEach(function (edge) {
        _this10.getEdgePoints(edge);
      });
      Object.assign(data, {
        size: {
          width: width,
          height: height
        },
        extents: {
          left: left,
          top: top,
          right: right,
          bottom: bottom
        },
        viewPort: {
          maxRight: maxRight,
          maxLeft: maxLeft,
          maxTop: maxTop,
          maxBottom: maxBottom
        }
      });
    } //可以继承覆盖

  }, {
    key: "getEdgePoints",
    value: function getEdgePoints(edge) {
      var points = []; //firstPoint

      var firstPoint = {
        x: parseInt(edge.source.x + edge.source.boundingClientWidth / 2),
        y: parseInt(edge.source.y)
      };

      if (!edge.source.depth) {
        //根节点
        firstPoint.x = parseInt(edge.source.x);
      }

      if (edge.source.shapeType == 'underLine') {
        firstPoint.y = parseInt(edge.source.y + edge.source.height / 2);
      }

      points.push(firstPoint);
      var secPoint = {
        x: firstPoint.x + 10,
        y: firstPoint.y
      };
      points.push(secPoint); //lastPoint

      var lastPoint = {
        x: parseInt(edge.target.x - edge.target.boundingClientWidth / 2),
        y: parseInt(edge.target.y)
      };

      if (edge.target.shapeType == 'underLine') {
        lastPoint.y = parseInt(edge.target.y + edge.target.height / 2);
      } //LR


      points.push({
        x: secPoint.x + parseInt((lastPoint.x - secPoint.x) / 2),
        y: lastPoint.y
      });
      points.push(lastPoint);
      edge.points = points;
      return points;
    }
  }, {
    key: "_drawNodes",
    value: function _drawNodes() {
      var _this11 = this;

      var me = this;

      _.each(this.data.nodes, function (node) {
        var key = node.rowData[_this11.field];

        var drawNode = function drawNode() {
          _this11._drawNode(node); //处理一些tree 相对 relation 特有的逻辑
          //collapse


          if (node.depth && _this11.node.collapse.enabled) {
            var iconId = key + "_collapse_icon";
            var iconBackId = key + "_collapse_icon_back";

            if (node.rowData[_this11.childrenField] && node.rowData.__originData[_this11.childrenField] && node.rowData.__originData[_this11.childrenField].length) {
              var charCode = _this11.node.collapse.openCharCode;

              if (!node.rowData.collapsed) {
                charCode = _this11.node.collapse.closeCharCode;
              }
              var iconText = String.fromCharCode(parseInt(_this11.getProp(charCode, node), 16));

              var fontSize = _this11.getProp(_this11.node.collapse.fontSize, node);

              var fontColor = _this11.getProp(_this11.node.collapse.fontColor, node);

              var fontFamily = _this11.getProp(_this11.node.collapse.fontFamily, node);

              var offsetX = _this11.getProp(_this11.node.collapse.offsetX, node);

              var offsetY = _this11.getProp(_this11.node.collapse.offsetY, node); //let tipsContent= this.getProp( this.node.collapse.tipsContent , node);


              var background = _this11.getProp(_this11.node.collapse.background, node);

              var lineWidth = _this11.getProp(_this11.node.collapse.lineWidth, node);

              var strokeStyle = _this11.getProp(_this11.node.collapse.strokeStyle, node);

              var _collapseIcon = _this11.labelsSp.getChildById(iconId);

              var _collapseIconBack = _this11.labelsSp.getChildById(iconBackId);

              var x = parseInt(node.x + node.boundingClientWidth / 2 + offsetX - _this11.node.padding - fontSize / 4);

              if (node.shapeType == 'diamond') {
                x += _this11.node.padding + fontSize * 1 + 1;
              }

              var y = parseInt(node.y + offsetY); //collapseIcon的 位置默认为左右方向的xy

              var collapseCtx = {
                x: x,
                y: y + 1,
                fontSize: fontSize,
                fontFamily: fontFamily,
                fillStyle: fontColor,
                textAlign: "center",
                textBaseline: "middle",
                cursor: 'pointer'
              };
              var r = parseInt(fontSize * 0.5) + 2;
              var _collapseBackCtx = {
                x: x,
                y: y,
                r: r,
                fillStyle: background,
                strokeStyle: strokeStyle,
                lineWidth: lineWidth
              };

              if (_collapseIcon) {
                _collapseIcon.resetText(iconText);

                Object.assign(_collapseIcon.context, collapseCtx);
                Object.assign(_collapseIconBack.context, _collapseBackCtx);
              } else {
                _collapseIcon = new _canvax["default"].Display.Text(iconText, {
                  id: iconId,
                  context: collapseCtx
                });
                _collapseIconBack = new Circle({
                  id: iconBackId,
                  context: _collapseBackCtx
                });

                _this11.labelsSp.addChild(_collapseIconBack);

                _this11.labelsSp.addChild(_collapseIcon);

                _collapseIcon._collapseIconBack = _collapseIconBack;
                var _me = _this11; //这里不能用箭头函数，听我的没错

                _collapseIcon.on(event.types.get(), function (e) {
                  var trigger = _me.node.collapse;
                  e.eventInfo = {
                    trigger: trigger,
                    tipsContent: _me.node.collapse.tipsContent,
                    nodes: [node] //node

                  }; //下面的这个就只在鼠标环境下有就好了

                  if (_collapseIconBack.context) {
                    if (e.type == 'mousedown') {
                      _collapseIconBack.context.r += 1;
                    }

                    if (e.type == 'mouseup') {
                      _collapseIconBack.context.r -= 1;
                    }
                  }

                  if (_me.node.collapse.triggerEventType.indexOf(e.type) > -1) {
                    this.nodeData.rowData.collapsed = !this.nodeData.rowData.collapsed;

                    _me._syncToOrigin(this.nodeData.rowData);

                    var _trigger = new _trigger2["default"](_me, {
                      origin: key
                    });

                    _me.app.resetData(null, _trigger);
                  }

                  _me.app.fire(e.type, e);
                });
              }
              //collapseIcon的引用就断了

              _collapseIcon.nodeData = node;
              node.collapseIcon = _collapseIcon;
              node.collapseIconBack = _collapseIconBack;
            } else {
              var _collapseIcon2 = _this11.labelsSp.getChildById(iconId);

              if (_collapseIcon2) _collapseIcon2.destroy();

              var _collapseIconBack2 = _this11.labelsSp.getChildById(iconBackId);

              if (_collapseIconBack2) _collapseIconBack2.destroy();
            }
          }

          var getIconStyle = function getIconStyle(prop, charCode) {
            var iconText = String.fromCharCode(parseInt(charCode, 16));
            var fontSize = me.getProp(prop.fontSize, node, charCode);
            var fontColor = me.getProp(prop.fontColor, node, charCode);
            var fontFamily = me.getProp(prop.fontFamily, node, charCode);
            var offsetX = me.getProp(prop.offsetX, node, charCode);
            var offsetY = me.getProp(prop.offsetY, node, charCode);
            var tipsContent = prop.tipsContent; //tips不需要提前计算，hover的时候计算 //me.getProp( prop.tipsContent, node, charCode);

            return {
              iconText: iconText,
              fontSize: fontSize,
              fontColor: fontColor,
              fontFamily: fontFamily,
              offsetX: offsetX,
              offsetY: offsetY,
              tipsContent: tipsContent
            };
          }; //绘制preIcon


          if (node.preIconCharCode) {
            var preIconId = key + "_pre_icon";

            var _getIconStyle = getIconStyle(_this11.node.preIcon, node.preIconCharCode),
                _iconText = _getIconStyle.iconText,
                _fontSize = _getIconStyle.fontSize,
                _fontColor = _getIconStyle.fontColor,
                _fontFamily = _getIconStyle.fontFamily,
                _offsetX = _getIconStyle.offsetX,
                _offsetY = _getIconStyle.offsetY,
                tipsContent = _getIconStyle.tipsContent;

            var _x = parseInt(node.x - node.boundingClientWidth / 2 + _this11.node.padding + _offsetX);

            var _y = parseInt(node.y + _offsetY); //collapseIcon的 位置默认为左右方向的xy


            var preIconCtx = {
              x: _x,
              y: _y + 1,
              fontSize: _fontSize,
              fontFamily: _fontFamily,
              fillStyle: _fontColor,
              textAlign: "left",
              textBaseline: "middle",
              cursor: 'pointer'
            };

            var _preIcon = _this11.labelsSp.getChildById(preIconId);

            if (_preIcon) {
              _preIcon.resetText(_iconText);

              Object.assign(_preIcon.context, preIconCtx);
            } else {
              _preIcon = new _canvax["default"].Display.Text(_iconText, {
                id: preIconId,
                context: preIconCtx
              });

              _this11.labelsSp.addChild(_preIcon);
            }
            node.preIconEl = _preIcon;
          } else {
            if (node.preIconEl) {
              node.preIconEl.destroy();
              delete node.preIconEl;
            }
          } //绘制icons 待续...


          if (node.icons && node.icons.length) {
            var iconsSpId = key + "_icons_sp";

            var _iconsSp = _this11.labelsSp.getChildById(iconsSpId);

            if (_iconsSp) {
              _iconsSp.destroy();
            }
            _iconsSp = new _canvax["default"].Display.Sprite({
              id: iconsSpId
            });

            _this11.labelsSp.addChild(_iconsSp);

            node.icons.forEach(function (icon, i) {
              var _getIconStyle2 = getIconStyle(icon, icon.charCode),
                  iconText = _getIconStyle2.iconText,
                  fontSize = _getIconStyle2.fontSize,
                  fontColor = _getIconStyle2.fontColor,
                  fontFamily = _getIconStyle2.fontFamily,
                  offsetX = _getIconStyle2.offsetX,
                  offsetY = _getIconStyle2.offsetY,
                  tipsContent = _getIconStyle2.tipsContent;

              var x = parseInt(node.x - node.boundingClientWidth / 2 + node.width + offsetX + (node.preIconEl ? iconWidth : 0) - _this11.node.padding / 2);
              var y = parseInt(node.y + offsetY); //collapseIcon的 位置默认为左右方向的xy

              var iconCtx = {
                x: x + i * iconWidth,
                y: y + 1,
                fontSize: fontSize,
                fontFamily: fontFamily,
                fillStyle: fontColor,
                textAlign: "left",
                textBaseline: "middle",
                cursor: 'pointer'
              };

              var _icon = new _canvax["default"].Display.Text(iconText, {
                context: iconCtx
              });

              _iconsSp.addChild(_icon); //这里不能用箭头函数，听我的没错


              _icon.on(event.types.get(), function (e) {
                var trigger = icon;
                e.eventInfo = {
                  trigger: trigger,
                  tipsContent: tipsContent,
                  nodes: [node] //node

                }; //下面的这个就只在鼠标环境下有就好了

                if (this.context) {
                  if (e.type == 'mouseover') {
                    this.context.fontSize += 1;
                  }

                  if (e.type == 'mouseout') {
                    this.context.fontSize -= 1;
                  }
                }
                me.app.fire(e.type, e);
              });
            });
            node.iconsSp = _iconsSp;
          } else {
            if (node.iconsSp) {
              node.iconsSp.destroy();
              delete node.iconsSp;
            }
          }
        }; //绘制的时候一定要准备好conentElement的


        _this11._initcontentElementAndSize(node.rowData).then(function () {
          drawNode();
        }); // if( !node.contentElement ){
        //     //绘制的时候如果发现没有 contentElement，那么就要把 contentElement 初始化了
        //     this._initcontentElementAndSize( node.rowData ).then( ()=>{
        //         drawNode();
        //     } )
        // } else {
        //     drawNode();
        // }

      });
    }
  }, {
    key: "_destroy",
    value: function _destroy(item) {
      var _this12 = this;

      item.shapeElement && item.shapeElement.destroy();

      if (item.contentElement) {
        if (item.contentElement.destroy) {
          item.contentElement.destroy();
        } else {
          //否则就可定是个dom
          this.domContainer.removeChild(item.contentElement);
        }
      }

      item.pathElement && item.pathElement.destroy();
      item.labelElement && item.labelElement.destroy();
      item.arrowElement && item.arrowElement.destroy();
      item.edgeIconElement && item.edgeIconElement.destroy();
      item.edgeIconBack && item.edgeIconBack.destroy(); //下面两个是tree中独有的

      item.collapseIcon && item.collapseIcon.destroy();
      item.collapseIconBack && item.collapseIconBack.destroy();
      item.preIconEl && item.preIconEl.destroy();
      item.iconsSp && item.iconsSp.destroy();

      if (Array.isArray(item[this.field])) {
        //是个edge的话，要检查下源头是不是没有子节点了， 没有子节点了， 还要把collapseIcon 都干掉
        var sourceNode = item.source;

        if (!this.data.edges.find(function (item) {
          return item[_this12.field][0] == sourceNode[_this12.field];
        })) {
          //如歌edges里面还有 targetNode[this.field] 开头的，targetNode 还有子节点, 否则就可以把 targetNode的collapseIcon去掉
          sourceNode.collapseIcon && sourceNode.collapseIcon.destroy();
          sourceNode.collapseIconBack && sourceNode.collapseIconBack.destroy();
        }
      }
    }
  }, {
    key: "arrayToTreeJsonForRelation",
    value: function arrayToTreeJsonForRelation(data) {
      var _this13 = this;

      // [ { key: 1, name: },{key:'1,2'} ] to [ { name: children: [ {}... ] } ] 
      var _nodes = {};
      var _edges = {};

      _.each(data, function (item) {
        var key = item[_this13.field] + '';

        if (key.split(',').length == 1) {
          _nodes[key] = item;
        } else {
          _edges[key] = item;
        }
      }); //先找到所有的一层


      var arr = [];

      _.each(_nodes, function (node, nkey) {
        var isFirstLev = true;

        _.each(_edges, function (edge, ekey) {
          ekey = ekey + '';

          if (ekey.split(',')[1] == nkey) {
            isFirstLev = false;
            return false;
          }
        });

        if (isFirstLev) {
          arr.push(node);
          node.__inRelation = true;
        }
      }); //有了第一层就好办了


      var getChildren = function getChildren(list) {
        _.each(list, function (node) {
          if (node.__cycle) return;
          var key = node[_this13.field];

          _.each(_edges, function (edge, ekey) {
            ekey = ekey + '';

            if (ekey.split(',')[0] == key) {
              //那么说明[1] 就是自己的children
              var childNode = _nodes[ekey.split(',')[1]];

              if (childNode) {
                if (!node[_this13.childrenField]) node[_this13.childrenField] = [];

                if (!_.find(node[_this13.childrenField], function (_child) {
                  return _child[_this13.field] == childNode[_this13.field];
                })) {
                  node[_this13.childrenField].push(childNode);
                }
                //如果这个目标节点__inRelation已经在关系结构中
                //那么说明形成闭环了，不需要再分析这个节点的children

                if (childNode.__inRelation) {
                  childNode.__cycle = true;
                }
              }
            }
          });

          if (node[_this13.childrenField] && node[_this13.childrenField].length) {
            getChildren(node[_this13.childrenField]);
          }
        });
      };

      getChildren(arr);
      return arr.length ? arr[0] : null;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        childrenField: {
          detail: '树结构数据的关联字段',
          documentation: '如果是树结构的关联数据，不是行列式，那么就通过这个字段来建立父子关系',
          "default": 'children'
        },
        rankdir: {
          detail: '布局方向',
          "default": 'LR'
        },
        layout: {
          detail: '紧凑的树布局方案， 也可以设置为一个function，自定义布局算法',
          "default": "tree"
        },
        layoutOpts: {
          detail: '布局引擎对应的配置',
          propertys: {}
        },
        ranksep: {
          detail: '排与排之间的距离',
          "default": 40
        },
        nodesep: {
          detail: '同级node之间的距离',
          "default": 20
        },
        node: {
          detail: '单个节点的配置',
          propertys: {
            content: {
              detail: ' 内容配置',
              propertys: {
                textAlign: {
                  detail: '左右对齐方式',
                  "default": 'left'
                }
              }
            },
            collapse: {
              detail: '树状图是否有节点收缩按钮',
              propertys: {
                enabled: {
                  detail: "是否开启",
                  "default": true
                },
                field: {
                  detail: "用来记录collapsed是否折叠的字段，在节点的数据上",
                  "default": "collapsed"
                },
                triggerEventType: {
                  detail: '触发事件',
                  "default": 'click,tap'
                },
                openCharCode: {
                  detail: "点击后触发展开的icon chartCode，当前状态为收缩",
                  "default": ''
                },
                closeCharCode: {
                  detail: "点击后触发收缩的icon chartCode，当前状态为展开",
                  "default": ''
                },
                fontSize: {
                  detail: "icon字号大小",
                  "default": 10
                },
                fontColor: {
                  detail: "icon字体颜色",
                  "default": '#666'
                },
                fontFamily: {
                  detail: "icon在css中的fontFamily",
                  "default": 'iconfont'
                },
                tipsContent: {
                  detail: '鼠标移动到收缩icon上面的tips内容',
                  "default": ''
                },
                offsetX: {
                  detail: 'x方向偏移量',
                  "default": 0
                },
                offsetY: {
                  detail: 'y方向偏移量',
                  "default": 0
                },
                background: {
                  detail: 'icon的 背景色',
                  "default": '#fff'
                },
                lineWidth: {
                  detail: '边框大小',
                  "default": 1
                },
                strokeStyle: {
                  detail: '描边颜色',
                  "default": '#667894'
                }
              }
            },
            preIcon: {
              detail: '内容前面的一个icon，主要用来描这个node的类型',
              propertys: {
                charCode: {
                  detail: "icon的iconfont字符串",
                  "default": ''
                },
                fontSize: {
                  detail: "icon字号大小",
                  "default": 18
                },
                fontColor: {
                  detail: "icon字体颜色",
                  "default": '#666'
                },
                fontFamily: {
                  detail: "icon在css中的fontFamily",
                  "default": 'iconfont'
                },
                tipsContent: {
                  detail: '鼠标移动到收缩icon上面的tips内容',
                  "default": ''
                },
                offsetX: {
                  detail: 'x方向偏移量',
                  "default": 0
                },
                offsetY: {
                  detail: 'y方向偏移量',
                  "default": 0
                }
              }
            },
            icons: {
              detail: '相对于preIcon，跟在label后面的一组icon',
              "default": []
            },
            iconsDefault: {
              detail: '内容后面的一组icon，是个数组， 支持函数返回一组icon，单个icon的格式和preIcon保持一致',
              propertys: {
                charCode: {
                  detail: "icon的iconfont字符串",
                  "default": ''
                },
                fontSize: {
                  detail: "icon字号大小",
                  "default": 12
                },
                fontColor: {
                  detail: "icon字体颜色",
                  "default": '#666'
                },
                fontFamily: {
                  detail: "icon在css中的fontFamily",
                  "default": 'iconfont'
                },
                tipsContent: {
                  detail: '鼠标移动到收缩icon上面的tips内容',
                  "default": ''
                },
                offsetX: {
                  detail: 'x方向偏移量',
                  "default": 0
                },
                offsetY: {
                  detail: 'y方向偏移量',
                  "default": 0
                }
              }
            }
          }
        },
        line: {
          detail: '连线配置',
          propertys: {
            arrow: {
              detail: '箭头配置',
              propertys: {
                enabled: {
                  detail: '是否显示',
                  "default": false
                }
              }
            },
            edgeLabel: {
              detail: '连线文本',
              propertys: {
                enabled: {
                  detail: '是否要连线的文本',
                  "default": false
                }
              }
            },
            icon: {
              detail: '连线上的icon',
              propertys: {
                enabled: {
                  detail: '是否要连线上的icon',
                  "default": false
                }
              }
            }
          }
        }
      };
    }
  }]);
  return compactTree;
}(_base["default"]);

_base["default"].registerComponent(compactTree, 'graphs', 'compacttree');

var _default = compactTree;
exports["default"] = _default;
});

unwrapExports(compacttree);

function center(x, y) {
  var nodes, strength = 1;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  return force;
}

function tree_add(d) {
  const x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add$1(this.cover(x, y), x, y, d);
}

function add$1(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add$1(this, xz[i], yz[i], data[i]);
  }

  return this;
}

function tree_cover(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0 || 1,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

function tree_data() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}

function tree_extent(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}

function Quad(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

function tree_find(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new Quad(node[3], xm, ym, x2, y2),
        new Quad(node[2], x1, ym, xm, y2),
        new Quad(node[1], xm, y1, x2, ym),
        new Quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}

function tree_remove(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll$1(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

function tree_root() {
  return this._root;
}

function tree_size() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}

function tree_visit(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
}

function tree_visitAfter(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

function defaultX(d) {
  return d[0];
}

function tree_x(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

function defaultY(d) {
  return d[1];
}

function tree_y(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll$1;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

function constant$2(x) {
  return function() {
    return x;
  };
}

function jiggle(random) {
  return (random() - 0.5) * 1e-6;
}

function x$1(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

function collide(radius) {
  var nodes,
      radii,
      random,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = constant$2(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = quadtree(nodes, x$1, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = jiggle(random), l += x * x;
            if (y === 0) y = jiggle(random), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : radius;
  };

  return force;
}

function index$2(d) {
  return d.index;
}

function find$1(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}

function link(links) {
  var id = index$2,
      strength = defaultStrength,
      strengths,
      distance = constant$2(30),
      distances,
      nodes,
      count,
      bias,
      random,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || jiggle(random);
        y = target.y + target.vy - source.y - source.vy || jiggle(random);
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find$1(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find$1(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant$2(+_), initializeDistance(), force) : distance;
  };

  return force;
}

var noop$1 = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get$1(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now$3() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now$3() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now$3(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
const a = 1664525;
const c = 1013904223;
const m = 4294967296; // 2^32

function lcg() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}

function x$2(d) {
  return d.x;
}

function y$1(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

function simulation(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = new Map(),
      stepper = timer(step),
      event = dispatch("tick", "end"),
      random = lcg();

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.forEach(function(force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}

function manyBody() {
  var nodes,
      node,
      random,
      alpha,
      strength = constant$2(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = quadtree(nodes, x$2, y$1).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = jiggle(random), l += x * x;
        if (y === 0) y = jiggle(random), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = jiggle(random), l += x * x;
      if (y === 0) y = jiggle(random), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}

function radial(radius, x, y) {
  var nodes,
      strength = constant$2(0.1),
      strengths,
      radiuses;

  if (typeof radius !== "function") radius = constant$2(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _, initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : radius;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}

function x$3(x) {
  var strength = constant$2(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = constant$2(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : x;
  };

  return force;
}

function y$2(y) {
  var strength = constant$2(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = constant$2(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : y;
  };

  return force;
}



var src = /*#__PURE__*/Object.freeze({
	__proto__: null,
	forceCenter: center,
	forceCollide: collide,
	forceLink: link,
	forceManyBody: manyBody,
	forceRadial: radial,
	forceSimulation: simulation,
	forceX: x$3,
	forceY: y$2
});

var force_1 = createCommonjsModule(function (module, exports) {





Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(graphs);

var force = _interopRequireWildcard(src);



function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof_1$1(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Circle = _canvax["default"].Shapes.Circle;
var Text = _canvax["default"].Display.Text;
var Line = _canvax["default"].Shapes.Line;

var Force = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(Force, _GraphsBase);

  var _super = _createSuper(Force);

  function Force(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, Force);
    _this = _super.call(this, opt, app);
    _this.type = "force";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(Force.defaultProps()), opt);

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(Force, [{
    key: "init",
    value: function init() {
      this.nodesSp = new _canvax["default"].Display.Sprite({
        id: "nodesSp"
      });
      this.edgesSp = new _canvax["default"].Display.Sprite({
        id: "edgesSp"
      });
      this.graphsSp = new _canvax["default"].Display.Sprite({
        id: "graphsSp"
      });
      this.graphsSp.addChild(this.edgesSp);
      this.graphsSp.addChild(this.nodesSp);
      this.sprite.addChild(this.graphsSp);
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {});

      _.extend(true, this, opt);

      this.data = opt.data || this._initData();
      this.widget();
      this.fire("complete");
    }
  }, {
    key: "_initData",
    value: function _initData() {
      var _this2 = this;

      //和关系图那边保持data格式的统一
      var data = {
        nodes: [//{ type,key,label,ctype,width,height,x,y }
        ],
        edges: [//{ type,key[],label,ctype,width,height,x,y }
        ],
        size: {
          width: this.app.width,
          height: this.app.height
        }
      };
      var _nodeMap = {};
      var nodeValMin = 0,
          nodeValMax = 0,
          lineValMin = 0,
          lineValMax = 0;

      for (var i = 0; i < this.dataFrame.length; i++) {
        var rowData = this.dataFrame.getRowDataAt(i);

        var fields = _.flatten([(rowData[this.keyField] + "").split(",")]);

        var label = this._getContent(rowData);

        var key = fields.length == 1 ? fields[0] : fields;
        var value = rowData[this.field];
        var element = new _canvax["default"].Display.Sprite({
          id: "nodeSp_" + key
        });
        this.graphsSp.addChild(element);
        var node = {
          type: "force",
          field: this.field,
          iNode: i,
          rowData: rowData,
          key: key,
          value: value,
          label: label,
          //下面三个属性在_setElementAndSize中设置
          element: element,
          //外面传的layout数据可能没有element，widget的时候要检测下
          width: null,
          height: null,
          //radius : 1,    //默认为1
          //distance: 20,  //如果是
          //这个在layout的时候设置
          x: null,
          y: null,
          shapeType: null,
          //如果是edge，要填写这两节点
          source: null,
          target: null
        }; //_.extend(node, this._getElementAndSize(node));

        if (fields.length == 1) {
          node.shapeType = this.getProp(this.node.shapeType, node);
          data.nodes.push(node);
          _nodeMap[node.key] = node;

          if (value != undefined) {
            nodeValMin = Math.min(nodeValMin, value);
            nodeValMax = Math.max(nodeValMax, value);
          }
        } else {
          node.shapeType = "line";
          data.edges.push(node);

          if (value != undefined) {
            lineValMin = Math.min(lineValMin, value);
            lineValMax = Math.max(lineValMax, value);
          }
        }
      }
      this.nodeValMin = nodeValMin;
      this.nodeValMax = nodeValMax;
      this.lineValMin = lineValMin;
      this.lineValMax = lineValMax;
      data.nodes.forEach(function (node) {
        //计算 node的 半径 width height 和 style等
        node.radius = _this2.node.radius ? _this2.getProp(_this2.node.radius, node) : _this2._getNodeRadius(node);
        node.width = node.height = node.radius * 2;
      });
      data.edges.forEach(function (edge) {
        var keys = edge.key;
        edge.source = _nodeMap[keys[0]];
        edge.target = _nodeMap[keys[1]];
        edge.distance = _this2.line.distance ? _this2.getProp(_this2.node.distance, edge) : _this2._getLineDistance(edge);
      });
      return data;
    } //this.node.radius为null的时候 内部默认的计算radius的方法

  }, {
    key: "_getNodeRadius",
    value: function _getNodeRadius(nodeData) {
      var val = nodeData.value;
      var radius = this.node.radiusMin;

      if (val) {
        radius += (this.node.radiusMax - this.node.radiusMin) / (this.nodeValMax - this.nodeValMin) * val;
      }

      return parseInt(radius);
    } //this.line.distance 为null的时候 内部默认的计算 distance 的方法

  }, {
    key: "_getLineDistance",
    value: function _getLineDistance(nodeData) {
      var val = nodeData.value;
      var distance = this.line.distanceMin;

      if (val) {
        distance += (this.line.distanceMax - this.line.distanceMin) / (this.lineValMax - this.lineValMin) * val;
      }

      return parseInt(distance);
    }
  }, {
    key: "widget",
    value: function widget() {
      var _this3 = this;

      var me = this;
      var keyField = this.keyField;
      var field = this.field;
      var links = this.data.edges.map(function (d) {
        //source: "Napoleon", target: "Myriel", value: 1
        return {
          source: d.source[keyField],
          target: d.target[keyField],
          value: d.rowData[field],
          nodeData: d
        };
      });
      var nodes = this.data.nodes.map(function (d) {
        var node = Object.create(d);
        node.id = d.key;
        node.nodeData = d;
        return node;
      });
      var _this$data$size = this.data.size,
          width = _this$data$size.width,
          height = _this$data$size.height;
      var simulation = force.forceSimulation(nodes).force("link", force.forceLink(links).id(function (d) {
        return d.id;
      }).distance(function (edge, edgeIndex, edges) {
        var distance = edge.nodeData.distance;
        var distanceNodes = edge.source.nodeData.radius + edge.target.nodeData.radius;
        return Math.max(distance, distanceNodes);
      })).force("charge", force.forceManyBody().distanceMin(this.line.distanceMin).distanceMax(this.line.distanceMax).strength(this.node.strength)) //节点间作用力
      .force("center", force.forceCenter(width / 2, height / 2)).force('collide', force.forceCollide().radius(function (node, nodeIndex, nodes) {
        return node.nodeData.radius;
      })).force("x", force.forceX()).force("y", force.forceY()).alpha(0.5);
      nodes.forEach(function (node) {
        var fillStyle = me.getProp(me.node.fillStyle, node.nodeData);
        var strokeStyle = me.getProp(me.node.strokeStyle, node.nodeData);
        var lineWidth = me.getProp(me.node.lineWidth, node.nodeData);
        var nodeAlpha = me.getProp(me.node.nodeAlpha, node.nodeData); //写回nodeData里面，tips等地方需要

        node.nodeData.fillStyle = fillStyle;
        var r = node.nodeData.radius;

        var _node = new Circle({
          context: {
            r: r,
            fillStyle: fillStyle,
            strokeStyle: strokeStyle,
            lineWidth: lineWidth,
            globalAlpha: nodeAlpha,
            cursor: 'pointer'
          }
        });

        node.nodeData.element.addChild(_node);
        _node.nodeData = node.nodeData;

        _node.on(event.types.get(), function (e) {
          e.eventInfo = {
            trigger: 'this.node',
            nodes: [this.nodeData]
          };
          me.app.fire(e.type, e);
        });

        var labelFontSize = me.getProp(me.label.fontSize, node.nodeData);
        var labelFontColor = me.getProp(me.label.fontColor, node.nodeData);
        var labelTextBaseline = me.getProp(me.label.textBaseline, node.nodeData);
        var labelTextAlign = me.getProp(me.label.textAlign, node.nodeData);

        var _label = new Text(node.nodeData.label, {
          context: {
            fontSize: labelFontSize,
            fillStyle: labelFontColor,
            textBaseline: labelTextBaseline,
            textAlign: labelTextAlign,
            globalAlpha: 0.7
          }
        });

        node.nodeData.element.addChild(_label);
      });
      links.forEach(function (link) {
        var lineWidth = me.getProp(me.line.lineWidth, link.nodeData);
        var strokeStyle = me.getProp(me.line.strokeStyle, link.nodeData);
        var lineType = me.getProp(me.line.lineType, link.nodeData);
        var lineAlpha = me.getProp(me.line.lineAlpha, link.nodeData);
        link.nodeData.strokeStyle = strokeStyle;

        var _line = new Line({
          context: {
            lineWidth: lineWidth,
            strokeStyle: strokeStyle,
            lineType: lineType,
            start: {
              x: 0,
              y: 0
            },
            end: {
              x: 0,
              y: 0
            },
            globalAlpha: lineAlpha
          }
        });

        _this3.edgesSp.addChild(_line);

        link.line = _line;
      });
      simulation.on("tick", function () {
        if (simulation.alpha() <= 0.05) {
          simulation.stop();
          return;
        }
        nodes.forEach(function (node) {
          var elemCtx = node.nodeData.element.context;

          if (elemCtx) {
            elemCtx.x = node.x;
            elemCtx.y = node.y;
          }
        });
        links.forEach(function (link) {
          var lineCtx = link.line.context;

          if (lineCtx) {
            lineCtx.start.x = link.source.x;
            lineCtx.start.y = link.source.y;
            lineCtx.end.x = link.target.x;
            lineCtx.end.y = link.target.y;
          }
        });
      });
    }
    /**
     * 字符串是否含有html标签的检测
     */

  }, {
    key: "_checkHtml",
    value: function _checkHtml(str) {
      var reg = /<[^>]+>/g;
      return reg.test(str);
    }
  }, {
    key: "_getContent",
    value: function _getContent(rowData) {
      var me = this;

      var _c; //this.label;


      if (this._isField(this.label.field)) {
        _c = rowData[this.label.field];
      }

      if (me.label.format) {
        if (_.isFunction(me.label.format)) {
          _c = me.label.format.apply(this, [_c, rowData]);
        }
      } else {
        //否则用fieldConfig上面的
        var _coord = me.app.getComponent({
          name: 'coord'
        });

        var fieldConfig = _coord.getFieldConfig(me.keyField);

        if (fieldConfig) {
          _c = fieldConfig.getFormatValue(_c);
        }
      }
      return _c;
    }
  }, {
    key: "_isField",
    value: function _isField(str) {
      return ~this.dataFrame.fields.indexOf(str);
    }
  }, {
    key: "getNodesAt",
    value: function getNodesAt() {}
  }, {
    key: "getProp",
    value: function getProp(prop, nodeData) {
      var _prop = prop;

      if (this._isField(prop) && nodeData.rowData) {
        _prop = nodeData.rowData[prop];
      } else {
        if (_.isArray(prop)) {
          _prop = prop[nodeData.iNode];
        }

        if (_.isFunction(prop)) {
          _prop = prop.apply(this, [nodeData]);
        }
      }
      return _prop;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        keyField: {
          detail: 'key字段',
          "default": ''
        },
        field: {
          detail: 'value字段，node，link都公用这个字段',
          "default": ''
        },
        node: {
          detail: '单个节点的配置',
          propertys: {
            shapeType: {
              detail: '节点图形',
              "default": 'circle'
            },
            radiusMin: {
              detail: '最小节点半径',
              "default": 6
            },
            radiusMax: {
              detail: '最大节点半径',
              "default": 30
            },
            radius: {
              detail: '节点半径',
              "default": null
            },
            fillStyle: {
              detail: '节点背景色',
              "default": '#acdf7d'
            },
            strokeStyle: {
              detail: '描边颜色',
              "default": '#e5e5e5'
            },
            lineWidth: {
              detail: '描边线宽',
              "default": 0
            },
            nodeAlpha: {
              detail: '节点透明度',
              "default": 1
            },
            strength: {
              detail: '节点之间作用力',
              "default": -300
            }
          }
        },
        line: {
          detail: '两个节点连线配置',
          propertys: {
            lineWidth: {
              detail: '线宽',
              "default": 1
            },
            strokeStyle: {
              detail: '连线的颜色',
              "default": '#e5e5e5'
            },
            lineType: {
              detail: '连线样式（虚线等）',
              "default": 'solid'
            },
            lineAlpha: {
              detail: '连线透明度',
              "default": 0.6
            },
            distanceMin: {
              detail: '最小连线距离',
              "default": 30
            },
            distanceMax: {
              detail: '最大连线距离',
              "default": 200
            },
            distance: {
              detail: '连线距离',
              "default": null
            },
            arrow: {
              detail: '是否有箭头',
              "default": true
            }
          }
        },
        label: {
          detail: '节点内容配置',
          propertys: {
            field: {
              detail: '内容字段',
              "default": 'label'
            },
            fontColor: {
              detail: '内容文本颜色',
              "default": '#666'
            },
            format: {
              detail: '内容格式化处理函数',
              "default": null
            },
            textAlign: {
              detail: "textAlign",
              "default": "center"
            },
            textBaseline: {
              detail: 'textBaseline',
              "default": "middle"
            }
          }
        }
      };
    }
  }, {
    key: "polyfill",
    value: function polyfill(opt) {
      if (opt.valueField) {
        //20220304 所有的graph都统一一个field
        opt.field = opt.valueField;
        delete opt.valueField;
      }

      return opt;
    }
  }]);
  return Force;
}(_index["default"]);

_index["default"].registerComponent(Force, 'graphs', 'force');

var _default = Force;
exports["default"] = _default;
});

unwrapExports(force_1);

var projection = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var filterNum = 0; //间隔多少个点绘制

function getBbox(json, specialArea) {
  if (!json.srcSize) {
    parseSrcSize(json, specialArea);
  }
  return json.srcSize;
}

function parseSrcSize(json) {
  var specialArea = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  convertorParse.xmin = 360;
  convertorParse.xmax = -360;
  convertorParse.ymin = 180;
  convertorParse.ymax = -180;
  var shapes = json.features;
  var geometries;
  var shape;

  for (var i = 0, len = shapes.length; i < len; i++) {
    shape = shapes[i];

    if (shape.properties.name && specialArea.indexOf(shape.properties.name) > -1 || shape.properties.adcode && specialArea.indexOf(shape.properties.adcode) > -1) {
      continue;
    }

    switch (shape.type) {
      case 'Feature':
        convertorParse[shape.geometry.type](shape.geometry.coordinates);
        break;

      case 'GeometryCollection':
        geometries = shape.geometries;

        for (var j = 0, len2 = geometries.length; j < len2; j++) {
          convertorParse[geometries[j].type](geometries[j].coordinates);
        }

        break;
    }
  }

  json.srcSize = {
    left: convertorParse.xmin.toFixed(4) * 1,
    top: convertorParse.ymin.toFixed(4) * 1,
    width: (convertorParse.xmax - convertorParse.xmin).toFixed(4) * 1,
    height: (convertorParse.ymax - convertorParse.ymin).toFixed(4) * 1
  };
  return json;
}

var convertor = {
  //调整俄罗斯东部到地图右侧与俄罗斯相连
  formatPoint: function formatPoint(p) {
    return [(p[0] < -168.5 && p[1] > 63.8 ? p[0] + 360 : p[0]) + 168.5, 90 - p[1]];
  },
  makePoint: function makePoint(p) {
    var self = this;
    var point = self.formatPoint(p); // for cp

    if (self._bbox.xmin > p[0]) {
      self._bbox.xmin = p[0];
    }

    if (self._bbox.xmax < p[0]) {
      self._bbox.xmax = p[0];
    }

    if (self._bbox.ymin > p[1]) {
      self._bbox.ymin = p[1];
    }

    if (self._bbox.ymax < p[1]) {
      self._bbox.ymax = p[1];
    }

    var x = (point[0] - convertor.offset.x) * convertor.scale.x + convertor.offset.left;
    var y = (point[1] - convertor.offset.y) * convertor.scale.y + convertor.offset.top;
    return [x, y];
  },
  Point: function Point(coordinates) {
    coordinates = this.makePoint(coordinates);
    return coordinates.join(',');
  },
  LineString: function LineString(coordinates) {
    var str = '';
    var point;

    for (var i = 0, len = coordinates.length; i < len; i++) {
      if (i % (filterNum + 1) && len > filterNum) continue;
      point = convertor.makePoint(coordinates[i]);

      if (i === 0) {
        str = 'M' + point.join(',');
      } else {
        str = str + 'L' + point.join(',');
      }
    }

    return str;
  },
  Polygon: function Polygon(coordinates) {
    var str = '';

    for (var i = 0, len = coordinates.length; i < len; i++) {
      str = str + convertor.LineString(coordinates[i]) + 'z';
    }

    return str;
  },
  MultiPoint: function MultiPoint(coordinates) {
    var arr = [];

    for (var i = 0, len = coordinates.length; i < len; i++) {
      arr.push(convertor.Point(coordinates[i]));
    }

    return arr;
  },
  MultiLineString: function MultiLineString(coordinates) {
    var str = '';

    for (var i = 0, len = coordinates.length; i < len; i++) {
      str += convertor.LineString(coordinates[i]);
    }

    return str;
  },
  MultiPolygon: function MultiPolygon(coordinates) {
    var str = '';

    for (var i = 0, len = coordinates.length; i < len; i++) {
      str += convertor.Polygon(coordinates[i]);
    }

    return str;
  }
};
var convertorParse = {
  formatPoint: convertor.formatPoint,
  makePoint: function makePoint(p) {
    var self = this;
    var point = self.formatPoint(p);
    var x = point[0];
    var y = point[1];

    if (self.xmin > x) {
      self.xmin = x;
    }

    if (self.xmax < x) {
      self.xmax = x;
    }

    if (self.ymin > y) {
      self.ymin = y;
    }

    if (self.ymax < y) {
      self.ymax = y;
    }
  },
  Point: function Point(coordinates) {
    this.makePoint(coordinates);
  },
  LineString: function LineString(coordinates) {
    for (var i = 0, len = coordinates.length; i < len; i++) {
      if (i % (filterNum + 1) && len > filterNum) continue;
      this.makePoint(coordinates[i]);
    }
  },
  Polygon: function Polygon(coordinates) {
    for (var i = 0, len = coordinates.length; i < len; i++) {
      this.LineString(coordinates[i]);
    }
  },
  MultiPoint: function MultiPoint(coordinates) {
    for (var i = 0, len = coordinates.length; i < len; i++) {
      this.Point(coordinates[i]);
    }
  },
  MultiLineString: function MultiLineString(coordinates) {
    for (var i = 0, len = coordinates.length; i < len; i++) {
      this.LineString(coordinates[i]);
    }
  },
  MultiPolygon: function MultiPolygon(coordinates) {

    for (var i = 0, len = coordinates.length; i < len; i++) {
      this.Polygon(coordinates[i]);
    }
  }
};

function geoJson2Path(json, transform) {
  var specialArea = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  convertor.scale = null;
  convertor.offset = null;

  if (!json.srcSize) {
    parseSrcSize(json, specialArea);
  }

  transform.offset = {
    x: json.srcSize.left,
    y: json.srcSize.top,
    left: transform.OffsetLeft || 0,
    top: transform.OffsetTop || 0
  };
  convertor.scale = transform.scale;
  convertor.offset = transform.offset;
  var shapes = json.features;
  var geometries;
  var pathArray = [];
  var val;
  var shape;

  for (var i = 0, len = shapes.length; i < len; i++) {
    shape = shapes[i];

    if (shape.properties.name && specialArea.indexOf(shape.properties.name) > -1 || shape.properties.adcode && specialArea.indexOf(shape.properties.adcode) > -1) {
      // 忽略specialArea
      continue;
    }

    if (shape.type == 'Feature') {
      pushApath(shape.geometry, shape);
    } else if (shape.type == 'GeometryCollection') {
      geometries = shape.geometries;

      for (var j = 0, len2 = geometries.length; j < len2; j++) {
        val = geometries[j];
        pushApath(val, val);
      }
    }
  }

  var shapeType;
  var shapeCoordinates;
  var str;

  function pushApath(gm, shape) {
    shapeType = gm.type;
    shapeCoordinates = gm.coordinates;
    convertor._bbox = {
      xmin: 360,
      xmax: -360,
      ymin: 180,
      ymax: -180
    };
    str = convertor[shapeType](shapeCoordinates);
    pathArray.push({
      // type: shapeType,
      path: str,
      cp: shape.properties.cp ? convertor.makePoint(shape.properties.cp) : convertor.makePoint([(convertor._bbox.xmin + convertor._bbox.xmax) / 2, (convertor._bbox.ymin + convertor._bbox.ymax) / 2]),
      properties: shape.properties,
      adcode: shape.properties.adcode
    });
  }

  return pathArray;
}
/**
 * 平面坐标转经纬度
 * @param {Array} p
 */


function pos2geo(obj, p) {
  var x;
  var y;

  if (p instanceof Array) {
    x = p[0] * 1;
    y = p[1] * 1;
  } else {
    x = p.x * 1;
    y = p.y * 1;
  }

  x = x / obj.scale.x + obj.offset.x - 168.5;
  x = x > 180 ? x - 360 : x;
  y = 90 - (y / obj.scale.y + obj.offset.y);
  return [x, y];
}
/**
 * 经纬度转平面坐标
 * @param {Array | Object} p
 */


function geo2pos(obj, p) {
  convertor.offset = obj.offset;
  convertor.scale = obj.scale;

  if (p instanceof Array) {
    return convertor.makePoint([p[0] * 1, p[1] * 1]);
  } else {
    return convertor.makePoint([p.x * 1, p.y * 1]);
  }
}

var _default = {
  getBbox: getBbox,
  geoJson2Path: geoJson2Path,
  pos2geo: pos2geo,
  geo2pos: geo2pos
};
exports["default"] = _default;
});

unwrapExports(projection);

var trans = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;



var _projection = interopRequireDefault(projection);

var rate = 0.75;
/**
 * 
 * @param {Object} geoData 
 * @param {Object} graphBBox 绘制在什么位置{x,y,width,height} 
 */

function _default(geoData, graphBBox) {
  var specialArea = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  //先过一遍解码，么有编码的数据会直接返回
  geoData.json = decode(geoData.json);

  var data = _getProjectionData(geoData, graphBBox, specialArea);

  return data;
}

var _getProjectionData = function _getProjectionData(geoData, graphBBox, specialArea) {
  var province = [];

  var bbox = geoData.bbox || _projection["default"].getBbox(geoData.json, specialArea);

  var transform = _getTransform(bbox, graphBBox, rate);

  var lastTransform = geoData.lastTransform || {
    scale: {}
  };
  var pathArray;

  if (transform.left != lastTransform.left || transform.top != lastTransform.top || transform.scale.x != lastTransform.scale.x || transform.scale.y != lastTransform.scale.y) {
    //发生过变化，需要重新生成pathArray
    pathArray = _projection["default"].geoJson2Path(geoData.json, transform, specialArea);
    lastTransform = Canvax._.clone(transform);
  } else {
    transform = geoData.transform;
    pathArray = geoData.pathArray;
  }

  geoData.bbox = bbox;
  geoData.transform = transform;
  geoData.lastTransform = lastTransform;
  geoData.pathArray = pathArray;
  var position = [transform.left, transform.top];

  for (var i = 0, l = pathArray.length; i < l; i++) {
    province.push(_getSingleProvince(geoData, pathArray[i], position, bbox));
  }
  return province;
};

var _getTransform = function _getTransform(bbox, graphBBox, rate) {
  var width = graphBBox.width,
      height = graphBBox.height;
  var mapWidth = bbox.width;
  var mapHeight = bbox.height; //var minScale;

  var xScale = width / rate / mapWidth;
  var yScale = height / mapHeight;

  if (xScale > yScale) {
    //minScale = yScale;
    xScale = yScale * rate;
    width = mapWidth * xScale;
  } else {
    yScale = xScale;
    xScale = yScale * rate;
    height = mapHeight * yScale;
  }

  return {
    left: 0,
    top: 0,
    width: width,
    height: height,
    baseScale: 1,
    scale: {
      x: xScale,
      y: yScale
    }
  };
};

var _getSingleProvince = function _getSingleProvince(geoData, path, position, bbox) {
  var textPosition;
  var name = path.properties.name;
  var textFixed = [0, 0];

  if (path.cp) {
    textPosition = [path.cp[0] + textFixed[0], path.cp[1] + textFixed[1]];
  } else {
    textPosition = geo2pos(geoData, [bbox.left + bbox.width / 2, bbox.top + bbox.height / 2]);
    textPosition[0] += textFixed[0];
    textPosition[1] += textFixed[1];
  }

  path.name = name;
  path.position = position;
  path.textX = textPosition[0];
  path.textY = textPosition[1];
  return path;
};
/**
 * 经纬度转平面坐标
 * @param {Object} p
 */


var geo2pos = function geo2pos(geoData, p) {
  if (!geoData.transform) {
    return null;
  }
  return _projection["default"].geo2pos(geoData.transform, p);
}; //geoJson有的加过密，比如百度图表库的geoJson


var decode = function decode(geoData) {
  if (!geoData.UTF8Encoding) {
    return geoData;
  }

  var features = geoData.features;

  for (var f = 0; f < features.length; f++) {
    var feature = features[f];
    var coordinates = feature.geometry.coordinates;
    var encodeOffsets = feature.geometry.encodeOffsets;

    for (var c = 0; c < coordinates.length; c++) {
      var coordinate = coordinates[c];

      if (feature.geometry.type === 'Polygon') {
        coordinates[c] = decodePolygon(coordinate, encodeOffsets[c]);
      } else if (feature.geometry.type === 'MultiPolygon') {
        for (var c2 = 0; c2 < coordinate.length; c2++) {
          var polygon = coordinate[c2];
          coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2]);
        }
      }
    }
  } // Has been decoded


  geoData.UTF8Encoding = false;
  return geoData;
};

var decodePolygon = function decodePolygon(coordinate, encodeOffsets) {
  var result = [];
  var prevX = encodeOffsets[0];
  var prevY = encodeOffsets[1];

  for (var i = 0; i < coordinate.length; i += 2) {
    var x = coordinate.charCodeAt(i) - 64;
    var y = coordinate.charCodeAt(i + 1) - 64; // ZigZag decoding

    x = x >> 1 ^ -(x & 1);
    y = y >> 1 ^ -(y & 1); // Delta deocding

    x += prevX;
    y += prevY;
    prevX = x;
    prevY = y; // Dequantize

    result.push([x / 1024, y / 1024]);
  }

  return result;
};
});

unwrapExports(trans);

var map$1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);

var _index = interopRequireDefault(graphs);

var _trans = interopRequireDefault(trans);





var _zoom = interopRequireDefault(zoom);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Text = _canvax["default"].Display.Text;
var Path = _canvax["default"].Shapes.Path;
var Rect = _canvax["default"].Shapes.Rect;

var Map = /*#__PURE__*/function (_GraphsBase) {
  (0, _inherits2["default"])(Map, _GraphsBase);

  var _super = _createSuper(Map);

  function Map(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, Map);
    _this = _super.call(this, opt, app);
    _this.type = "map";
    _this.maxValue = 0;
    _this.dataOrg = []; //this.dataFrame.getFieldData( this.field )

    _this.data = []; //layoutData list , default is empty Array

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(Map.defaultProps()), opt);

    if (!_this.node.maxFillStyle) {
      _this.node.maxFillStyle = _this.app.getTheme(0);
    }

    if (_this.node.beginFillStyle && _this.node.endFillStyle) {
      _this._gradientColors = (0, color.gradient)(_this.node.endFillStyle, _this.node.beginFillStyle);
    }

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(Map, [{
    key: "init",
    value: function init() {
      this._pathsp = new _canvax["default"].Display.Sprite({
        id: "nodePathSp"
      });
      this._textsp = new _canvax["default"].Display.Sprite({
        id: "textsp"
      });
      this._marksp = new _canvax["default"].Display.Sprite({
        id: "markSp"
      });
      this.mapGraphs = new _canvax["default"].Display.Sprite({
        id: "mapGraphs"
      });

      this._initInduce();

      this.mapGraphs.addChild(this._pathsp);
      this.mapGraphs.addChild(this._textsp);
      this.mapGraphs.addChild(this._marksp);
      this.sprite.addChild(this.mapGraphs);

      this._initZoom();
    }
  }, {
    key: "_initZoom",
    value: function _initZoom() {
      this.zoom = new _zoom["default"]({
        scale: this.status.transform.scale,
        scaleMin: this.status.transform.statusMin,
        scaleMax: this.status.transform.statusMax
      });
      var me = this;
      var _mosedownIng = false;

      var _preCursor = me.app.canvax.domView ? me.app.canvax.domView.style.cursor : 'default'; //滚轮缩放相关


      var _wheelHandleTimeLen = 32; //16 * 2

      var _wheelHandleTimeer = null;
      var _deltaY = 0;
      this.sprite.on(event.types.get(), function (e) {
        if (me.status.transform.enabled) {
          e.preventDefault();
          var point = e.target.localToGlobal(e.point, me.sprite);

          if (e.type == "mousedown") {
            _mosedownIng = true;
            me.app.canvax.domView && (me.app.canvax.domView.style.cursor = "move");
            me.zoom.mouseMoveTo(point);
          }

          if (e.type == "mouseup" || e.type == "mouseout") {
            _mosedownIng = false;
            me.app.canvax.domView && (me.app.canvax.domView.style.cursor = _preCursor);
          }

          if (e.type == "mousemove") {
            if (_mosedownIng) {
              var _me$zoom$move = me.zoom.move(point),
                  x = _me$zoom$move.x,
                  y = _me$zoom$move.y;

              me.mapGraphs.context.x = x;
              me.mapGraphs.context.y = y;
            }
          }

          if (e.type == "wheel") {
            if (Math.abs(e.deltaY) > Math.abs(_deltaY)) {
              _deltaY = e.deltaY;
            }

            if (!_wheelHandleTimeer) {
              _wheelHandleTimeer = setTimeout(function () {
                var _me$zoom$wheel = me.zoom.wheel(e, point),
                    scale = _me$zoom$wheel.scale,
                    x = _me$zoom$wheel.x,
                    y = _me$zoom$wheel.y;

                me.mapGraphs.context.x = x;
                me.mapGraphs.context.y = y;
                me.mapGraphs.context.scaleX = scale;
                me.mapGraphs.context.scaleY = scale;
                me.status.transform.scale = scale;
                _wheelHandleTimeer = null;
                _deltaY = 0;
              }, _wheelHandleTimeLen);
            }
          }
        }
      });
    }
  }, {
    key: "_initInduce",
    value: function _initInduce() {
      var me = this;
      this._include = new Rect({
        context: {
          x: this.app.padding.left,
          y: this.app.padding.top,
          width: this.width,
          height: this.height,
          fillStyle: "rgba(0,0,0,0)"
        }
      });

      this._include.on(event.types.get(), function (e) {
        e.eventInfo = {
          trigger: me,
          nodes: []
        };
        me.app.fire(e.type, e);
      });

      this.sprite.addChild(this._include);
    }
  }, {
    key: "draw",
    value: function draw(opt) {
      var _this2 = this;

      !opt && (opt = {}); //第二个data参数去掉，直接trimgraphs获取最新的data

      _.extend(true, this, opt);

      var values = this.dataFrame.getFieldData(this.valueField);
      this.maxValue = _.max(values);
      this.minValue = _.min(values);
      this.getGeoData().then(function (geoData) {
        if (geoData) {
          var graphBBox = {
            x: _this2.app.padding.left,
            y: _this2.app.padding.top,
            width: _this2.width,
            height: _this2.height
          };

          _this2._widget(geoData, graphBBox);
        }
      });
      this._include.context.width = this.width;
      this._include.context.height = this.height;
      this.fire("complete");
    }
  }, {
    key: "_widget",
    value: function _widget(geoData, graphBBox) {
      var _this3 = this;

      var elements = [];
      var geoGraphs = (0, _trans["default"])(geoData, graphBBox, this.specialArea);
      geoGraphs.forEach(function (nodeData) {
        var rowData = _this3.dataFrame.getRowDataOf({
          adcode: nodeData[_this3.field]
        });

        if (rowData.length) {
          nodeData.rowData = rowData[0];
        }
        // let fillAlpha   = this._getProp(this.node, "fillAlpha"  , nodeData);
        // let strokeStyle = this._getProp(this.node, "strokeStyle", nodeData);
        // let strokeAlpha = this._getProp(this.node, "strokeAlpha", nodeData);
        // let lineWidth   = this._getProp(this.node, "lineWidth"  , nodeData);
        // let lineType    = this._getProp(this.node, "lineType"   , nodeData);

        var pathCtx = {
          x: graphBBox.x + (graphBBox.width - geoData.transform.width) / 2,
          y: graphBBox.y + (graphBBox.height - geoData.transform.height) / 2,
          path: nodeData.path
        };
        var nodePath = new Path({
          id: 'path_' + nodeData[_this3.field],
          hoverClone: false,
          context: pathCtx
        });
        nodePath.nodeData = nodeData;
        nodePath.geoData = geoData;
        nodeData.nodeElement = nodePath;

        _this3._setNodeStyle(nodePath);

        nodeData.color = nodePath.context.fillStyle;

        _this3.node.drawBegin.bind(_this3)(nodeData);

        _this3._pathsp.addChild(nodePath); // if( geoGraph.name == "浙江省" ){
        //     //test    
        //     let nodePathBox = nodePath.getBound();
        //     let globalPos = nodePath.localToGlobal( nodePathBox );
        //     nodePathBox.x = globalPos.x;
        //     nodePathBox.y = globalPos.y;
        //     this._pathsp.addChild( new Rect({
        //         context: {
        //             ...nodePathBox,
        //             lineWidth:1,
        //             strokeStyle:"red"
        //         }
        //     }) )
        // }


        _this3.node.drawEnd.bind(_this3)(nodeData); //drawEnd中可能把这个node销毁了


        nodePath.context && elements.push(nodePath);
        var me = _this3; //有些区块在外面会告诉你( drawBegin or drawEnd ) 会在geoGraph中标注上告诉你不用监听事件
        //因为有些时候某些比较小的区块，比如深圳 上海，等，周边的区块没数据的时候，如果也检测事件，那么这些小区块会难以选中

        if (nodePath.context && nodePath.context.fillStyle && _this3.node.fillAlpha && !nodeData.pointerEventsNone && nodePath.context) {
          nodePath.context.cursor = 'pointer';
          nodePath.on(event.types.get(), function (e) {
            e.eventInfo = {
              //iNode : this.iNode,
              trigger: me.node,
              nodes: [this.nodeData]
            };

            if (e.type == 'mouseover') {
              me.focusAt(this.nodeData[me.field]);
            }

            if (e.type == 'mouseout') {
              me.unfocusAt(this.nodeData[me.field]);
            }
            me.app.fire(e.type, e);
          });
        }
      });
      return elements;
    }
  }, {
    key: "_setNodeStyle",
    value: function _setNodeStyle(_path, type) {
      var nodeData = _path.nodeData;

      if (_path) {
        var _path$context = _path.context,
            fillStyle = _path$context.fillStyle,
            fillAlpha = _path$context.fillAlpha,
            strokeStyle = _path$context.strokeStyle,
            strokeAlpha = _path$context.strokeAlpha,
            lineWidth = _path$context.lineWidth,
            lineType = _path$context.lineType;
        _path._default = {
          fillStyle: fillStyle,
          fillAlpha: fillAlpha,
          strokeStyle: strokeStyle,
          strokeAlpha: strokeAlpha,
          lineWidth: lineWidth,
          lineType: lineType
        };
        var _propPath = this.node[type];

        if (!type) {
          _propPath = this.node;
        }

        var _fillStyle = this._getProp(_propPath, "fillStyle", nodeData) || fillStyle;

        var _fillAlpha = this._getProp(_propPath, "fillAlpha", nodeData) || fillAlpha;

        var _strokeStyle = this._getProp(_propPath, "strokeStyle", nodeData) || strokeStyle;

        var _strokeAlpha = this._getProp(_propPath, "strokeAlpha", nodeData) || strokeAlpha;

        var _lineWidth = this._getProp(_propPath, "lineWidth", nodeData) || lineWidth;

        var _lineType = this._getProp(_propPath, "lineType", nodeData) || lineType;

        _path.context.fillStyle = _fillStyle;
        _path.context.fillAlpha = _fillAlpha;
        _path.context.strokeStyle = _strokeStyle;
        _path.context.strokeAlpha = _strokeAlpha;
        _path.context.lineWidth = _lineWidth;
        _path.context.lineType = _lineType;
      }
    }
  }, {
    key: "focusAt",
    value: function focusAt(adcode) {
      if (!this.node.focus.enabled) return;

      var _path = this._pathsp.getChildById('path_' + adcode);

      var nodeData = _path.nodeData;

      if (!nodeData.selected) {
        //已经选中的不能换成focus状态，_selected权重最高
        this._setNodeStyle(_path, 'focus');

        nodeData.focused = true;
      }
    }
  }, {
    key: "unfocusAt",
    value: function unfocusAt(adcode) {
      if (!this.node.focus.enabled) return;

      var _path = this._pathsp.getChildById('path_' + adcode);

      var nodeData = _path.nodeData;

      if (!nodeData.selected) {
        //已经选中的不能换成focus状态，_selected权重最高
        this._setNodeStyle(_path);

        nodeData.focused = false;
      }
    }
  }, {
    key: "selectAt",
    value: function selectAt(adcode) {
      if (!this.node.select.enabled) return;

      var _path = this._pathsp.getChildById('path_' + adcode);

      var nodeData = _path.nodeData;

      this._setNodeStyle(_path, 'select');

      nodeData.selected = true;
    }
  }, {
    key: "unselectAt",
    value: function unselectAt(adcode) {
      if (!this.node.select.enabled) return;

      var _path = this._pathsp.getChildById('path_' + adcode);

      var geoGraph = _path.nodeData;

      this._setNodeStyle(_path);

      geoGraph.selected = false;

      if (geoGraph.focused) {
        this.focusAt(adcode);
      }
    }
  }, {
    key: "drawChildren",
    value: function drawChildren(adcode) {
      var _this4 = this;

      return new Promise(function (resolve) {
        _this4.getGeoData({
          mapAdcode: adcode
        }).then(function (geoData) {
          if (geoData) {
            var _path = _this4._pathsp.getChildById('path_' + adcode);

            var pathBBox = _path.getBound();

            var globalPos = _path.localToGlobal(pathBBox);

            pathBBox.x = globalPos.x;
            pathBBox.y = globalPos.y;
            resolve(_this4._widget(geoData, pathBBox));
          }
        });
      });
    }
  }, {
    key: "getGeoData",
    value: function getGeoData() {
      var _this5 = this;

      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
      return new Promise(function (resolve, reject) {
        if (opt.mapAdcode !== null || opt.geoJsonUrl) {
          var url = opt.geoJsonUrl || _this5.adcodeUrlTempl.replace(new RegExp('\\{adcode\\}', 'gm'), opt.mapAdcode);

          if (!_this5.app.__geoDataMap) _this5.app.__geoDataMap = {};

          if (_this5.app.__geoDataMap[url]) {
            resolve(_this5.app.__geoDataMap[url]);
          } else {
            fetch(url).then(function (data) {
              if (data.ok) {
                data.json().then(function (d) {
                  var _d = _this5.geoJsonFilter(d);

                  _this5.app.__geoDataMap[url] = {
                    json: _d || d
                  };
                  resolve(_this5.app.__geoDataMap[url]);
                });
              } else {
                resolve(null);
              }
            })["catch"](function (error) {
              reject(error);
            });
          }
        } else if (opt.geoJson) {
          resolve({
            json: opt.geoJson
          });
        }
      });
    }
  }, {
    key: "_getProp",
    value: function _getProp(propPath, type, nodeData) {
      var configValue = propPath[type];
      var value;

      if (_.isFunction(configValue)) {
        value = configValue.apply(this, [nodeData, this.dataFrame]);
      } else {
        value = configValue;
      }

      if (type == "fillStyle") {
        var rowData = nodeData.rowData;

        if (rowData) {
          if (rowData[type] !== undefined) {
            value = rowData[type];
          } else {
            var val = rowData[this.valueField];

            if (!isNaN(val) && val != '') {
              //let alpha = ((val - this.minValue) / (this.maxValue - this.minValue)) * (this.node.fillAlpha - this.node.minFillAlpha) + this.node.minFillAlpha;
              var alpha = this.node.minFillAlpha + (this.node.fillAlpha - this.node.minFillAlpha) / (this.maxValue - this.minValue) * (val - this.minValue); //console.log( alpha );

              if (this._gradientColors) {
                return this._gradientColors[100 - parseInt(alpha * 100)];
              } else {
                value = (0, color.colorRgba)(this.node.maxFillStyle, parseFloat(alpha.toFixed(2)));
                value = (0, color.rgba2rgb)(value);
              }
            }
          }
        }
      }

      return value;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: '数据中的adcode字段',
          "default": 'adcode',
          documentation: '数据中的adcode字段，用来对应上地图中的某个区块的adcode，从而找到这个区块对应的这一条数据'
        },
        valueField: {
          detail: '数据中的值字段',
          "default": 'value',
          documentation: '作为field字段的补充，通过field字段找到数据后，用来从数据中取值'
        },
        mapAdcode: {
          detail: '当前绘制的地图adcode',
          "default": null
        },
        adcodeUrlTempl: {
          detail: 'adcode的url模板',
          "default": '//geo.datav.aliyun.com/areas_v2/bound/{adcode}_full.json',
          //http://datav.aliyun.com/tools/atlas/#&lat=43.29320031385282&lng=104.32617187499999&zoom=4
          documentation: '如果是是配置的adcode，那么和他对应的url模板'
        },
        geoJson: {
          detail: '要绘制的geoJson数据',
          "default": null
        },
        geoJsonUrl: {
          detail: '要绘制的geoJson的url',
          "default": null
        },
        geoJsonFilter: {
          detail: 'geoJson的二次过滤处理',
          "default": function _default(json) {
            return json;
          }
        },
        specialArea: {
          detail: '要排除掉不绘制的数据集合，可以是adcode，也可以是name',
          "default": []
        },
        node: {
          detail: '单个元素图形配置',
          propertys: {
            drawBegin: {
              detail: '开始绘制的钩子函数',
              "default": function _default() {}
            },
            drawEnd: {
              detail: '开始绘制的钩子函数',
              "default": function _default() {}
            },
            fillStyle: {
              detail: '单个区块背景色',
              "default": null //'#fff' //从themeColor获取默认 , 默认为空就会没有颜色的区块不会有事件点击

            },
            fillAlpha: {
              detail: '单个区块透明度',
              "default": 1
            },
            maxFillStyle: {
              detail: '单个区块数据最大对应的颜色',
              "default": null
            },
            maxFillAlpha: {
              detail: '单个区块最大透明度',
              "default": 1
            },
            minFillAlpha: {
              detail: '单个区块最小透明度',
              "default": 0.4
            },
            beginFillStyle: {
              detail: '区域颜色的起始色',
              documentation: '设置区域颜色的另外一个方案，两个颜色确定一个区间的结束色',
              "default": null
            },
            endFillStyle: {
              detail: '区域颜色的结束色',
              documentation: '设置区域颜色的另外一个方案，两个颜色确定一个区间的结束色',
              "default": null
            },
            strokeStyle: {
              detail: '单个区块描边颜色',
              "default": "#ccc"
            },
            strokeAlpha: {
              detail: '单个区块描边透明度',
              "default": 1
            },
            lineWidth: {
              detail: '单个区块描边线宽',
              "default": 1
            },
            lineType: {
              detail: '区块描边样式',
              "default": 'solid'
            },
            focus: {
              detail: "单个区块hover态设置",
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": true
                },
                fillStyle: {
                  detail: 'hover态单个区块背景色',
                  "default": null //从themeColor获取默认

                },
                fillAlpha: {
                  detail: 'hover态单个区块透明度',
                  "default": 1
                },
                strokeStyle: {
                  detail: 'hover态单个区块描边颜色',
                  "default": null //默认获取themeColor

                },
                strokeAlpha: {
                  detail: 'hover态单个区块描边透明度',
                  "default": 1 //默认获取themeColor

                },
                lineWidth: {
                  detail: 'hover态单个区块描边线宽',
                  "default": 1
                },
                lineType: {
                  detail: 'hover态区块描边样式',
                  "default": null
                }
              }
            },
            select: {
              detail: "单个区块选中态设置",
              propertys: {
                enabled: {
                  detail: '是否开启',
                  "default": false
                },
                fillStyle: {
                  detail: '选中态单个区块背景色',
                  "default": null //从themeColor获取默认

                },
                fillAlpha: {
                  detail: '选中态单个区块透明度',
                  "default": 1
                },
                strokeStyle: {
                  detail: '选中态单个区块描边颜色',
                  "default": null
                },
                strokeAlpha: {
                  detail: '选中态单个区块描边颜色',
                  "default": 1
                },
                lineWidth: {
                  detail: '选中态单个区块描边线宽',
                  "default": 1
                },
                lineType: {
                  detail: '选中态区块描边样式',
                  "default": null
                }
              }
            }
          }
        },
        label: {
          detail: '文本配置',
          propertys: {
            enabled: {
              detail: '是否开启文本',
              "default": true
            },
            textAlign: {
              detail: '文本布局位置(left,center,right)',
              "default": 'center'
            },
            textBaseline: {
              detail: '文本基线对齐方式',
              "default": 'middle'
            },
            format: {
              detail: '文本格式化处理函数',
              "default": null
            },
            fontSize: {
              detail: '文本字体大小',
              "default": 12
            },
            fontColor: {
              detail: '文本颜色',
              "default": '#666',
              documentation: 'align为center的时候的颜色，align为其他属性时候取node的颜色'
            }
          }
        },
        status: {
          detail: '一些开关配置',
          propertys: {
            transform: {
              detail: "是否启动拖拽缩放整个画布",
              propertys: {
                fitView: {
                  detail: "自动缩放",
                  "default": '' //autoZoom

                },
                enabled: {
                  detail: "是否开启",
                  "default": true
                },
                scale: {
                  detail: "缩放值",
                  "default": 1
                },
                scaleMin: {
                  detail: "缩放最小值",
                  "default": 1
                },
                scaleMax: {
                  detail: "缩放最大值",
                  "default": 10
                },
                scaleOrigin: {
                  detail: "缩放原点",
                  "default": {
                    x: 0,
                    y: 0
                  }
                }
              }
            }
          }
        }
      };
    }
  }]);
  return Map;
}(_index["default"]);

_index["default"].registerComponent(Map, 'graphs', 'map');

var _default2 = Map;
exports["default"] = _default2;
});

unwrapExports(map$1);

var legend = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);

var _trigger = interopRequireDefault(trigger);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Circle = _canvax["default"].Shapes.Circle;
var Rect = _canvax["default"].Shapes.Rect;

var Legend = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(Legend, _Component);

  var _super = _createSuper(Legend);

  function Legend(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, Legend);
    _this = _super.call(this, opt, app);
    _this.name = "legend";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(Legend.defaultProps()), opt);
    /* data的数据结构为
    [
        //descartes中用到的时候还会带入yAxis
        {name: "uv", color: "#ff8533", field: '' ...如果手动传入数据只需要前面这三个 enabled: true, ind: 0, } //外部只需要传field和fillStyle就行了 activate是内部状态
    ]
    */


    _this.data = _this._getLegendData(opt); //this.position = "top" ; //图例所在的方向top,right,bottom,left
    //this.direction = "h"; //横向 top,bottom --> h left,right -- >v

    if (!opt.direction && opt.position) {
      if (_this.position == "left" || _this.position == "right") {
        _this.direction = 'v';
      } else {
        _this.direction = 'h';
      }
    }
    _this.sprite = new _canvax["default"].Display.Sprite({
      id: "LegendSprite",
      context: {
        x: _this.pos.x,
        y: _this.pos.y
      }
    });

    _this.app.stage.addChild(_this.sprite);

    _this.widget(); //图例是需要自己绘制完成后，才能拿到高宽来设置自己的位置


    _this.layout();

    return _this;
  }

  (0, _createClass2["default"])(Legend, [{
    key: "_getLegendData",
    value: function _getLegendData(opt) {
      var legendData = opt.data;

      if (legendData) {
        _.each(legendData, function (item, i) {
          item.enabled = true;
          item.ind = i;
        }); //delete opt.data;

      } else {
        legendData = this.app.getLegendData();
      }
      return legendData || [];
    }
  }, {
    key: "layout",
    value: function layout() {
      var app = this.app;
      var width = this.width + this.margin.left + this.margin.right;
      var height = this.height + this.margin.top + this.margin.bottom;
      var x = app.padding.left;
      var y = app.padding.top;

      if (this.position == "right") {
        x = app.width - app.padding.right - width;
      }

      if (this.position == "bottom") {
        y = app.height - app.padding.bottom - height + this.icon.height / 2; //TODO:这样的设置到了中线了
      }
      var layoutWidth, layoutHeight; //然后把app的padding扩展开来

      if (this.position == "left" || this.position == "right") {
        // v
        app.padding[this.position] += width;
        layoutWidth = width;
        layoutHeight = app.height - app.padding.top - app.padding.bottom;
      } else if (this.position == "top" || this.position == "bottom") {
        // h
        app.padding[this.position] += height;
        layoutWidth = app.width - app.padding.right - app.padding.left;
        layoutHeight = height;
      }

      if (this.textAlign == 'center') {
        x += layoutWidth / 2 - this.width / 2;
      }

      if (this.textAlign == 'right') {
        x += layoutWidth - this.width;
      }
      this.pos = {
        x: x,
        y: y
      };
      return this.pos;
    }
  }, {
    key: "draw",
    value: function draw() {
      //为了在直角坐标系中，让 textAlign left的时候，图例和坐标系左侧对齐， 好看点, 用心良苦啊
      var _coord = this.app.getComponent({
        name: 'coord'
      });

      if (_coord && _coord.type == 'rect') {
        if (this.textAlign == "left" && (this.position == "top" || this.position == "bottom")) {
          this.pos.x = _coord.getSizeAndOrigin().origin.x + this.icon.radius;
        }
      }
      this.setPosition();
    }
  }, {
    key: "widget",
    value: function widget() {
      var me = this;
      var viewWidth = this.app.width - this.app.padding.left - this.app.padding.right;
      var viewHeight = this.app.height - this.app.padding.top - this.app.padding.bottom;
      var maxItemWidth = 0;
      var width = 0,
          height = 0;
      var x = 0,
          y = 0;
      var rows = 1;
      var isOver = false; //如果legend过多

      _.each(this.data, function (obj, i) {
        if (isOver) return;

        var _icon = me._getIconNodeEl(obj, i);

        _icon.on(event.types.get(), function (e) {//... 代理到sprit上面处理
        });

        var _text = obj.name;

        if (me.label.format) {
          _text = me.label.format(obj.name, obj);
        }
        var txt = new _canvax["default"].Display.Text(_text, {
          id: "legend_field_txt_" + i,
          context: {
            x: me.icon.radius + 3,
            y: me.icon.height / 3,
            textAlign: me.label.textAlign,
            //"left",
            textBaseline: me.label.textBaseline,
            //"middle",
            fillStyle: me.label.fontColor,
            //"#333", //obj.color
            cursor: me.label.cursor //"pointer"

          }
        });
        txt.on(event.types.get(), function (e) {//... 代理到sprit上面处理
        });
        var txtW = txt.getTextWidth();
        var itemW = txtW + me.icon.radius * 2 + 20;
        maxItemWidth = Math.max(maxItemWidth, itemW);
        var spItemC = {
          height: me.icon.height
        };

        if (me.direction == "v") {
          if (y + me.icon.height > viewHeight) {
            if (x > viewWidth * 0.3) {
              isOver = true;
              return;
            }
            x += maxItemWidth;
            y = 0;
          }
          spItemC.x = x;
          spItemC.y = y;
          y += me.icon.height;
          height = Math.max(height, y);
        } else {
          //横向排布
          if (x + itemW > viewWidth) {
            if (me.icon.height * (rows + 1) > viewHeight * 0.3) {
              isOver = true;
              return;
            }
            x = 0;
            rows++;
          }
          spItemC.x = x;
          spItemC.y = me.icon.height * (rows - 1);
          x += itemW;
          width = Math.max(width, x);
        }
        var sprite = new _canvax["default"].Display.Sprite({
          id: "legend_field_" + i,
          context: spItemC
        });
        sprite.addChild(_icon);
        sprite.addChild(txt);
        sprite.context.width = itemW;
        me.sprite.addChild(sprite);
        sprite.on(event.types.get(), function (e) {
          if (me.triggerEventType.indexOf(e.type) > -1 && me.activeEnabled) {
            //只有一个field的时候，不支持取消
            if (_.filter(me.data, function (obj) {
              return obj.enabled;
            }).length == 1) {
              if (obj.enabled) {
                return;
              }
            }
            obj.enabled = !obj.enabled;
            _icon.context.fillStyle = !obj.enabled ? "#ccc" : obj.color || "#999";

            if (obj.enabled) {
              me.app.show(obj.field, new _trigger["default"](this, obj));
            } else {
              me.app.hide(obj.field, new _trigger["default"](this, obj));
            }
          }

          if (me.tipsEnabled) {
            if (e.type == 'mouseover' || e.type == 'mousemove') {
              e.eventInfo = me._getInfoHandler(e, obj);
            }

            if (e.type == 'mouseout') {
              delete e.eventInfo;
            }
            me.app.fire(e.type, e);
          }
        });
      });

      if (this.direction == "h") {
        me.width = me.sprite.context.width = width;
        me.height = me.sprite.context.height = me.icon.height * rows;
      } else {
        me.width = me.sprite.context.width = x + maxItemWidth;
        me.height = me.sprite.context.height = height;
      } //me.width = me.sprite.context.width  = width;
      //me.height = me.sprite.context.height = height;

    }
  }, {
    key: "_getIconNodeEl",
    value: function _getIconNodeEl(obj, i) {
      var fillStyle = !obj.enabled ? "#ccc" : obj.color || "#999";

      if (this.icon.fillStyle) {
        var _fillStyle = this._getProp(this.icon.fillStyle, obj);

        if (_fillStyle) {
          fillStyle = _fillStyle;
        }
      }
      var el;

      if (obj.type == 'line') {
        el = new Rect({
          id: "legend_field_icon_" + i,
          context: {
            x: -this.icon.radius,
            y: this.icon.height / 3 - 1,
            fillStyle: fillStyle,
            width: this.icon.radius * 2,
            height: 2,
            cursor: "pointer"
          }
        });
      } else if (obj.type == 'bar') {
        el = new Rect({
          id: "legend_field_icon_" + i,
          context: {
            x: -this.icon.radius,
            y: this.icon.height / 3 - this.icon.radius,
            fillStyle: fillStyle,
            width: this.icon.radius * 2,
            height: this.icon.radius * 2,
            radius: [3, 3, 3, 3],
            cursor: "pointer"
          }
        });
      } else {
        el = new Circle({
          id: "legend_field_icon_" + i,
          context: {
            x: 0,
            y: this.icon.height / 3,
            fillStyle: fillStyle,
            r: this.icon.radius,
            cursor: "pointer"
          }
        });
      }
      return el;
    }
  }, {
    key: "_getInfoHandler",
    value: function _getInfoHandler(e, data) {
      return {
        type: "legend",
        triggerType: 'legend',
        trigger: 'this',
        //this,
        tipsEnabled: this.tipsEnabled,
        nodes: [{
          name: data.name,
          fillStyle: data.color
        }]
      };
    }
  }, {
    key: "_getProp",
    value: function _getProp(prop, nodeData) {
      var _prop = prop;

      if (_.isArray(prop)) {
        _prop = prop[nodeData.ind];
      }

      if (_.isFunction(prop)) {
        _prop = prop.apply(this, [nodeData]);
      }
      return _prop;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        data: {
          detail: '图例数据',
          "default": [],
          documentation: '\
                    数据结构为：{name: "uv", color: "#ff8533", field: "" ...}\
                    如果手动传入数据只需要前面这三个 enabled: true, ind: 0\
                    外部只需要传field和fillStyle就行了\
                    '
        },
        position: {
          detail: '图例位置',
          documentation: '图例所在的方向top,right,bottom,left',
          "default": 'top'
        },
        direction: {
          detail: '图例布局方向',
          "default": 'h',
          documentation: '横向 top,bottom --> h left,right -- >v'
        },
        textAlign: {
          detail: '水平方向的对其，默认居左对其',
          "default": 'left',
          documentation: '可选left，center，right'
        },
        verticalAlign: {
          detail: '垂直方向的对其方式，默认居中（待实现）',
          "default": 'middle',
          documentation: '可选top，middle，bottom'
        },
        icon: {
          detail: '图标设置',
          propertys: {
            height: {
              detail: '高',
              "default": 26
            },
            width: {
              detail: '图标宽',
              "default": 'auto'
            },
            shapeType: {
              detail: '图标的图形类型，目前只实现了圆形',
              "default": 'circle'
            },
            radius: {
              detail: '图标（circle）半径',
              "default": 5
            },
            lineWidth: {
              detail: '图标描边宽度',
              "default": 1
            },
            fillStyle: {
              detail: '图标颜色，一般会从data里面取，这里是默认色',
              "default": null
            }
          }
        },
        label: {
          detail: '文本配置',
          propertys: {
            textAlign: {
              detail: '水平对齐方式',
              "default": 'left'
            },
            textBaseline: {
              detail: '文本基线对齐方式',
              "default": 'middle'
            },
            fontColor: {
              detail: '文本颜色',
              "default": '#333333'
            },
            cursor: {
              detail: '鼠标样式',
              "default": 'pointer'
            },
            format: {
              detail: '文本格式化处理函数',
              "default": null
            }
          }
        },
        triggerEventType: {
          detail: '触发事件',
          "default": 'click,tap'
        },
        activeEnabled: {
          detail: '是否启动图例的交互事件',
          "default": true
        },
        tipsEnabled: {
          detail: '是否开启图例的tips',
          "default": false
        }
      };
    }
  }]);
  return Legend;
}(_component["default"]);

_component["default"].registerComponent(Legend, 'legend');

var _default = Legend;
exports["default"] = _default;
});

unwrapExports(legend);

var datazoom = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = interopRequireDefault(toConsumableArray$1);

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);

var _trigger = interopRequireDefault(trigger);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._;
var Line = _canvax["default"].Shapes.Line;
var Rect = _canvax["default"].Shapes.Rect;
var Polygon = _canvax["default"].Shapes.Polygon;

var dataZoom = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(dataZoom, _Component);

  var _super = _createSuper(dataZoom);

  function dataZoom(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, dataZoom);
    _this = _super.call(this, opt, app);
    _this.name = "dataZoom";
    _this._cloneChart = null;
    _this.count = 1; //把w 均为为多少个区间， 同样多节点的line 和  bar， 这个count相差一

    _this.dataLen = 1; //总共有多少条数据 

    _this.axisLayoutType = null;

    _this.dragIng = function () {};

    _this.dragEnd = function () {};

    _this.disPart = {};
    _this._preRange = null;
    _this._btnLeft = null;
    _this._btnRight = null;
    _this._underline = null;
    _this.sprite = new _canvax["default"].Display.Sprite({
      id: "dataZoom",
      context: {
        x: _this.pos.x,
        y: _this.pos.y
      }
    });
    _this.sprite.noSkip = true;
    _this.dataZoomBg = new _canvax["default"].Display.Sprite({
      id: "dataZoomBg"
    });
    _this.dataZoomBtns = new _canvax["default"].Display.Sprite({
      id: "dataZoomBtns"
    });

    _this.sprite.addChild(_this.dataZoomBg);

    _this.sprite.addChild(_this.dataZoomBtns);

    app.stage.addChild(_this.sprite); //如果组件是布局在左右两侧位置的话，说明组件是竖立的，那么要把用户设置的width和height对调

    if (opt.position == 'left' || opt.position == 'right') {
      var _width = opt.width;
      var _height = opt.height;
      opt.height = _width;
      opt.width = _height;
      if (opt.width === undefined) delete opt.width;
      if (opt.height === undefined) delete opt.height;
    }

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(dataZoom.defaultProps()), opt);

    if (!("margin" in opt)) {
      if (_this.position == 'bottom') {
        _this.margin.top = 10;
      }

      if (_this.position == 'top') {
        _this.margin.bottom = 10;
      }
    }

    _this.axis = null; //对应哪个轴

    _this.layout();

    return _this;
  } //datazoom begin


  (0, _createClass2["default"])(dataZoom, [{
    key: "layout",
    value: function layout() {
      var app = this.app;

      if (this.position == "bottom") {
        //目前dataZoom是固定在bottom位置的
        //_getDataZoomOpt中会矫正x
        this.pos.y = app.height - (this.height + app.padding.bottom + this.margin.bottom);
        app.padding.bottom += this.height + this.margin.top + this.margin.bottom;
      }

      if (this.position == "top") {
        this.pos.y = app.padding.top + this.margin.top;
        app.padding.top += this.height + this.margin.top + this.margin.bottom;
      }

      if (this.position == "left") {
        this.pos.x = -((this.width - this.height) / 2) + app.padding.left + this.margin.left;
        this.pos.y = app.height - app.padding.bottom - this.margin.bottom - this.width / 2 - this.height / 2; //因为是把组件 旋转了 90du，所以这个的width 要用height

        app.padding.left += this.height + this.margin.left + this.margin.right;
      }

      if (this.position == "right") {
        this.pos.x = -((this.width - this.height) / 2) + app.padding.left + this.margin.left;
        this.pos.y = app.height - app.padding.bottom - this.margin.bottom - this.width / 2 - this.height / 2; //因为是把组件 旋转了 90du，所以这个的width 要用height

        app.padding.right += this.height + this.margin.left + this.margin.right;
      }
    }
  }, {
    key: "_getCloneChart",
    value: function _getCloneChart() {
      var me = this;
      var app = this.app;

      var _coord = app.getCoord();

      var chartConstructor = app.constructor; //(barConstructor || Bar);

      var cloneEl = app.el.cloneNode();
      cloneEl.innerHTML = "";
      cloneEl.id = app.el.id + "_currclone";
      cloneEl.style.position = "absolute";
      cloneEl.style.width = this.width + "px";
      cloneEl.style.height = this.btnHeight + "px"; //app.el.offsetHeight + "px";

      cloneEl.style.top = "-10000px";
      document.body.appendChild(cloneEl); //let opt = _.extend(true, {}, me._opt);
      //_.extend(true, opt, me.getCloneChart() );
      //clone的chart只需要coord 和 graphs 配置就可以了
      //因为画出来后也只需要拿graphs得sprite去贴图

      var graphsOpt = [];

      _.each(app.getComponents({
        name: 'graphs'
      }), function (_g) {
        var _field = _g.enabledField || _g.field;

        if (_.flatten([_field]).length) {
          var _opt = _.extend(true, {}, _g._opt);

          _opt.field = _field;
          var miniOpt = {};

          if (_g.type == "bar") {
            miniOpt = {
              node: {//fillStyle: "#ececec"
              }
            };

            if (me.graphStyle) {
              miniOpt.node.fillStyle = me.graphStyle;
            }
          }

          if (_g.type == "line") {
            miniOpt = {
              line: {
                lineWidth: 1 //strokeStyle: "#ececec"

              },
              node: {
                enabled: false
              },
              area: {//fillStyle: "#ececec"
              }
            };

            if (me.graphStyle) {
              miniOpt.line.strokeStyle = me.graphStyle;
              miniOpt.area.fillStyle = me.graphStyle;
            }
          }

          var _h = _coord.height || app.el.offsetHeight;

          var radiusScale = me.btnHeight / _h || 1;

          if (_g.type == "scat") {
            miniOpt = {
              node: {
                //fillStyle : "#ececec",
                radiusScale: radiusScale
              }
            };

            if (me.graphStyle) ;
          }
          graphsOpt.push(_.extend(true, _opt, miniOpt, {
            label: {
              enabled: false
            },
            animation: false
          }));
        }
      });

      var opt = {
        coord: Object.assign({}, app._opt.coord),
        graphs: graphsOpt
      };

      if (opt.coord.horizontal) {
        delete opt.coord.horizontal;
      }
      opt.coord.enabled = false;
      opt.coord.padding = 0;
      var thumbChart = new chartConstructor(cloneEl, app._data, opt, app.componentModules, app.otherOptions);
      thumbChart.draw();
      return {
        thumbChart: thumbChart,
        cloneEl: cloneEl
      };
    }
  }, {
    key: "_setDataZoomOpt",
    value: function _setDataZoomOpt() {
      var app = this.app;
      var coordSize = app.getComponent({
        name: 'coord'
      }).getSizeAndOrigin();
      var me = this;
      var defaultWidth = coordSize.width;

      if (this.position == 'left' || this.position == 'right') {
        defaultWidth = coordSize.height || 150;
      }

      _.extend(true, this, {
        width: this.width || parseInt(defaultWidth),
        pos: {
          x: this.pos.x || coordSize.origin.x
        },
        dragIng: function dragIng(range) {
          var trigger;

          if (me.axisLayoutType == 'proportion') {
            trigger = new _trigger["default"](me, {
              min: range.start,
              max: range.end
            });

            app.dataFrame.filters['datazoom' + me.__cid] = function (rowData) {
              //如果有用户自定义的
              if (me.dragIngDataFilter) {
                return me.dragIngDataFilter.apply(me, [rowData, range]);
              }

              var field = Array.isArray(me.axis.field) ? me.axis.field[0] : me.axis.field;
              var val = rowData[field];
              var min = Math.min.apply(Math, (0, _toConsumableArray2["default"])(me.axis.dataSection));
              var max = Math.max.apply(Math, (0, _toConsumableArray2["default"])(me.axis.dataSection));
              var width = me.width;
              var startVal = min + (max - min) * (range.start / width);
              var endVal = min + (max - min) * (range.end / width);
              return val >= startVal && val <= endVal;
            };
          } else {
            trigger = new _trigger["default"](me, {
              left: app.dataFrame.range.start - range.start,
              right: range.end - app.dataFrame.range.end
            });

            _.extend(app.dataFrame.range, range);
          }

          app.resetData(null, trigger);
          app.fire("dataZoomDragIng");
        },
        dragEnd: function dragEnd() {
          app.updateChecked && app.updateChecked();
          app.fire("dataZoomDragEnd");
        }
      });
    } //datazoom end

  }, {
    key: "draw",
    value: function draw() {
      //设置一些opt，需要用到 coord 坐标系的一些size数据，只有draw的时候才有
      this._setDataZoomOpt();

      this._cloneChart = this._getCloneChart();

      var _coord = this._cloneChart.thumbChart.getComponent({
        name: 'coord'
      });

      var _xAxis = _coord._xAxis;
      this.axis = _xAxis;

      if (this.position == 'left') {
        this.axis = _coord._yAxisLeft;
      }

      if (this.position == 'right') {
        this.axis = _coord._yAxisRight;
      }
      this.axisLayoutType = this.axis.layoutType; //和line bar等得xAxis.layoutType 一一对应

      this._computeAttrs(); //这个组件可以在init的时候就绘制好


      this.widget();

      this._setLines(); //统一的也只有rect的选择区域， 才需要复制一份图形，作为datazoom的minimap


      this.setMiniGroupsMap();
      this.setPosition(); //如果是left right 两侧的话， 需要做下旋转

      if (this.position == 'left' || this.position == 'right') {
        var xAxisHeight = this.app.getComponent({
          name: 'coord'
        })._xAxis.height;

        this.sprite.context.rotation = -90;
        this.sprite.context.rotateOrigin = {
          x: this.width / 2,
          y: this.height / 2
        };
        this.sprite.context.y -= xAxisHeight;

        if (!this._opt.width) {
          this.sprite.context.y -= this.width / 2;
          this.sprite.context.x -= this.width / 2;
        }
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.sprite.destroy();
    }
  }, {
    key: "reset",
    value: function reset(opt) {
      !opt && (opt = {});
      var _preCount = this.count;
      var _preStart = this.range.start;
      var _preEnd = this.range.end;
      opt && _.extend(true, this, opt);
      this._cloneChart = this._getCloneChart(); //cloneChart;

      this._computeAttrs(opt);

      if (_preCount != this.count || opt.range && (opt.range.start != _preStart || opt.range.end != _preEnd)) {
        this.widget();

        this._setLines();
      }
      this.setMiniGroupsMap();
    } //计算属性

  }, {
    key: "_computeAttrs",
    value: function _computeAttrs() {
      var _cloneChart = this._cloneChart.thumbChart;
      this.dataLen = _cloneChart.dataFrame.length;

      switch (this.axisLayoutType) {
        case "rule":
          this.count = this.dataLen - 1;
          break;

        case "peak":
          this.count = this.dataLen;
          break;

        case "proportion":
          this.count = this.width;
          break;
      }

      if (!this._opt.range || this._opt.range && !this._opt.range.max || this.range.max > this.count) {
        this.range.max = this.count - 1;
      }

      if (!this._opt.range || this._opt.range && !this._opt.range.end || this.range.end > this.dataLen - 1) {
        this.range.end = this.dataLen - 1;

        if (this.axisLayoutType == "proportion") {
          this.range.end = this.count - 1;
        }
      }

      this.disPart = this._getDisPart();
      this.btnHeight = this.height - this.btnOut;
    }
  }, {
    key: "_getDisPart",
    value: function _getDisPart() {
      var me = this;
      var min = Math.max(parseInt(me.range.min / 2 / me.count * me.width), 23);
      var max = parseInt((me.range.max + 1) / me.count * me.width); //柱状图用得这种x轴布局，不需要 /2

      if (this.axisLayoutType == "peak") {
        min = Math.max(parseInt(me.range.min / me.count * me.width), 23);
      }

      if (this.axisLayoutType == "proportion") {
        //min = min;
        max = me.width;
      }
      return {
        min: min,
        max: max
      };
    }
  }, {
    key: "_getRangeEnd",
    value: function _getRangeEnd(end) {
      if (end === undefined) {
        end = this.range.end;
      }

      if (this.axisLayoutType == "peak") {
        end += 1;
      }

      if (this.axisLayoutType == "proportion") {
        end += 1;
      }

      return end;
    }
  }, {
    key: "widget",
    value: function widget() {
      var me = this;

      var setLines = function setLines() {
        me._setLines.apply(me, arguments);
      };

      if (me.bg.enabled) {
        var bgFillStyle = me.bg.fillStyle;

        if (bgFillStyle && bgFillStyle.lineargradient && bgFillStyle.lineargradient.length) {
          var _style = me.ctx.createLinearGradient(0, me.btnHeight, me.width, me.btnHeight);

          _.each(bgFillStyle.lineargradient, function (item) {
            _style.addColorStop(item.position, item.color);
          });

          bgFillStyle = _style;
        }

        if (!bgFillStyle && me.shapeType == 'triangle') {
          bgFillStyle = '#e6e6e6';
        }
        var bgRectCtx = {
          x: 0,
          y: 0,
          width: me.width,
          height: me.btnHeight,
          lineWidth: me.bg.lineWidth,
          strokeStyle: me.bg.strokeStyle,
          fillStyle: bgFillStyle,
          fillAlpha: me.bg.glpha
        };
        var _bgTriangleCtx = {
          x: 0,
          y: 0,
          pointList: [[0, me.btnHeight], [me.width, me.btnHeight], [me.width, 0]],
          lineWidth: me.bg.lineWidth,
          strokeStyle: me.bg.strokeStyle,
          fillStyle: bgFillStyle,
          globalAlpha: me.bg.glpha
        };

        if (me._bgElement) {
          me._bgElement.animate(bgRectCtx, {
            onUpdate: setLines
          });
        } else {
          if (me.shapeType == 'rect') {
            me._bgElement = new Rect({
              context: bgRectCtx
            });
          } else {
            me._bgElement = new Polygon({
              context: _bgTriangleCtx
            });
          }
          me.dataZoomBg.addChild(me._bgElement);
        }
      }

      if (me.underline.enabled) {
        var underlineCtx = {
          start: {
            x: me.range.start / me.count * me.width + me.btnWidth / 2,
            y: me.btnHeight
          },
          end: {
            x: me._getRangeEnd() / me.count * me.width - me.btnWidth / 2,
            y: me.btnHeight
          },
          lineWidth: me.underline.lineWidth,
          strokeStyle: me.underline.strokeStyle || me.color
        };

        if (me._underline) {
          me._underline.animate(underlineCtx, {
            onUpdate: setLines
          });
        } else {
          me._underline = me._addLine(underlineCtx);
          me.dataZoomBg.addChild(me._underline);
        }
      }

      var btnLeftCtx = {
        x: me.range.start / me.count * me.width,
        y: -me.btnOut / 2 + 1,
        width: me.btnWidth,
        height: me.btnHeight + me.btnOut,
        fillStyle: me.left.fillStyle || me.color,
        cursor: me.left.eventEnabled && "move"
      };

      if (me._btnLeft) {
        me._btnLeft.animate(btnLeftCtx, {
          onUpdate: setLines
        });
      } else {
        me._btnLeft = new Rect({
          id: 'btnLeft',
          dragEnabled: me.left.eventEnabled,
          hoverClone: false,
          context: btnLeftCtx
        });

        me._btnLeft.on("draging", function () {
          this.context.y = -me.btnOut / 2 + 1;

          if (this.context.x < 0) {
            this.context.x = 0;
          }

          if (this.context.x > me._btnRight.context.x - me.btnWidth) {
            this.context.x = me._btnRight.context.x - me.btnWidth;
          }

          if (me._btnRight.context.x + me.btnWidth - this.context.x > me.disPart.max) {
            this.context.x = me._btnRight.context.x + me.btnWidth - me.disPart.max - 1;
          }

          if (me._btnRight.context.x + me.btnWidth - this.context.x < me.disPart.min) {
            this.context.x = me._btnRight.context.x + me.btnWidth - me.disPart.min;
          }

          if (me.shapeType == 'rect') {
            me._rangeElement.context.width = me._btnRight.context.x - this.context.x - me.btnWidth;
            me._rangeElement.context.x = this.context.x + me.btnWidth;
          }

          if (me.shapeType == 'triangle') {
            me._rangeElement.context.pointList = me._getRangeTrianglePoints();
          }

          me._setRange();
        });

        me._btnLeft.on("dragend", function () {
          me.dragEnd(me.range);
        });

        this.dataZoomBtns.addChild(this._btnLeft);
      }
      var btnRightCtx = {
        x: me._getRangeEnd() / me.count * me.width - me.btnWidth + 1,
        y: -me.btnOut / 2 + 1,
        width: me.btnWidth,
        height: me.btnHeight + me.btnOut,
        fillStyle: me.right.fillStyle || me.color,
        cursor: me.right.eventEnabled && "move"
      };

      if (me._btnRight) {
        me._btnRight.animate(btnRightCtx, {
          onUpdate: setLines
        });
      } else {
        me._btnRight = new Rect({
          id: 'btnRight',
          dragEnabled: me.right.eventEnabled,
          hoverClone: false,
          context: btnRightCtx
        });

        me._btnRight.on("draging", function () {
          this.context.y = -me.btnOut / 2 + 1;

          if (this.context.x > me.width - me.btnWidth) {
            this.context.x = me.width - me.btnWidth + 1;
          }

          if (this.context.x + me.btnWidth - me._btnLeft.context.x > me.disPart.max) {
            this.context.x = me.disPart.max - (me.btnWidth - me._btnLeft.context.x) + 1;
          }

          if (this.context.x + me.btnWidth - me._btnLeft.context.x < me.disPart.min) {
            this.context.x = me.disPart.min - me.btnWidth + me._btnLeft.context.x;
          }

          if (me.shapeType == 'rect') {
            me._rangeElement.context.width = this.context.x - me._btnLeft.context.x - me.btnWidth;
            me._rangeElement.context.x = me._btnLeft.context.x + me.btnWidth;
          }

          if (me.shapeType == 'triangle') {
            me._rangeElement.context.pointList = me._getRangeTrianglePoints();
          }

          me._setRange();
        });

        me._btnRight.on("dragend", function () {
          me.dragEnd(me.range);
        });

        this.dataZoomBtns.addChild(this._btnRight);
      }
      var rangeWidth = btnRightCtx.x - btnLeftCtx.x + me.btnWidth;
      var rangeHeight = this.btnHeight - 1;
      var rangeX = btnLeftCtx.x;
      var rangeY = 1;
      var rangeFillStyle = me.range.fillStyle;

      if (rangeFillStyle && rangeFillStyle.lineargradient && rangeFillStyle.lineargradient.length) {
        var _style2 = me.ctx.createLinearGradient(0, me.btnHeight, me.width, me.btnHeight);

        _.each(rangeFillStyle.lineargradient, function (item) {
          _style2.addColorStop(item.position, item.color);
        });

        rangeFillStyle = _style2;
      }
      var rangeRectCtx = {
        x: rangeX,
        y: rangeY,
        width: rangeWidth,
        height: rangeHeight,
        fillStyle: rangeFillStyle,
        fillAlpha: me.range.alpha,
        cursor: "move"
      };
      var bgTriangleCtx = {
        x: rangeX,
        y: rangeY,
        pointList: me._getRangeTrianglePoints(),
        fillStyle: rangeFillStyle,
        fillAlpha: me.range.alpha,
        cursor: "move"
      };

      if (this._rangeElement) {
        this._rangeElement.animate(rangeRectCtx, {
          onUpdate: setLines
        });
      } else {
        //中间矩形拖拽区域
        if (this.shapeType == 'rect') {
          this._rangeElement = new Rect({
            id: 'btnRange',
            dragEnabled: true,
            hoverClone: false,
            context: rangeRectCtx
          });

          this._rangeElement.on("draging", function () {
            this.context.y = 1;

            if (this.context.x < 0) {
              this.context.x = 0;
            }

            if (this.context.x > me.width - this.context.width) {
              this.context.x = me.width - this.context.width;
            }
            me._btnLeft.context.x = this.context.x;
            me._btnRight.context.x = this.context.x + this.context.width - me.btnWidth;

            me._setRange("btnRange");
          });

          this._rangeElement.on("dragend", function () {
            me.dragEnd(me.range);
          });
        } else {
          this._rangeElement = new Polygon({
            id: 'btnRange',
            //dragEnabled : true,
            //hoverClone  : false,
            context: bgTriangleCtx
          }); //三角形的 zoom 暂时不需要添加事件
        }

        this.dataZoomBtns.addChild(this._rangeElement, 0);
      }

      if (!this.linesLeft) {
        this.linesLeft = new _canvax["default"].Display.Sprite({
          id: "linesLeft"
        });

        if (this.left.eventEnabled) {
          this._addLines({
            sprite: this.linesLeft
          });
        }
        this.dataZoomBtns.addChild(this.linesLeft);
      }

      if (!this.linesRight) {
        this.linesRight = new _canvax["default"].Display.Sprite({
          id: "linesRight"
        });

        if (this.right.eventEnabled) {
          this._addLines({
            sprite: this.linesRight
          });
        }
        this.dataZoomBtns.addChild(this.linesRight);
      }

      if (!this.linesCenter && this.shapeType == 'rect') {
        this.linesCenter = new _canvax["default"].Display.Sprite({
          id: "linesCenter"
        });

        this._addLines({
          count: 3,
          //dis    : 1,
          sprite: this.linesCenter,
          strokeStyle: this.color
        });

        this.dataZoomBtns.addChild(this.linesCenter);
      }
    }
  }, {
    key: "_getRangeTrianglePoints",
    value: function _getRangeTrianglePoints() {
      var btnLeftCtx = this._btnLeft.context;
      var btnRightCtx = this._btnRight.context;
      var rangeX = btnLeftCtx.x;
      var rangeWidth = btnRightCtx.x - btnLeftCtx.x + this.btnWidth;
      var rangeHeight = this.btnHeight - 1;
      var bgWidth = this.width;
      return [[rangeX, rangeHeight], [rangeX + rangeWidth, rangeHeight], [rangeX + rangeWidth, rangeHeight * (1 - (rangeX + rangeWidth) / bgWidth)], [rangeX, rangeHeight * (1 - rangeX / bgWidth)]];
    }
  }, {
    key: "_setRange",
    value: function _setRange(trigger) {
      var me = this;

      var _end = me._getRangeEnd();

      var _preDis = _end - me.range.start;

      var start = me._btnLeft.context.x / me.width * me.count;
      var end = (me._btnRight.context.x + me.btnWidth) / me.width * me.count; //console.log( (me._btnRight.context.x + me.btnWidth)+"|"+ me.width + "|" + me.count )

      if (this.axisLayoutType == "peak") {
        start = Math.round(start);
        end = Math.round(end);
      } else if (this.axisLayoutType == "rule") {
        start = parseInt(start);
        end = parseInt(end);
      } else {
        start = parseInt(start);
        end = parseInt(end);
      }

      if (trigger == "btnRange") {
        //如果是拖动中间部分，那么要保持 end-start的总量一致
        if (end - start != _preDis) {
          end = start + _preDis;
        }
      }

      if (start != me.range.start || end != _end) {
        me.range.start = start;

        if (me.axisLayoutType == "peak") {
          end -= 1;
        }
        me.range.end = end;
        me.dragIng(me.range);
      }

      me._setLines();
    }
  }, {
    key: "_setRange_bak",
    value: function _setRange_bak(trigger) {
      var me = this;

      var _start = me._preRange ? me._preRange.start : 0;

      var _end = me._preRange ? me._preRange.end : 0;

      var _preDis = me._preRange ? _end - me._preRange.start : 0;

      var start = me._btnLeft.context.x / me.width * me.count;
      var end = (me._btnRight.context.x + me.btnWidth) / me.width * me.count; //console.log( (me._btnRight.context.x + me.btnWidth)+"|"+ me.width + "|" + me.count )

      if (this.axisLayoutType == "peak") {
        start = Math.round(start);
        end = Math.round(end);
      } else if (this.axisLayoutType == "rule") {
        start = parseInt(start);
        end = parseInt(end);
      } else {
        start = parseInt(start);
        end = parseInt(end);
      }

      if (trigger == "btnRange") {
        //如果是拖动中间部分，那么要保持 end-start的总量一致
        if (me._preRange && end - start != _preDis) {
          end = start + _preDis;
        }
      }

      if (!me._preRange || start != _start || end != _end) {
        me.range.start = start;

        if (me.axisLayoutType == "peak") {
          end -= 1;
        }
        me.range.end = end;
        me.dragIng(me.range);
        me._preRange = Object.assign({}, me.range);
      }

      me._setLines();
    }
  }, {
    key: "_setLines",
    value: function _setLines() {
      var me = this;
      var linesLeft = this.linesLeft;
      var linesRight = this.linesRight;
      var btnLeft = this._btnLeft;
      var btnRight = this._btnRight;
      linesLeft.context.x = btnLeft.context.x + (btnLeft.context.width - linesLeft.context.width) / 2;
      linesLeft.context.y = btnLeft.context.y + (btnLeft.context.height - linesLeft.context.height) / 2;
      linesRight.context.x = btnRight.context.x + (btnRight.context.width - linesRight.context.width) / 2;
      linesRight.context.y = btnRight.context.y + (btnRight.context.height - linesRight.context.height) / 2; //矩形的选择框才有必要放中间的标示线

      if (me.shapeType == 'rect') {
        var linesCenter = this.linesCenter;
        var btnRange = this._rangeElement;
        linesCenter.context.x = btnRange.context.x + (btnRange.context.width - linesCenter.context.width) / 2;
        linesCenter.context.y = btnRange.context.y + (btnRange.context.height - linesCenter.context.height) / 2;
      }

      if (me.underline.enabled) {
        me._underline.context.start.x = linesLeft.context.x + me.btnWidth / 2;
        me._underline.context.end.x = linesRight.context.x + me.btnWidth / 2;
      }
    }
  }, {
    key: "_addLines",
    value: function _addLines($o) {
      var me = this;
      var count = $o.count || 2;
      var sprite = $o.sprite;
      var dis = $o.dis || 2;
      var a;

      for (a = 0; a < count; a++) {
        sprite.addChild(me._addLine({
          x: a * dis,
          strokeStyle: $o.strokeStyle || ''
        }));
      }

      sprite.context.width = a * dis - 1;
      sprite.context.height = 6;
    }
  }, {
    key: "_addLine",
    value: function _addLine($o) {
      var o = $o || {};
      var line = new Line({
        id: o.id || '',
        context: {
          x: o.x || 0,
          y: o.y || 0,
          start: {
            x: o.start ? o.start.x : 0,
            y: o.start ? o.start.y : 0
          },
          end: {
            x: o.end ? o.end.x : 0,
            y: o.end ? o.end.y : 6
          },
          lineWidth: o.lineWidth || 1,
          strokeStyle: o.strokeStyle || '#ffffff'
        }
      });
      return line;
    }
  }, {
    key: "setMiniGroupsMap",
    value: function setMiniGroupsMap() {
      if (this.shapeType == 'triangle') {
        return;
      }

      if (this.__graphssp) {
        this.__graphssp.destroy();
      }
      var graphssp = this._cloneChart.thumbChart.graphsSprite;
      graphssp.setEventEnable(false);

      var _coor = this._cloneChart.thumbChart.getComponent({
        name: 'coord'
      });

      graphssp.id = graphssp.id + "_datazoomthumbChartbg";
      graphssp.context.x = -_coor.origin.x; //0;
      //缩放到横条范围内

      graphssp.context.scaleY = this.btnHeight / _coor.height;
      graphssp.context.scaleX = this.width / _coor.width;
      graphssp.context.globalAlpha = this.graphAlpha;
      this.dataZoomBg.addChild(graphssp, 0);
      this.__graphssp = graphssp;

      this._cloneChart.thumbChart.destroy();

      this._cloneChart.cloneEl.parentNode.removeChild(this._cloneChart.cloneEl);
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        position: {
          detail: '位置，默认bottom,其他可选left,right,top',
          "default": 'bottom'
        },
        height: {
          detail: '高',
          "default": 24
        },
        width: {
          detail: '宽',
          "default": 0 //默认0，从轴去取width

        },
        color: {
          detail: '拖拽轴的主题颜色，比如其他按钮如果没有单独设置颜色，就继承该值',
          "default": '#809fff'
        },
        shapeType: {
          detail: '背景的图形形状,可选rect，triangle',
          "default": 'rect' // rect,triangle

        },
        range: {
          //propotion中，start 和 end代表的是数值的大小
          detail: '范围设置',
          propertys: {
            start: {
              detail: '开始位置',
              "default": 0
            },
            end: {
              detail: '结束位置，默认为null，表示到最后',
              "default": null
            },
            max: {
              detail: '最多可以选择多大的数据区间',
              "default": null
            },
            min: {
              detail: '最少可以选择多大的数据区间',
              "default": 1
            },
            eventEnabled: {
              detail: '是否响应事件',
              "default": true
            },
            fillStyle: {
              detail: '填充色',
              "default": '#000000'
            },
            alpha: {
              detail: '透明度',
              "default": 0.015
            }
          }
        },
        left: {
          detail: '左边按钮',
          propertys: {
            eventEnabled: {
              detail: '是否响应事件',
              "default": true
            },
            fillStyle: {
              detail: '颜色，默认取组件.color',
              "default": ''
            }
          }
        },
        right: {
          detail: '右边按钮',
          propertys: {
            eventEnabled: {
              detail: '是否响应事件',
              "default": true
            },
            fillStyle: {
              detail: '颜色，默认取组件.color',
              "default": ''
            }
          }
        },
        bg: {
          detail: '背景设置',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": true
            },
            fillStyle: {
              detail: '填充色',
              "default": ''
            },
            alpha: {
              detail: '透明度',
              "default": 0.5
            },
            strokeStyle: {
              detail: '边框色',
              "default": '#e6e6e6'
            },
            lineWidth: {
              detail: '线宽',
              "default": 1
            }
          }
        },
        graphAlpha: {
          detail: '图形的透明度',
          "default": 0.6
        },
        graphStyle: {
          detail: '图形的颜色',
          "default": '#dddddd'
        },
        underline: {
          detail: 'underline',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": true
            },
            strokeStyle: {
              detail: '线条色',
              "default": null
            },
            lineWidth: {
              detail: '线宽',
              "default": 2
            }
          }
        },
        btnOut: {
          detail: 'left,right按钮突出的大小',
          "default": 4
        },
        btnHeight: {
          detail: 'left,right按钮高',
          "default": 20,
          documentation: 'left,right按钮的高，不在left，right下面，统一在这个属性里， 以为要强制保持一致'
        },
        btnWidth: {
          detail: 'left,right按钮的宽',
          "default": 9,
          documentation: 'left,right按钮的宽，不在left，right下面，统一在这个属性里， 以为要强制保持一致'
        }
      };
    }
  }]);
  return dataZoom;
}(_component["default"]);

_component["default"].registerComponent(dataZoom, 'dataZoom');

var _default = dataZoom;
exports["default"] = _default;
});

unwrapExports(datazoom);

var markline = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._;
var BrokenLine = _canvax["default"].Shapes.BrokenLine;
var Sprite = _canvax["default"].Display.Sprite;
var Text = _canvax["default"].Display.Text;

var MarkLine = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(MarkLine, _Component);

  var _super = _createSuper(MarkLine);

  function MarkLine(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, MarkLine);
    _this = _super.call(this, opt, app);
    _this.name = "markLine";
    _this._yAxis = null;
    _this.line = {
      y: 0,
      list: []
    };
    _this._txt = null;
    _this._line = null;
    _this.sprite = new Sprite();

    _this.app.graphsSprite.addChild(_this.sprite);

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(MarkLine.defaultProps()), opt);

    return _this;
  }

  (0, _createClass2["default"])(MarkLine, [{
    key: "draw",
    value: function draw() {
      this._calculateProps();

      this.setPosition();
      this.widget();
    }
  }, {
    key: "_calculateProps",
    value: function _calculateProps() {
      var opt = this._opt; //如果markline有target配置，那么只现在target配置里的字段的 markline, 推荐

      var field = opt.markTo;

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      if (field && _.indexOf(this.app.dataFrame.fields, field) == -1) {
        //如果配置的字段不存在，则不绘制
        return;
      }
      var _yAxis = _coord._yAxis[0]; //默认为左边的y轴

      if (field) {
        //如果有配置markTo就从 _coord._yAxis中找到这个markTo所属的yAxis对象
        _.each(_coord._yAxis, function ($yAxis, yi) {
          var fs = _.flatten([$yAxis.field]);

          if (_.indexOf(fs, field) >= 0) {
            _yAxis = $yAxis;
          }
        });
      }

      if (opt.yAxisAlign) {
        //如果有配置yAxisAlign，就直接通过yAxisAlign找到对应的
        _yAxis = _coord._yAxis[opt.yAxisAlign == "left" ? 0 : 1];
      }
      var y;

      if (opt.y !== undefined && opt.y !== null) {
        //兼容老的配置，有些地方已经使用了y，都要改统一成yVal
        y = Number(opt.y);
      } else if (opt.yVal !== undefined && opt.yVal !== null) {
        y = Number(opt.yVal);
      } else {
        //如果没有配置这个y的属性，就 自动计算出来均值
        //但是均值是自动计算的，比如datazoom在draging的时候
        y = function y() {
          var _fdata = this.app.dataFrame.getFieldData(field);

          var _count = 0;

          _.each(_fdata, function (val) {
            if (Number(val)) {
              _count += val;
            }
          });

          return _count / _fdata.length;
        };
      }

      if (!isNaN(y)) {
        //如果y是个function说明是均值，自动实时计算的，而且不会超过ydatasection的范围
        _yAxis.addValToSection(y);
      }
      var _fstyle = "#777";

      var fieldConfig = _coord.getFieldConfig(field);

      if (fieldConfig) {
        _fstyle = fieldConfig.color;
      }
      var lineStrokeStyle = opt.line && opt.line.strokeStyle || _fstyle;
      var textFillStyle = opt.label && opt.label.fontColor || _fstyle; //开始计算赋值到属性上面

      this._yAxis = _yAxis;
      this.width = _coord.width;
      this.height = _coord.height;
      this.yVal = y;
      this.pos = {
        x: _coord.origin.x,
        y: _coord.origin.y
      };
      this.line.list = [[0, 0], [this.width, 0]];
      this.label.fontColor = textFillStyle;

      if (lineStrokeStyle) {
        this.line.strokeStyle = lineStrokeStyle;
      }
    }
  }, {
    key: "widget",
    value: function widget() {
      var me = this;

      var y = this._getYPos();

      var line = new BrokenLine({
        //线条
        id: "line",
        context: {
          y: y,
          pointList: me.line.list,
          strokeStyle: me.line.strokeStyle,
          lineWidth: me.line.lineWidth,
          lineType: me.line.lineType
        }
      });
      me.sprite.addChild(line);
      me._line = line;

      if (me.label.enabled) {
        var txtCtx = {
          fillStyle: me.label.fontColor,
          fontSize: me.label.fontSize
        };
        var txt = new Text(me._getLabel(), {
          //文字
          context: txtCtx
        });
        this._txt = txt;
        me.sprite.addChild(txt);

        me._setTxtPos(y);
      }

      this.line.y = y;
    }
  }, {
    key: "reset",
    value: function reset(opt) {
      opt && _.extend(true, this, opt);
      var me = this;

      var y = this._getYPos();

      if (y != this.line.y) {
        this._line.animate({
          y: y
        }, {
          duration: 300,
          onUpdate: function onUpdate(obj) {
            if (me.label.enabled) {
              me._txt.resetText(me._getLabel());

              me._setTxtPos(obj.y); //me._txt.context.y = obj.y - me._txt.getTextHeight();

            }
          } //easing: 'Back.Out' //Tween.Easing.Elastic.InOut

        });
      }
      this._line.context.strokeStyle = this.line.strokeStyle;
      this.line.y = y;
    }
  }, {
    key: "_setTxtPos",
    value: function _setTxtPos(y) {
      var me = this;
      var txt = me._txt;
      if (!this._yAxis) return 0;

      if (this._yAxis.align == "left") {
        txt.context.x = 5;
      } else {
        txt.context.x = this.width - txt.getTextWidth() - 5;
      }

      if (_.isNumber(me.label.y)) {
        txt.context.y = me.label.y;
      } else {
        txt.context.y = y - txt.getTextHeight();
      }
    }
  }, {
    key: "_getYVal",
    value: function _getYVal(yVal) {
      yVal = yVal || this.yVal;
      var y = yVal;

      if (_.isFunction(yVal)) {
        y = yVal.apply(this);
      }
      return y;
    }
  }, {
    key: "_getYPos",
    value: function _getYPos() {
      if (this._opt.yPixel) {
        //如果用户有指定的具体像素位置，则直接使用该值
        return -this._opt.yPixel;
      }

      if (this._yAxis) {
        return -this._yAxis.getPosOfVal(this._getYVal());
      } else {
        return 0;
      }
    }
  }, {
    key: "_getLabel",
    value: function _getLabel() {
      var str;

      var yVal = this._getYVal();

      if (_.isFunction(this.label.format)) {
        str = this.label.format(yVal, this);
      } else {
        if (_.isString(this.label.text)) {
          str = this.label.text;
        } else {
          str = yVal;
        }
      }
      return str;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        markTo: {
          detail: '标准哪个目标字段',
          "default": null
        },
        yVal: {
          detail: '组件的值',
          "default": 0,
          documentation: '可能是个function，均值计算就是个function'
        },
        yPixel: {
          detail: '组件指定的具体y像素值',
          "default": 0
        },
        line: {
          detail: '线的配置',
          propertys: {
            strokeStyle: {
              detail: '线的颜色',
              "default": '#999999'
            },
            lineWidth: {
              detail: '线宽',
              "default": 1
            },
            lineType: {
              detail: '线样式',
              "default": 'dashed'
            }
          }
        },
        label: {
          detail: '文本',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": false
            },
            fontColor: {
              detail: '文本字体颜色',
              "default": '#666'
            },
            fontSize: {
              detail: '文本字体大小',
              "default": 12
            },
            text: {
              detail: '文本内容',
              "default": null
            },
            format: {
              detail: '文本格式化函数',
              "default": null
            }
          }
        }
      };
    }
  }]);
  return MarkLine;
}(_component["default"]);

_component["default"].registerComponent(MarkLine, 'markLine');

var _default = MarkLine;
exports["default"] = _default;
});

unwrapExports(markline);

var tips = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = interopRequireDefault(_typeof_1$1);

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._;
var Rect = _canvax["default"].Shapes.Rect;
var Line = _canvax["default"].Shapes.Line;

var Tips = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(Tips, _Component);

  var _super = _createSuper(Tips);

  function Tips(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, Tips);
    _this = _super.call(this, opt, app);
    _this.name = "tips";
    _this.cW = 0; //容器的width

    _this.cH = 0; //容器的height

    _this.dW = 0; //html的tips内容width

    _this.dH = 0; //html的tips内容Height

    _this._tipDom = null;
    _this._tipsPointer = null; //所有调用tip的 event 上面 要附带有符合下面结构的eventInfo属性
    //会deepExtend到this.indo上面来

    _this.eventInfo = null;
    _this.sprite = null;
    _this.sprite = new _canvax["default"].Display.Sprite({
      id: "TipSprite"
    });

    _this.app.stage.addChild(_this.sprite);

    var me = (0, _assertThisInitialized2["default"])(_this);

    _this.sprite.on("destroy", function () {
      //me._tipDom = null;
      me._removeContent();
    });

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(Tips.defaultProps()), opt);

    _this.tipDomContainer = null;

    if (document) {
      if (_this.containerIsBody) {
        _this.tipDomContainer = document.body;
      } else {
        _this.tipDomContainer = _this.app.canvax.domView;
      }
    }

    return _this;
  }

  (0, _createClass2["default"])(Tips, [{
    key: "show",
    value: function show(e) {
      var _this2 = this;

      if (!this.enabled) return;

      if (e.eventInfo) {
        this.eventInfo = e.eventInfo; //TODO:这里要优化，canvax后续要提供直接获取canvax实例的方法

        var stage = e.target.getStage();

        if (stage) {
          this.cW = stage.context.width;
          this.cH = stage.context.height;
        } else {
          if (e.target.type == 'canvax') {
            this.cW = e.target.width;
            this.cH = e.target.height;
          }
        }

        var content = this._setContent(e);

        content.then(function (content) {
          if (content) {
            _this2._setPosition(e);

            _this2.sprite.toFront();
          } else {
            _this2._hideDialogTips(e);
          }
        });
      } else {
        this._hideDialogTips(e);
      }

      this._tipsPointerShow(e);

      this.onshow.apply(this, [e]);
    }
  }, {
    key: "move",
    value: function move(e) {
      var _this3 = this;

      if (!this.enabled) return;

      if (e.eventInfo) {
        this.eventInfo = e.eventInfo;

        var content = this._setContent(e);

        content.then(function (content) {
          if (content) {
            _this3._setPosition(e);
          } else {
            //move的时候hide的只有dialogTips, pointer不想要隐藏
            _this3._hideDialogTips();
          }
        });
      }

      this._tipsPointerMove(e);

      this.onmove.apply(this, [e]);
    }
  }, {
    key: "hide",
    value: function hide(e) {
      //console.log('tips hide')
      this._hide(e);

      this.onhide.apply(this, [e]);
    }
  }, {
    key: "_hide",
    value: function _hide(e) {
      if (!this.enabled) return;

      this._hideDialogTips(e);

      this._tipsPointerHide(e);
    }
  }, {
    key: "_hideDialogTips",
    value: function _hideDialogTips() {
      if (this.eventInfo) {
        this.eventInfo = null;
        this.sprite.removeAllChildren();

        this._removeContent();
      }
    }
    /**
     *@pos {x:0,y:0}
     */

  }, {
    key: "_setPosition",
    value: function _setPosition(e) {
      //tips直接修改为fixed，所以定位直接用e.x e.y 2020-02-27
      if (!this.enabled) return;
      if (!this._tipDom) return;
      var domBounding = this.app.canvax.el.getBoundingClientRect();
      var domBX = domBounding.x || domBounding.left;
      var domBY = domBounding.y || domBounding.top;
      var x, y;

      if (this.containerIsBody) {
        var globalPoint = e.target.localToGlobal(e.point);
        x = this._checkX(globalPoint.x + domBX + this.offsetX);
        y = this._checkY(globalPoint.y + domBY + this.offsetY);
      } else {
        x = this._checkX(e.offsetX + domBX + this.offsetX);
        y = this._checkY(e.offsetY + domBY + this.offsetY);
        x -= domBX;
        y -= domBY;
      } //let x = this._checkX( e.clientX + this.offsetX);
      //let y = this._checkY( e.clientY + this.offsetY);


      this._tipDom.style.cssText += ";visibility:visible;left:" + x + "px;top:" + y + "px;";

      if (this.positionOfPoint == "left") {
        this._tipDom.style.left = this._checkX(e.x - this.offsetX - this._tipDom.offsetWidth) + "px";
      }
    }
    /**
     *content相关-------------------------
     */

  }, {
    key: "_creatTipDom",
    value: function _creatTipDom(e) {
      if (document) {
        this._tipDom = document.createElement("div");
        this._tipDom.className = "chart-tips";
        this._tipDom.style.cssText += "; border-radius:" + this.borderRadius + "px;background:" + this.fillStyle + ";border:1px solid " + this.strokeStyle + ";visibility:hidden;position:" + (this.containerIsBody ? 'fixed' : 'absolute') + ";z-index:99999999;enabled:inline-block;*enabled:inline;*zoom:1;padding:6px;color:" + this.fontColor + ";line-height:1.5";
        this._tipDom.style.cssText += "; box-shadow:1px 1px 3px " + this.strokeStyle + ";";
        this._tipDom.style.cssText += "; border:none;white-space:nowrap;word-wrap:normal;";
        this._tipDom.style.cssText += "; text-align:left;pointer-events:none;";
        this._tipDom.style.cssText += "; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;";
        this.tipDomContainer && this.tipDomContainer.appendChild(this._tipDom);
        return this._tipDom;
      }
    }
  }, {
    key: "_removeContent",
    value: function _removeContent() {
      if (!this._tipDom) return;
      this.tipDomContainer && this.tipDomContainer.removeChild(this._tipDom);
      this._tipDom = null;
    }
  }, {
    key: "_setContent",
    value: function _setContent(e) {
      var _this4 = this;

      return new Promise(function (resolve) {
        var tipxContent = _this4._getContent(e);

        if (!tipxContent && tipxContent !== 0) {
          resolve('');
          return;
        }

        if (!_this4._tipDom) {
          _this4._tipDom = _this4._creatTipDom(e);
        }

        if (_this4._tipDom) {
          if (tipxContent.then) {
            tipxContent.then(function (tipxContent) {
              _this4._tipDom.innerHTML = tipxContent;
              _this4.dW = _this4._tipDom.offsetWidth;
              _this4.dH = _this4._tipDom.offsetHeight;
              resolve(tipxContent);
            });
          } else {
            _this4._tipDom.innerHTML = tipxContent;
            _this4.dW = _this4._tipDom.offsetWidth;
            _this4.dH = _this4._tipDom.offsetHeight;
            resolve(tipxContent);
          }
        }
      });
    }
  }, {
    key: "_getContent",
    value: function _getContent(e) {
      var content = '';

      if (e.eventInfo.tipsContent) {
        content = _.isFunction(e.eventInfo.tipsContent) ? e.eventInfo.tipsContent(e.eventInfo, e) : e.eventInfo.tipsContent;
      }

      if (!content) {
        if (this.content) {
          content = _.isFunction(this.content) ? this.content(e.eventInfo, e) : this.content;
        } else {
          content = this._getDefaultContent(e.eventInfo);
        }
      }
      return content;
    }
  }, {
    key: "_getDefaultContent",
    value: function _getDefaultContent(info) {
      var _coord = this.app.getComponent({
        name: 'coord'
      });

      var str = "";

      if (!info.nodes.length) {
        return str;
      }
      var hasNodesContent = false;

      if (info.nodes.length) {
        str += "<table >";

        if (info.title !== undefined && info.title !== null && info.title !== "") {
          str += "<tr><td colspan='2' style='text-align:left;padding-left:3px;'>";
          str += "<span style='font-size:12px;padding:4px;color:#333;'>" + info.title + "</span>";
          str += "</td></tr>";
          hasNodesContent = true;
        }

        _.each(info.nodes, function (node, i) {
          // if (!node.value && node.value !== 0) {
          //     return;
          // };
          var style = node.color || node.fillStyle || node.strokeStyle;
          var name, value;

          var fieldConfig = _coord.getFieldConfig(node.field); //node.name优先级最高，是因为像 pie funnel cloud 等一维图表，会有name属性
          //关系图中会有content


          name = node.name || node.label || (fieldConfig || {}).name || node.content || node.field || '';
          str += "<tr>";

          if ((0, _typeof2["default"])(node.value) == 'object') {
            //主要是用在散点图的情况
            if (node.value && node.value.x) {
              var xfieldConfig = _coord.getFieldConfig(info.xAxis.field);

              var xName = xfieldConfig && xfieldConfig.name || info.xAxis.field;
              var xvalue = xfieldConfig ? xfieldConfig.getFormatValue(node.value.x) : node.value.x;
              str += "<td style='padding:0px 6px;'>" + xName + "：<span style='color:" + style + "'>" + xvalue + "</span></td>";
              hasNodesContent = true;
            }

            if (node.value && node.value.y) {
              value = fieldConfig ? fieldConfig.getFormatValue(node.value.y) : node.value.y;
              str += "<td style='padding:0px 6px;'>" + name + "：<span style='color:" + style + "'>" + value + "</span></td>";
              hasNodesContent = true;
            }
          } else {
            value = fieldConfig ? fieldConfig.getFormatValue(node.value) : node.value;
            var hasValue = node.value || node.value === 0;

            if (!hasValue && !node.__no_value) {
              style = "#ddd";
              value = '--';
            }

            if (!node.__no__name) {
              str += "<td style='padding:0px 6px;color:" + (!hasValue && !node.__no_value ? '#ddd' : '#a0a0a0;') + "'>" + name + "</td>";
              hasNodesContent = true;
            }

            if (!node.__no_value) {
              str += "<td style='padding:0px 6px;font-weight:bold;'>";
              str += "<span style='color:" + style + "'>" + value + "</span>";

              if (node.subValue) {
                str += "<span style='padding-left:6px;font-weight:normal;'>" + node.subValue + "</span>";
                hasNodesContent = true;
              }
              str += "</td>";
            }
          }

          str += "</tr>";
        });

        str += "</table>";
      }

      if (!hasNodesContent) {
        str = "";
      }

      return str;
    }
    /**
     *检测是x方向超过了视窗
     */

  }, {
    key: "_checkX",
    value: function _checkX(x) {
      var w = this.dW + 2; //后面的2 是 两边的 linewidth

      var left = 0;
      var clientWidth = document.documentElement.clientWidth;

      if (x < left) {
        x = left;
      } else if (x + w > clientWidth) {
        x = clientWidth - w;
      }

      return x;
    }
    /**
     *检测是y方向超过了视窗
     */

  }, {
    key: "_checkY",
    value: function _checkY(y) {
      var h = this.dH + 2; //后面的2 是 两边的 linewidth

      var top = 0;
      var clientHeight = document.documentElement.clientHeight;

      if (y < top) {
        y = top;
      } else if (y + h > clientHeight) {
        y = clientHeight - h;
      }

      return y;
    }
  }, {
    key: "_tipsPointerShow",
    value: function _tipsPointerShow(e) {
      var _this5 = this;

      //legend等组件上面的tips是没有xAxis等轴信息的
      if (!e.eventInfo || !e.eventInfo.xAxis) {
        return;
      }

      var _coord = this.app.getComponent({
        name: 'coord'
      }); //目前只实现了直角坐标系的tipsPointer


      if (!_coord || _coord.type != 'rect') return;
      if (!this.pointer) return; //自动检测到如果数据里有一个柱状图的数据， 那么就启用region的pointer

      e.eventInfo.nodes.forEach(function (node) {
        if (node.type == "bar") {
          _this5.pointer = "region";
        }
      });
      var el = this._tipsPointer;
      var y = _coord.origin.y - _coord.height;
      var x = 0;

      if (this.pointer == "line") {
        x = _coord.origin.x + e.eventInfo.xAxis.x;
      }

      if (this.pointer == "region") {
        var regionWidth = _coord._xAxis.getCellLengthOfPos(e.eventInfo.xAxis.x);

        x = _coord.origin.x + e.eventInfo.xAxis.x - regionWidth / 2;

        if (e.eventInfo.xAxis.ind < 0) {
          //当没有任何数据的时候， e.eventInfo.xAxis.ind==-1
          x = _coord.origin.x;
        }
      }

      if (!el) {
        if (this.pointer == "line") {
          el = new Line({
            //xyToInt : false,
            context: {
              x: x,
              y: y,
              start: {
                x: 0,
                y: 0
              },
              end: {
                x: 0,
                y: _coord.height
              },
              lineWidth: this.pointerLineWidth,
              strokeStyle: this.pointerColor
            }
          });
        }

        if (this.pointer == "region") {
          var _regionWidth = _coord._xAxis.getCellLengthOfPos(x);

          el = new Rect({
            //xyToInt : false,
            context: {
              width: _regionWidth,
              height: _coord.height,
              x: x,
              y: y,
              fillStyle: this.pointerColor,
              globalAlpha: this.pointerRegionAlpha
            }
          });
        }
        this.app.graphsSprite.addChild(el, 0);
        this._tipsPointer = el;
      } else {
        if (this.pointerAnim && _coord._xAxis.layoutType != "proportion") {
          if (el.__animation) {
            el.__animation.stop();
          }
          el.__animation = el.animate({
            x: x,
            y: y
          }, {
            duration: 200
          });
        } else {
          el.context.x = x;
          el.context.y = y;
        }
      }
    }
  }, {
    key: "_tipsPointerHide",
    value: function _tipsPointerHide(e) {
      //legend等组件上面的tips是没有xAxis等轴信息的
      if (!e.eventInfo || !e.eventInfo.xAxis) {
        return;
      }

      var _coord = this.app.getComponent({
        name: 'coord'
      }); //目前只实现了直角坐标系的tipsPointer


      if (!_coord || _coord.type != 'rect') return;
      if (!this.pointer || !this._tipsPointer) return;

      this._tipsPointer.destroy();

      this._tipsPointer = null;
    }
  }, {
    key: "_tipsPointerMove",
    value: function _tipsPointerMove(e) {
      //legend等组件上面的tips是没有xAxis等轴信息的
      if (!e.eventInfo || !e.eventInfo.xAxis) {
        return;
      }

      var _coord = this.app.getComponent({
        name: 'coord'
      }); //目前只实现了直角坐标系的tipsPointer


      if (!_coord || _coord.type != 'rect') return;
      if (!this.pointer || !this._tipsPointer) return;
      var el = this._tipsPointer;
      var x = _coord.origin.x + e.eventInfo.xAxis.x;

      if (this.pointer == "region") {
        var regionWidth = _coord._xAxis.getCellLengthOfPos(e.eventInfo.xAxis.x);

        x = _coord.origin.x + e.eventInfo.xAxis.x - regionWidth / 2;

        if (e.eventInfo.xAxis.ind < 0) {
          //当没有任何数据的时候， e.eventInfo.xAxis.ind==-1
          x = _coord.origin.x;
        }
      }
      var y = _coord.origin.y - _coord.height;

      if (x == el.__targetX) {
        return;
      }

      if (this.pointerAnim && _coord._xAxis.layoutType != "proportion") {
        if (el.__animation) {
          el.__animation.stop();
        }
        el.__targetX = x;
        el.__animation = el.animate({
          x: x,
          y: y
        }, {
          duration: 200,
          onComplete: function onComplete() {
            delete el.__targetX;
            delete el.__animation;
          }
        });
      } else {
        el.context.x = x;
        el.context.y = y;
      }
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        enabled: {
          detail: '是否开启Tips',
          "default": true
        },
        content: {
          detail: '自定义tips的内容（html）',
          "default": null
        },
        containerIsBody: {
          detail: 'tips的html内容是否放到body下面，默认true，false则放到图表自身的容器内',
          "default": true
        },
        borderRadius: {
          detail: 'tips的边框圆角半径',
          "default": 5
        },
        strokeStyle: {
          detail: 'tips边框颜色',
          "default": '#ccc'
        },
        fillStyle: {
          detail: 'tips背景色',
          "default": 'rgba(255,255,255,0.95)'
        },
        fontColor: {
          detail: 'tips文本颜色',
          "default": '#999999'
        },
        positionOfPoint: {
          detail: 'tips在触发点的位置，默认在右侧',
          "default": 'right'
        },
        offsetX: {
          detail: 'tips内容到鼠标位置的偏移量x',
          "default": 10
        },
        offsetY: {
          detail: 'tips内容到鼠标位置的偏移量y',
          "default": 10
        },
        positionInRange: {
          detail: 'tip的浮层是否限定在画布区域(废弃)',
          "default": false
        },
        pointer: {
          detail: '触发tips的时候的指针样式',
          "default": 'line',
          documentation: 'tips的指针,默认为直线，可选为："line" | "region"(柱状图中一般用region)'
        },
        pointerColor: {
          detail: 'tips指针样式的颜色',
          "default": "#ccc"
        },
        pointerLineWidth: {
          detail: 'pointer为line的时候，设置指针line的线宽，默认1.5',
          "default": 1
        },
        pointerRegionAlpha: {
          detail: 'pointer为region的时候，设置指针region的透明度',
          "default": 0.38
        },
        pointerAnim: {
          detail: 'tips移动的时候，指针是否开启动画',
          "default": true
        },
        linkageName: {
          detail: 'tips的多图表联动，相同的图表会执行事件联动，这个属性注意要保证y轴的width是一致的',
          "default": null
        },
        onshow: {
          detail: 'show的时候的事件',
          "default": function _default() {}
        },
        onmove: {
          detail: 'move的时候的事件',
          "default": function _default() {}
        },
        onhide: {
          detail: 'hide的时候的事件',
          "default": function _default() {}
        }
      };
    }
  }]);
  return Tips;
}(_component["default"]);

_component["default"].registerComponent(Tips, 'tips');

var _default2 = Tips;
exports["default"] = _default2;
});

unwrapExports(tips);

var contextmenu = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._;

var contextMenu = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(contextMenu, _Component);

  var _super = _createSuper(contextMenu);

  function contextMenu(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, contextMenu);
    _this = _super.call(this, opt, app);
    _this.name = "contextmenu";
    _this.cW = 0; //容器的width

    _this.cH = 0; //容器的height

    _this.dW = 0; //html的tips内容width

    _this.dH = 0; //html的tips内容Height

    _this._tipDom = null;
    _this._tipsPointer = null; //所有调用tip的 event 上面 要附带有符合下面结构的eventInfo属性
    //会deepExtend到this.indo上面来

    _this.eventInfo = null;
    _this.sprite = null;
    _this.sprite = new _canvax["default"].Display.Sprite({
      id: "contextMenuSprite"
    });

    _this.app.stage.addChild(_this.sprite);

    var me = (0, _assertThisInitialized2["default"])(_this);

    _this.sprite.on("destroy", function () {
      me._removeContent();
    });

    _this.isShow = false;

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(contextMenu.defaultProps()), opt);

    _this.tipDomContainer = document ? document.body : null; //右键菜单只能放body下面
    // if( document ){
    //     if( this.containerIsBody ){
    //         this.tipDomContainer = document.body; 
    //     } else {
    //         this.tipDomContainer = this.app.canvax.domView;
    //     }
    // }; // (document && this.containerIsBody) ? document.body : null; //this.app.canvax.domView;

    return _this;
  }

  (0, _createClass2["default"])(contextMenu, [{
    key: "show",
    value: function show(e) {
      if (!this.enabled) return;

      if (e.eventInfo) {
        this.eventInfo = e.eventInfo; //TODO:这里要优化，canvax后续要提供直接获取canvax实例的方法

        var stage = e.target.getStage();

        if (stage) {
          this.cW = stage.context.width;
          this.cH = stage.context.height;
        } else {
          if (e.target.type == 'canvax') {
            this.cW = e.target.width;
            this.cH = e.target.height;
          }
        }

        var content = this._setContent(e);

        if (content) {
          this._setPosition(e);

          this.sprite.toFront();
        } else {
          this._hideDialogMenus(e);
        }
      } else {
        this._hideDialogMenus(e);
      }

      this.onshow.apply(this, [e]);
      this.isShow = true;
    }
  }, {
    key: "hide",
    value: function hide(e) {
      if (!this.enabled) return;

      this._hideDialogMenus(e);

      this.onhide.apply(this, [e]);
      this.isShow = false;
    }
  }, {
    key: "_hideDialogMenus",
    value: function _hideDialogMenus() {
      if (this.eventInfo) {
        this.eventInfo = null;
        this.sprite.removeAllChildren();

        this._removeContent();
      }
    }
    /**
     *@pos {x:0,y:0}
     */

  }, {
    key: "_setPosition",
    value: function _setPosition(e) {
      //tips直接修改为fixed，所以定位直接用e.x e.y 2020-02-27
      if (!this.enabled) return;
      if (!this._tipDom) return;
      var domBounding = this.app.canvax.el.getBoundingClientRect();
      var domBX = domBounding.x || domBounding.left;
      var domBY = domBounding.y || domBounding.top;
      var x, y;

      if (this.containerIsBody) {
        var globalPoint = e.target.localToGlobal(e.point);
        x = this._checkX(globalPoint.x + domBX + this.offsetX);
        y = this._checkY(globalPoint.y + domBY + this.offsetY);
      } else {
        x = this._checkX(e.offsetX + domBX + this.offsetX);
        y = this._checkY(e.offsetY + domBY + this.offsetY);
        x -= domBX;
        y -= domBY;
      }

      this._tipDom.style.cssText += ";visibility:visible;left:" + x + "px;top:" + y + "px;";

      if (this.positionOfPoint == "left") {
        this._tipDom.style.left = this._checkX(e.x - this.offsetX - this._tipDom.offsetWidth) + "px";
      }
    }
    /**
     *content相关-------------------------
     */

  }, {
    key: "_creatMenuDom",
    value: function _creatMenuDom(e) {
      var _this2 = this;

      if (document) {
        this._tipDom = document.createElement("div");
        this._tipDom.className = "context-menu-tips";
        this._tipDom.style.cssText += "; border-radius:" + this.borderRadius + "px;background:" + this.fillStyle + ";border:1px solid " + this.strokeStyle + ";visibility:hidden;position:" + (this.containerIsBody ? 'fixed' : 'absolute') + ";z-index:99999999;enabled:inline-block;*enabled:inline;*zoom:1;color:" + this.fontColor + ";line-height:1.5";
        this._tipDom.style.cssText += "; box-shadow:1px 1px 3px " + this.strokeStyle + ";";
        this._tipDom.style.cssText += "; border:none;white-space:nowrap;word-wrap:normal;";
        this._tipDom.style.cssText += "; text-align:left;";
        this._tipDom.style.cssText += "; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;";

        this._tipDom.onclick = function () {
          _this2.hide();
        };

        this.tipDomContainer && this.tipDomContainer.appendChild(this._tipDom);
        return this._tipDom;
      }
    }
  }, {
    key: "_removeContent",
    value: function _removeContent() {
      if (!this._tipDom) return;
      this.tipDomContainer && this.tipDomContainer.removeChild(this._tipDom);
      this._tipDom = null;
    }
  }, {
    key: "_setContent",
    value: function _setContent(e) {
      var tipxContent = this._getContent(e);

      if (!tipxContent && tipxContent !== 0) {
        return;
      }

      if (!this._tipDom) {
        this._tipDom = this._creatMenuDom(e);
      }

      if (this._tipDom) {
        this._tipDom.innerHTML = tipxContent;
        this.dW = this._tipDom.offsetWidth;
        this.dH = this._tipDom.offsetHeight;
      }
      return tipxContent;
    }
  }, {
    key: "_getContent",
    value: function _getContent(e) {
      var tipsContent;

      if (this.content) {
        tipsContent = _.isFunction(this.content) ? this.content(e.eventInfo, e) : this.content;
      } else {
        tipsContent = '';
      }
      return tipsContent;
    }
    /**
    *检测是x方向超过了视窗
    */

  }, {
    key: "_checkX",
    value: function _checkX(x) {
      var w = this.dW + 2; //后面的2 是 两边的 linewidth

      var left = 0;
      var clientWidth = document.documentElement.clientWidth;

      if (x < left) {
        x = left;
      } else if (x + w > clientWidth) {
        x = clientWidth - w;
      }

      return x;
    }
    /**
     *检测是y方向超过了视窗
     */

  }, {
    key: "_checkY",
    value: function _checkY(y) {
      var h = this.dH + 2; //后面的2 是 两边的 linewidth

      var top = 0;
      var clientHeight = document.documentElement.clientHeight;

      if (y < top) {
        y = top;
      } else if (y + h > clientHeight) {
        y = clientHeight - h;
      }

      return y;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        enabled: {
          detail: '是否开启右键菜单',
          "default": true
        },
        content: {
          detail: '自定义tips的内容（html）',
          "default": null
        },
        containerIsBody: {
          detail: 'tips的html内容是否放到body下面，默认true，false则放到图表自身的容器内',
          "default": true
        },
        borderRadius: {
          detail: 'tips的边框圆角半径',
          "default": 5
        },
        strokeStyle: {
          detail: 'tips边框颜色',
          "default": '#ccc'
        },
        fillStyle: {
          detail: 'tips背景色',
          "default": 'rgba(255,255,255,0.95)'
        },
        fontColor: {
          detail: 'tips文本颜色',
          "default": '#999999'
        },
        positionOfPoint: {
          detail: 'tips在触发点的位置，默认在右侧',
          "default": 'right'
        },
        offsetX: {
          detail: 'tips内容到鼠标位置的偏移量x',
          "default": 10
        },
        offsetY: {
          detail: 'tips内容到鼠标位置的偏移量y',
          "default": 10
        },
        onshow: {
          detail: 'show的时候的事件',
          "default": function _default() {}
        },
        onmove: {
          detail: 'move的时候的事件',
          "default": function _default() {}
        },
        onhide: {
          detail: 'hide的时候的事件',
          "default": function _default() {}
        }
      };
    }
  }]);
  return contextMenu;
}(_component["default"]);

_component["default"].registerComponent(contextMenu, 'contextmenu');

var _default2 = contextMenu;
exports["default"] = _default2;
});

unwrapExports(contextmenu);

var bartgi = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Line = _canvax["default"].Shapes.Line;
var _ = _canvax["default"]._;

var barTgi = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(barTgi, _Component);

  var _super = _createSuper(barTgi);

  function barTgi(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, barTgi);
    _this = _super.call(this, opt, app);
    _this.name = "barTgi"; //this.field = null;
    //this.barField = null;

    _this.data = null;
    _this.barDatas = null;
    _this._yAxis = null; //this.yAxisAlign = "left";

    _this.sprite = null; //this.standardVal = 100;

    _this.pos = {
      x: 0,
      y: 0
    };
    /*
    this.line = {
        lineWidth : 3,
        strokeStyle : function( val, i ){
            if( val >= this.standardVal ){
                return "#43cbb5"
            } else {
                return "#ff6060"
            }
        }
    };
    */

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(barTgi.defaultProps()), opt);

    _this._yAxis = _this.app.getComponent({
      name: 'coord'
    })._yAxis[_this.yAxisAlign == "left" ? 0 : 1];
    _this.sprite = new _canvax["default"].Display.Sprite();

    _this.app.graphsSprite.addChild(_this.sprite);

    return _this;
  }

  (0, _createClass2["default"])(barTgi, [{
    key: "reset",
    value: function reset(opt) {
      _.extend(true, this, opt);

      this.barDatas = null;
      this.data = null;
      this.sprite.removeAllChildren();
      this.draw();
    }
  }, {
    key: "draw",
    value: function draw() {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      this.pos = {
        x: _coord.origin.x,
        y: _coord.origin.y
      };
      this.setPosition();

      _.each(me.app.getComponents({
        name: 'graphs'
      }), function (_g) {
        if (_g.type == "bar" && _g.data[me.barField]) {
          me.barDatas = _g.data[me.barField];
          return false;
        }
      });

      this.data = _.flatten(me.app.dataFrame.getDataOrg(me.field));

      if (!this.barDatas) {
        return;
      }

      _.each(this.data, function (tgi, i) {
        var y = -me._yAxis.getPosOfVal(tgi);
        var barData = me.barDatas[i];

        var _tgiLine = new Line({
          context: {
            start: {
              x: barData.x,
              y: y
            },
            end: {
              x: barData.x + barData.width,
              y: y
            },
            lineWidth: 2,
            strokeStyle: me._getProp(me.line.strokeStyle, tgi, i)
          }
        });

        me.sprite.addChild(_tgiLine);
      });
    }
  }, {
    key: "_getProp",
    value: function _getProp(val, tgi, i) {
      var res = val;

      if (_.isFunction(val)) {
        res = val.apply(this, [tgi, i]);
      }
      return res;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: '字段配置',
          "default": null
        },
        barField: {
          detail: '这个bartgi组件对应的bar Graph 的field',
          "default": null
        },
        yAxisAlign: {
          detail: '这个bartgi组件回到到哪个y轴',
          "default": 'left'
        },
        standardVal: {
          detail: 'tgi标准线',
          "default": 100
        },
        line: {
          detail: 'bar对应的tgi线配置',
          propertys: {
            lineWidth: {
              detail: '线宽',
              "default": 3
            },
            strokeStyle: {
              detail: '线颜色',
              "default": function _default(val) {
                if (val >= this.standardVal) {
                  return "#43cbb5";
                } else {
                  return "#ff6060";
                }
              }
            }
          }
        }
      };
    }
  }]);
  return barTgi;
}(_component["default"]);

_component["default"].registerComponent(barTgi, 'barTgi');

var _default2 = barTgi;
exports["default"] = _default2;
});

unwrapExports(bartgi);

var barguide = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._;

var barGuide = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(barGuide, _Component);

  var _super = _createSuper(barGuide);

  function barGuide(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, barGuide);
    _this = _super.call(this, opt, app);
    _this.name = "barGuide";
    _this.data = null;
    _this.barDatas = null;
    _this._yAxis = null;
    _this.sprite = null;

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(barGuide.defaultProps()), opt);

    _this._yAxis = _this.app.getComponent({
      name: 'coord'
    })._yAxis[_this.yAxisAlign == "left" ? 0 : 1];
    _this.sprite = new _canvax["default"].Display.Sprite();

    _this.app.graphsSprite.addChild(_this.sprite);

    return _this;
  }

  (0, _createClass2["default"])(barGuide, [{
    key: "reset",
    value: function reset(opt) {
      _.extend(true, this, opt);

      this.barDatas = null;
      this.data = null;
      this.sprite.removeAllChildren();
      this.draw();
    }
  }, {
    key: "draw",
    value: function draw() {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      this.pos = {
        x: _coord.origin.x,
        y: _coord.origin.y
      };
      this.setPosition();

      _.each(me.app.getComponents({
        name: 'graphs'
      }), function (_g) {
        if (_g.type == "bar" && _g.data[me.barField]) {
          me.barDatas = _g.data[me.barField];
          return false;
        }
      });

      this.data = _.flatten(me.app.dataFrame.getDataOrg(me.field));

      if (!this.barDatas) {
        return;
      }

      _.each(this.data, function (val, i) {
        var y = -me._yAxis.getPosOfVal(val);
        var barData = me.barDatas[i];

        var _node = new _canvax["default"].Shapes.Circle({
          context: {
            x: barData.x + barData.width / 2,
            y: y,
            r: me.node.radius,
            fillStyle: me.node.fillStyle,
            strokeStyle: me.node.strokeStyle,
            lineWidth: me.node.lineWidth
          }
        });

        var _label = val;

        if (_.isFunction(me.label.format)) {
          _label = me.label.format(val, barData);
        }

        var _txt = new _canvax["default"].Display.Text(_label, {
          context: {
            x: barData.x + barData.width / 2,
            y: y - me.node.radius - 1,
            fillStyle: me.label.fontColor,
            lineWidth: me.label.lineWidth,
            strokeStyle: me.label.strokeStyle,
            fontSize: me.label.fontSize,
            textAlign: me.label.textAlign,
            textBaseline: me.label.verticalAlign
          }
        });

        me.sprite.addChild(_node);
        me.sprite.addChild(_txt);
      });
    }
  }, {
    key: "_getProp",
    value: function _getProp(val, tgi, i) {
      var res = val;

      if (_.isFunction(val)) {
        res = val.apply(this, [tgi, i]);
      }

      return res;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        field: {
          detail: '字段配置',
          "default": null
        },
        barField: {
          detail: '这个guide对应的bar Graph 的field',
          "default": null
        },
        yAxisAlign: {
          detail: '这个guide组件回到到哪个y轴',
          "default": 'left'
        },
        node: {
          detail: '单个节点配置',
          propertys: {
            shapeType: {
              detail: '节点绘制的图形类型',
              "default": 'circle'
            },
            lineWidth: {
              detail: '图表描边线宽',
              "default": 3
            },
            radius: {
              detail: '图形半径',
              "default": 6
            },
            fillStyle: {
              detail: '填充色',
              "default": '#19dea1'
            },
            strokeStyle: {
              detail: '描边色',
              "default": '#fff'
            }
          }
        },
        label: {
          detail: '文本配置',
          propertys: {
            fontSize: {
              detail: '字体大小',
              "default": 12
            },
            fontColor: {
              detail: '字体颜色',
              "default": '#19dea1'
            },
            verticalAlign: {
              detail: '垂直对齐方式',
              "default": 'bottom'
            },
            textAlign: {
              detail: '水平对齐方式',
              "default": 'center'
            },
            strokeStyle: {
              detail: '文本描边颜色',
              "default": '#fff'
            },
            lineWidth: {
              detail: '文本描边线宽',
              "default": 0
            },
            format: {
              detail: '文本格式处理函数',
              "default": null
            }
          }
        }
      };
    }
  }]);
  return barGuide;
}(_component["default"]);

_component["default"].registerComponent(barGuide, 'barGuide');

var _default = barGuide;
exports["default"] = _default;
});

unwrapExports(barguide);

var theme = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Theme = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(Theme, _Component);

  var _super = _createSuper(Theme);

  function Theme(theme, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, Theme);
    _this = _super.call(this, theme, app);
    _this.name = "theme";
    _this.colors = theme || [];
    return _this;
  }

  (0, _createClass2["default"])(Theme, [{
    key: "set",
    value: function set(colors) {
      this.colors = colors;
      return this.colors;
    }
  }, {
    key: "get",
    value: function get(ind) {
      var colors = this.colors;

      if (!Canvax._.isArray(colors)) {
        colors = [colors];
      }
      return colors;
    }
  }, {
    key: "mergeTo",
    value: function mergeTo(colors) {
      if (!colors) {
        colors = [];
      }

      for (var i = 0, l = this.colors.length; i < l; i++) {
        if (colors[i]) {
          colors[i] = this.colors[i];
        } else {
          colors.push(this.colors[i]);
        }
      }
      return colors;
    }
  }]);
  return Theme;
}(_component["default"]);

_component["default"].registerComponent(Theme, 'theme');

var _default = Theme;
exports["default"] = _default;
});

unwrapExports(theme);

var watermark = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _canvax = interopRequireDefault(Canvax);



var _component = interopRequireDefault(component);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._;

var waterMark = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(waterMark, _Component);

  var _super = _createSuper(waterMark);

  function waterMark(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, waterMark);
    _this = _super.call(this, opt, app);
    _this.name = "waterMark";
    _this.width = _this.app.width;
    _this.height = _this.app.height;

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(waterMark.defaultProps()), opt);

    _this.spripte = new _canvax["default"].Display.Sprite({
      id: "watermark"
    });

    _this.app.stage.addChild(_this.spripte);

    _this.draw();

    return _this;
  }

  (0, _createClass2["default"])(waterMark, [{
    key: "draw",
    value: function draw() {
      var textEl = new _canvax["default"].Display.Text(this.text, {
        context: {
          fontSize: this.fontSize,
          fillStyle: this.fontColor
        }
      });
      var textW = textEl.getTextWidth();
      var textH = textEl.getTextHeight();
      var rowCount = parseInt(this.height / (textH * 5)) + 1;
      var coluCount = parseInt(this.width / (textW * 1.5)) + 1;

      for (var r = 0; r < rowCount; r++) {
        for (var c = 0; c < coluCount; c++) {
          //TODO:text 的 clone有问题
          //let cloneText = textEl.clone();
          var _textEl = new _canvax["default"].Display.Text(this.text, {
            context: {
              rotation: this.rotation,
              fontSize: this.fontSize,
              fillStyle: this.fontColor,
              globalAlpha: this.alpha
            }
          });

          _textEl.context.x = textW * 1.5 * c + textW * .25;
          _textEl.context.y = textH * 5 * r;
          this.spripte.addChild(_textEl);
        }
      }
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        text: {
          detail: '水印内容',
          "default": 'chartx'
        },
        fontSize: {
          detail: '字体大小',
          "default": 20
        },
        fontColor: {
          detail: '水印颜色',
          "default": '#cccccc'
        },
        alpha: {
          detail: '水印透明度',
          "default": 0.2
        },
        rotation: {
          detail: '水印旋转角度',
          "default": 45
        }
      };
    }
  }]);
  return waterMark;
}(_component["default"]);

_component["default"].registerComponent(waterMark, 'waterMark');

var _default = waterMark;
exports["default"] = _default;
});

unwrapExports(watermark);

var cross = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._;
var Line = _canvax["default"].Shapes.Line;
var Rect = _canvax["default"].Shapes.Rect;
var Arrow = _canvax["default"].Shapes.Arrow;
var Text = _canvax["default"].Display.Text;

var Cross = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(Cross, _Component);

  var _super = _createSuper(Cross);

  function Cross(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, Cross);
    _this = _super.call(this, opt, app);
    _this.name = "cross";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(Cross.defaultProps()), opt);

    _this._yAxis = _this.app.getComponent({
      name: 'coord'
    })._yAxis[_this.yAxisAlign == "left" ? 0 : 1];
    _this.sprite = new _canvax["default"].Display.Sprite();

    _this.app.graphsSprite.addChild(_this.sprite, 0); //放到所有graphs的下面


    return _this;
  }

  (0, _createClass2["default"])(Cross, [{
    key: "draw",
    value: function draw() {
      this._widget();
    }
  }, {
    key: "reset",
    value: function reset(opt) {
      opt && _.extend(true, this, opt);

      this._widget();
    }
  }, {
    key: "_widget",
    value: function _widget() {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      this.pos = {
        x: _coord.origin.x,
        y: _coord.origin.y
      };
      this.setPosition();
      var width = _coord.width;
      var height = _coord.height;
      var xVal = this.aimPoint.xVal;
      var x = 0;

      if (xVal == null || xVal == undefined) {
        x = parseInt(width / 2);
      } else {
        x = _coord._xAxis.getPosOfVal(xVal);
      }

      var yVal = this.aimPoint.yVal;
      var y = 0;

      if (xVal == null || xVal == undefined) {
        y = parseInt(height / 2);
      } else {
        y = _coord._yAxis[0].getPosOfVal(yVal);
      }

      for (var i = 0, l = 4; i < l; i++) {
        var _x = 0,
            _y = 0,
            _w = 0,
            _h = 0;
        var quadrant = void 0;
        var textCtx = {};
        var textBackGroundCtx = {};

        switch (i) {
          case 0:
            _w = width - x;
            _h = height - y;
            _x = x;
            _y = -height;
            quadrant = 'rightTop';
            textCtx = {
              x: width - 8,
              y: _y + 4,
              textAlign: 'right',
              textBaseline: 'top'
            };
            textBackGroundCtx = {
              x: width,
              y: _y
            };
            break;

          case 1:
            _w = x;
            _h = height - y;
            _x = 0;
            _y = -height;
            quadrant = 'leftTop';
            textCtx = {
              x: _x + 8,
              y: _y + 4,
              textAlign: 'left',
              textBaseline: 'top'
            };
            textBackGroundCtx = {
              x: _x,
              y: _y
            };
            break;

          case 2:
            _w = x;
            _h = y;
            _x = 0;
            _y = -y;
            quadrant = 'leftBottom';
            textCtx = {
              x: 0 + 8,
              y: 0 - 4,
              textAlign: 'left',
              textBaseline: 'bottom'
            };
            textBackGroundCtx = {
              x: 0,
              y: 0
            };
            break;

          case 3:
            _w = width - x;
            _h = y;
            _x = x;
            _y = -y;
            quadrant = 'rightBottom';
            textCtx = {
              x: width - 8,
              y: 0 - 4,
              textAlign: 'right',
              textBaseline: 'bottom'
            };
            textBackGroundCtx = {
              x: width,
              y: 0
            };
            break;
        }

        var quadrantOpt = this.quadrant[quadrant];
        var ctx = {
          width: _w,
          height: _h,
          x: _x,
          y: _y,
          fillStyle: quadrantOpt.fillStyle,
          fillAlpha: quadrantOpt.fillAlpha
        };
        var quadrantId = '_quadrant_' + i;

        if (this[quadrantId]) {
          Object.assign(this[quadrantId].context, ctx);
        } else {
          this[quadrantId] = new Rect({
            id: quadrantId,
            context: ctx
          });
          me.sprite.addChild(this[quadrantId]);
        } //象限文本和象限文本背景的是否显示


        var visible = true;

        if (!_w || !_h || !quadrantOpt.label.text) {
          visible = false;
        } //设置象限文本


        textCtx.fillStyle = quadrantOpt.label.fontColor;
        textCtx.fontSize = quadrantOpt.label.fontSize;
        textCtx.visible = visible; //textCtx.x = 0;
        //textCtx.y = 0;

        var quadrantTextId = '_quadrant_text' + i;

        if (this[quadrantTextId]) {
          Object.assign(this[quadrantTextId].context, textCtx);
        } else {
          this[quadrantTextId] = new Text(quadrantOpt.label.text, {
            id: quadrantTextId,
            context: textCtx
          });
          me.sprite.addChild(this[quadrantTextId]);
        } //设置文本的背景


        textBackGroundCtx.fillStyle = quadrantOpt.label.fillStyle;
        textBackGroundCtx.fillAlpha = quadrantOpt.label.fillAlpha;
        textBackGroundCtx.visible = visible;
        Object.assign(textBackGroundCtx, {
          width: this[quadrantTextId].getTextWidth() + 16,
          height: this[quadrantTextId].getTextHeight() + 8
        });

        switch (i) {
          case 0:
            textBackGroundCtx.x = textBackGroundCtx.x - textBackGroundCtx.width;
            break;

          case 1:
            break;

          case 2:
            textBackGroundCtx.y = textBackGroundCtx.y - textBackGroundCtx.height;
            break;

          case 3:
            textBackGroundCtx.x = textBackGroundCtx.x - textBackGroundCtx.width;
            textBackGroundCtx.y = textBackGroundCtx.y - textBackGroundCtx.height;
            break;
        }

        var quadrantTextBackGroundId = '_quadrant_text_background_' + i;

        if (this[quadrantTextBackGroundId]) {
          Object.assign(this[quadrantTextBackGroundId].context, textBackGroundCtx);
        } else {
          this[quadrantTextBackGroundId] = new Rect({
            id: quadrantTextBackGroundId,
            context: textBackGroundCtx
          });
          me.sprite.addChild(this[quadrantTextBackGroundId]);
          this[quadrantTextBackGroundId].toBack(1);
        }
      } //开始绘制两交叉线


      var _hCtx = {
        //横向线条
        start: {
          x: 0,
          y: -y
        },
        end: {
          x: width,
          y: -y
        },
        strokeStyle: me.line.strokeStyle,
        lineWidth: me.line.lineWidth,
        lineType: me.line.lineType
      };

      if (me._hLineElement) {
        //_.extend( me._hLineElement.context , _hCtx );
        me._hLineElement.context.start.y = _hCtx.start.y;
        me._hLineElement.context.end.y = _hCtx.end.y;
      } else {
        me._hLineElement = new Line({
          context: _hCtx
        });
        me.sprite.addChild(me._hLineElement);
      }

      var _hArrowCtx = {
        x: 0,
        y: 0,
        control: {
          x: _hCtx.end.x - 10,
          y: _hCtx.end.y
        },
        point: {
          x: _hCtx.end.x,
          y: _hCtx.end.y
        },
        strokeStyle: _hCtx.strokeStyle,
        fillStyle: _hCtx.strokeStyle
      };

      if (me._hLineElementArrow) {
        Object.assign(me._hLineElementArrow.context.control, _hArrowCtx.control);
        Object.assign(me._hLineElementArrow.context.point, _hArrowCtx.point);
      } else {
        me._hLineElementArrow = new Arrow({
          id: '_hArrow',
          context: _hArrowCtx
        });
        me.sprite.addChild(me._hLineElementArrow);
      } //h上面的两个label


      ['begin', 'end'].forEach(function (type) {
        var _lineLabelCtx = {
          x: type == 'begin' ? 4 : width - 4,
          y: -y - 4,
          fillStyle: me.line.hLabel[type].fontColor,
          fontSize: me.line.hLabel[type].fontSize,
          textAlign: type == 'begin' ? 'left' : 'right',
          textBaseline: 'bottom'
        };
        var _elm = me['_hLineLabel' + type + 'Ctx'];

        if (_elm) {
          Object.assign(_elm.context, _lineLabelCtx);
        } else {
          _elm = me['_hLineLabel' + type + 'Ctx'] = new Text(me.line.hLabel[type].text, {
            context: _lineLabelCtx
          });
          me.sprite.addChild(_elm);
        }
      });
      var _vCtx = {
        start: {
          x: x,
          y: 0
        },
        end: {
          x: x,
          y: -height
        },
        strokeStyle: me.line.strokeStyle,
        lineWidth: me.line.lineWidth,
        lineType: me.line.lineType
      };

      if (me._vLineElement) {
        //_.extend( me._vLineElement.context , _vCtx );
        me._vLineElement.context.start.x = _vCtx.start.x;
        me._vLineElement.context.end.x = _vCtx.end.x;
      } else {
        me._vLineElement = new Line({
          //线条
          context: _vCtx
        });
        me.sprite.addChild(me._vLineElement);
      }

      var _vArrowCtx = {
        x: 0,
        y: 0,
        control: {
          x: _vCtx.end.x,
          y: _vCtx.end.y + 10
        },
        point: {
          x: _vCtx.end.x,
          y: _vCtx.end.y
        },
        strokeStyle: _vCtx.strokeStyle,
        fillStyle: _vCtx.strokeStyle
      };

      if (me._vLineElementArrow) {
        Object.assign(me._vLineElementArrow.context.control, _vArrowCtx.control);
        Object.assign(me._vLineElementArrow.context.point, _vArrowCtx.point);
      } else {
        me._vLineElementArrow = new Arrow({
          id: '_vArrow',
          context: _vArrowCtx
        });
        me.sprite.addChild(me._vLineElementArrow);
      } //v上面的两个label  


      ['begin', 'end'].forEach(function (type) {
        var _lineLabelCtx = {
          x: x - 4,
          y: type == 'begin' ? -4 : -height + 4,
          fillStyle: me.line.vLabel[type].fontColor,
          fontSize: me.line.vLabel[type].fontSize,
          textAlign: 'right',
          textBaseline: type == 'begin' ? 'bottom' : 'top'
        };
        var _elm = me['_vLineLabel' + type + 'Ctx'];

        if (_elm) {
          Object.assign(_elm.context, _lineLabelCtx);
        } else {
          _elm = me['_vLineLabel' + type + 'Ctx'] = new Text(me.line.vLabel[type].text, {
            context: _lineLabelCtx
          });
          me.sprite.addChild(_elm);
        }
      });
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        aimPoint: {
          detail: '准心位置',
          propertys: {
            xVal: {
              detail: '准心x轴value',
              "default": null
            },
            yVal: {
              detail: '准心y轴value',
              "default": null
            }
          }
        },
        line: {
          detail: '线配置',
          propertys: {
            strokeStyle: {
              detail: '线颜色',
              "default": '#cccccc'
            },
            lineWidth: {
              detail: '线宽',
              "default": 1
            },
            lineType: {
              detail: '线样式类型',
              "default": 'solid'
            },
            showArrow: {
              detail: '是否显示箭头',
              "default": true
            },
            vLabel: {
              detail: '纵向线方向的label',
              propertys: {
                begin: {
                  detail: '开始点label',
                  propertys: {
                    text: {
                      detail: '文本内容',
                      "default": ''
                    },
                    fontColor: {
                      detail: '文本颜色',
                      "default": '#999'
                    },
                    fontSize: {
                      detail: '文本大小',
                      "default": 12
                    }
                  }
                },
                end: {
                  detail: '结束点label',
                  propertys: {
                    text: {
                      detail: '文本内容',
                      "default": ''
                    },
                    fontColor: {
                      detail: '文本颜色',
                      "default": '#999'
                    },
                    fontSize: {
                      detail: '文本大小',
                      "default": 12
                    }
                  }
                }
              }
            },
            hLabel: {
              detail: '横向线方向的label',
              propertys: {
                begin: {
                  detail: '开始点label',
                  propertys: {
                    text: {
                      detail: '文本内容',
                      "default": ''
                    },
                    fontColor: {
                      detail: '文本颜色',
                      "default": '#999'
                    },
                    fontSize: {
                      detail: '文本大小',
                      "default": 12
                    }
                  }
                },
                end: {
                  detail: '结束点label',
                  propertys: {
                    text: {
                      detail: '文本内容',
                      "default": ''
                    },
                    fontColor: {
                      detail: '文本颜色',
                      "default": '#999'
                    },
                    fontSize: {
                      detail: '文本大小',
                      "default": 12
                    }
                  }
                }
              }
            }
          }
        },
        quadrant: {
          detail: '4象限设置',
          propertys: {
            rightTop: {
              detail: '第一象限',
              propertys: {
                fillStyle: {
                  detail: '象限区块背景色',
                  "default": '#fff'
                },
                fillAlpha: {
                  detail: '象限区块背透明度',
                  "default": 0.1
                },
                label: {
                  detail: '象限文本设置',
                  propertys: {
                    text: {
                      detail: '文本内容',
                      "default": ''
                    },
                    fontColor: {
                      detail: '文本颜色',
                      "default": '#666'
                    },
                    fontSize: {
                      detail: '文本字体大小',
                      "default": 14
                    },
                    fillStyle: {
                      detail: '文本矩形背景色',
                      "default": '#e9e9f8'
                    },
                    fillAlpha: {
                      detail: '文本矩形背景透明度',
                      "default": 0.5
                    }
                  }
                }
              }
            },
            leftTop: {
              detail: '第二象限',
              propertys: {
                fillStyle: {
                  detail: '象限区块背景色',
                  "default": '#fff'
                },
                fillAlpha: {
                  detail: '象限区块背透明度',
                  "default": 0.1
                },
                label: {
                  detail: '象限文本设置',
                  propertys: {
                    text: {
                      detail: '文本内容',
                      "default": ''
                    },
                    fontColor: {
                      detail: '文本颜色',
                      "default": '#666'
                    },
                    fontSize: {
                      detail: '文本字体大小',
                      "default": 14
                    },
                    fillStyle: {
                      detail: '文本矩形背景色',
                      "default": '#e9e9f8'
                    },
                    fillAlpha: {
                      detail: '文本矩形背景透明度',
                      "default": 0.5
                    }
                  }
                }
              }
            },
            leftBottom: {
              detail: '第三象限',
              propertys: {
                fillStyle: {
                  detail: '象限区块背景色',
                  "default": '#fff'
                },
                fillAlpha: {
                  detail: '象限区块背透明度',
                  "default": 0.1
                },
                label: {
                  detail: '象限文本设置',
                  propertys: {
                    text: {
                      detail: '文本内容',
                      "default": ''
                    },
                    fontColor: {
                      detail: '文本颜色',
                      "default": '#666'
                    },
                    fontSize: {
                      detail: '文本字体大小',
                      "default": 14
                    },
                    fillStyle: {
                      detail: '文本矩形背景色',
                      "default": '#e9e9f8'
                    },
                    fillAlpha: {
                      detail: '文本矩形背景透明度',
                      "default": 0.5
                    }
                  }
                }
              }
            },
            rightBottom: {
              detail: '第四象限',
              propertys: {
                fillStyle: {
                  detail: '象限区块背景色',
                  "default": '#fff'
                },
                fillAlpha: {
                  detail: '象限区块背透明度',
                  "default": 0.1
                },
                label: {
                  detail: '象限文本设置',
                  propertys: {
                    text: {
                      detail: '文本内容',
                      "default": ''
                    },
                    fontColor: {
                      detail: '文本颜色',
                      "default": '#666'
                    },
                    fontSize: {
                      detail: '文本字体大小',
                      "default": 14
                    },
                    fillStyle: {
                      detail: '文本矩形背景色',
                      "default": '#e9e9f8'
                    },
                    fillAlpha: {
                      detail: '文本矩形背景透明度',
                      "default": 0.5
                    }
                  }
                }
              }
            }
          }
        }
      };
    }
  }]);
  return Cross;
}(_component["default"]);

_component["default"].registerComponent(Cross, 'cross');

var _default = Cross;
exports["default"] = _default;
});

unwrapExports(cross);

var lineschedu = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._;

var lineSchedu = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(lineSchedu, _Component);

  var _super = _createSuper(lineSchedu);

  function lineSchedu(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, lineSchedu);
    _this = _super.call(this, opt, app);
    _this.name = "lineSchedu";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(lineSchedu.defaultProps()), opt);

    _this.lineDatas = null;
    _this.sprite = new _canvax["default"].Display.Sprite();

    _this.app.graphsSprite.addChild(_this.sprite);

    return _this;
  }

  (0, _createClass2["default"])(lineSchedu, [{
    key: "reset",
    value: function reset(opt) {
      _.extend(true, this, opt);

      this.lineDatas = null;
      this.sprite.removeAllChildren();
      this.draw();
    }
  }, {
    key: "draw",
    value: function draw() {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      this.pos = {
        x: _coord.origin.x,
        y: _coord.origin.y
      };
      this.setPosition();
      var lineGraphs = me.app.getComponent({
        name: 'graphs',
        type: "line",
        field: me.lineField
      });
      me.lineDatas = lineGraphs.data[me.lineField].data;
      var iNode = this.app.getComponent({
        name: "coord"
      }).getAxis({
        type: "xAxis"
      }).getIndexOfVal(this.time);

      if (iNode == -1) {
        return;
      }
      var nodeData = this.lineDatas[iNode];

      if (nodeData.y != undefined) {
        var y = me._getNodeY(nodeData, _coord);

        var x = nodeData.x;

        var _txtSp = new _canvax["default"].Display.Sprite({
          context: {
            x: x - 20
          }
        });

        this.sprite.addChild(_txtSp);
        var txtHeight = 0;

        var _title = new _canvax["default"].Display.Text(me.time, {
          context: {
            fillStyle: this.timeFontColor || this.style,
            fontSize: this.timeFontSize
          }
        });

        _txtSp.addChild(_title);

        txtHeight = _title.getTextHeight();

        var txtWidth = _title.getTextWidth();

        var _list = new _canvax["default"].Display.Text(_.flatten([me.list]).join("\n"), {
          context: {
            y: txtHeight,
            fillStyle: this.listFontColor || this.style,
            fontSize: this.listFontSize
          }
        });

        _txtSp.addChild(_list);

        txtHeight += _list.getTextHeight();
        txtWidth = Math.max(txtWidth, _list.getTextWidth());

        if (txtWidth + x - 20 > _coord.width + me.app.padding.right) {
          _txtSp.context.x = _coord.width + me.app.padding.right;
          _title.context.textAlign = "right";
          _list.context.textAlign = "right";
        }
        var tsTop = 0;

        if (me.status == "online") {
          tsTop = y - (this.radius + 3) - txtHeight;

          if (Math.abs(tsTop) > _coord.origin.y) {
            tsTop = -_coord.origin.y;
            y = -(_coord.origin.y - (this.radius + 3) - txtHeight);
          }
        } else {
          tsTop = y + (this.radius + 3);

          if (tsTop + txtHeight > 0) {
            tsTop = -txtHeight;
            y = -(this.radius + 3) - txtHeight;
          }
        }
        _txtSp.context.y = tsTop;

        var _line = new _canvax["default"].Shapes.BrokenLine({
          context: {
            pointList: [[x, y], [x, nodeData.y]],
            strokeStyle: me.style,
            lineWidth: me.lineWidth
          }
        });

        me.sprite.addChild(_line);

        var _node = new _canvax["default"].Shapes.Circle({
          context: {
            x: x,
            y: y,
            r: me.radius,
            fillStyle: me.fillStyle,
            strokeStyle: me.style,
            lineWidth: me.lineWidth
          }
        });

        me.sprite.addChild(_node);
      }
    }
  }, {
    key: "_getNodeY",
    value: function _getNodeY(nodeData, _coord) {
      var appHeight = this.app.height;
      var coordHeight = _coord.height;
      var y = nodeData.y;

      if (this.status == "online") {
        y -= Math.min(50, (appHeight - Math.abs(y)) * 0.3);
      } else {
        y += Math.min(50, Math.abs(y) * 0.3);
      }
      return y;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        lineField: {
          detail: '对应的line字段',
          "default": null
        },
        style: {
          detail: '默认色',
          "default": '#3995ff'
        },
        fillStyle: {
          detail: '节点填充色',
          "default": "#ffffff"
        },
        lineWidth: {
          detail: '线宽',
          "default": 2
        },
        radius: {
          detail: '圆点半径',
          "default": 6
        },
        timeFontSize: {
          detail: '时间文本大小',
          "default": 14
        },
        timeFontColor: {
          detail: '时间文本颜色',
          "default": '#606060'
        },
        listFontSize: {
          detail: '列表信息文本大小',
          "default": 12
        }
      };
    }
  }]);
  return lineSchedu;
}(_component["default"]);

_component["default"].registerComponent(lineSchedu, 'lineSchedu');

var _default = lineSchedu;
exports["default"] = _default;
});

unwrapExports(lineschedu);

var markcloumn = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var Line = _canvax["default"].Shapes.Line;
var Circle = _canvax["default"].Shapes.Circle;
var Text = _canvax["default"].Display.Text;

var markCloumn = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(markCloumn, _Component);

  var _super = _createSuper(markCloumn);

  function markCloumn(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, markCloumn);
    _this = _super.call(this, opt, app);
    _this.name = "markcloumn";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(markCloumn.defaultProps()), opt);

    _this.sprite = new _canvax["default"].Display.Sprite();

    _this.app.graphsSprite.addChild(_this.sprite);

    _this._line = null;
    _this._lineSp = new _canvax["default"].Display.Sprite();

    _this.sprite.addChild(_this._lineSp);

    _this.nodes = [];
    _this._nodes = new _canvax["default"].Display.Sprite();

    _this.sprite.addChild(_this._nodes);

    _this._labels = new _canvax["default"].Display.Sprite();

    _this.sprite.addChild(_this._labels);

    return _this;
  }

  (0, _createClass2["default"])(markCloumn, [{
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {});
      this.width = opt.width;
      this.height = opt.height;
      this.origin = opt.origin;
      this.sprite.context.x = this.origin.x;
      this.sprite.context.y = this.origin.y;

      this._widget();
    }
  }, {
    key: "reset",
    value: function reset(opt) {
      opt && _.extend(true, this, opt);

      this._widget();
    }
  }, {
    key: "_widget",
    value: function _widget() {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      var _xAxis = _coord._xAxis;
      var xNode;

      if (this.xVal != null) {
        xNode = _xAxis.getNodeInfoOfVal(this.xVal);
      }

      if (this.xPixel != null) {
        xNode = _xAxis.getNodeInfoOfX(this.xPixel);
      }

      if (!xNode) {
        return;
      }
      me.nodes = [];
      me.on("complete", function () {
        me._drawLine(xNode);

        me._drawNodes(xNode);

        me._drawLabels(xNode);
      });
      var i = 0;

      var _graphs = this.app.getGraphs();

      _.each(_graphs, function (_g) {
        function _f() {
          i++;

          if (me.markTo && _.flatten([_g.field]).indexOf(me.markTo) == -1) ; else {
            var nodes = _g.getNodesOfPos(xNode.x);

            if (me.markTo) {
              var _node = _.find(nodes, function (node) {
                return node.field == me.markTo;
              });

              _node && (me.nodes = [_node]);
            } else {
              me.nodes = me.nodes.concat(nodes);
            }
          }

          if (i == _graphs.length) {
            me.fire("complete");
          }
        }

        if (_g.inited) {
          _f();
        } else {
          _g.on('complete', function () {
            _f();
          });
        }
      });
    }
  }, {
    key: "_drawLine",
    value: function _drawLine(xNode) {
      var me = this;
      if (!me.line.enabled) return;

      var lineOpt = _.extend(true, {
        x: parseInt(xNode.x),
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: -me.height
        },
        //默认贯穿整个画布
        lineWidth: 1,
        strokeStyle: "#cccccc"
      }, this.line);

      if (me.line.endY != null) {
        var y = 0;

        if (_.isNumber(me.line.endY)) {
          y = me.line.endY;
        }

        if (me.line.endY == 'auto') {
          _.each(me.nodes, function (node) {
            y = Math.min(node.y, y);
          });
        }
        lineOpt.end.y = y;
      }

      if (this._line) {
        _.extend(this._line.context, lineOpt);
      } else {
        this._line = new Line({
          context: lineOpt
        });

        this._lineSp.addChild(this._line);

        this._line.on(event.types.get(), function (e) {
          e.eventInfo = {
            //iNode : this.iNode,
            xAxis: {},
            nodes: me.nodes
          };

          if (me.xVal != null) {
            e.eventInfo.xAxis.value = me.xVal;
            e.eventInfo.xAxis.text = me.xVal + '';
            e.eventInfo.title = me.xVal + '';
          }
          me.app.fire(e.type, e);
        });
      }
    }
  }, {
    key: "_drawNodes",
    value: function _drawNodes() {
      var me = this;
      if (!me.node.enabled) return;

      me._nodes.removeAllChildren();

      _.each(me.nodes, function (nodeData) {
        var nodeCtx = _.extend({
          x: nodeData.x,
          y: nodeData.y,
          cursor: "pointer",
          r: me.node.radius,
          lineWidth: me.node.lineWidth || nodeData.lineWidth,
          strokeStyle: me.node.strokeStyle || nodeData.color,
          fillStyle: me.node.fillStyle || nodeData.fillStyle
        });

        var _node = new Circle({
          context: nodeCtx
        });

        _node.nodeData = nodeData;

        _node.on(event.types.get(), function (e) {
          e.eventInfo = {
            //iNode : this.iNode,
            xAxis: {},
            nodes: [nodeData]
          };

          if (me.xVal != null) {
            e.eventInfo.xAxis.value = me.xVal;
            e.eventInfo.xAxis.text = me.xVal + '';
            e.eventInfo.title = me.xVal + '';
          }
          me.app.fire(e.type, e);
        });

        me._nodes.addChild(_node);
      });
    }
  }, {
    key: "_drawLabels",
    value: function _drawLabels() {
      var me = this;
      if (!me.node.enabled) return;

      me._labels.removeAllChildren();

      _.each(me.nodes, function (nodeData) {
        var labelCtx = {
          x: nodeData.x,
          y: nodeData.y - me.node.radius - 2,
          fillStyle: me.label.fontColor || nodeData.color,
          fontSize: me.label.fontSize,
          textAlign: "center",
          textBaseline: "bottom"
        };
        var text = me.label.text;

        if (_.isFunction(text)) {
          text = text.apply(me, [nodeData]);
        }
        if (!text) return;

        var _label = new Text(text, {
          context: labelCtx
        });

        me._labels.addChild(_label); //矫正label位置，可能出去了,目前只做了最右侧的检测


        if (_label.localToGlobal().x + _label.getTextWidth() / 2 > me.app.width) {
          _label.context.x = me.app.width - _label.getTextWidth() / 2 - _label.parent.localToGlobal().x;
        }
      });
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        xVal: {
          detail: 'x的value值',
          "default": null
        },
        xPixel: {
          detail: 'x方向的具体像素值',
          "default": null
        },
        markTo: {
          detail: '标准哪个目标字段，主要用作折线图',
          documentation: '如果设置了这个字段，那么line的起点将是这个graphs上的node节点',
          "default": null
        },
        line: {
          detail: '线的配置',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": true
            },
            lineWidth: {
              detail: '线宽',
              "default": 2
            },
            strokeStyle: {
              detail: '线的颜色',
              "default": '#d5d5d5'
            },
            lineType: {
              detail: '线的样式，虚线(dashed)实线(solid)',
              "default": 'solid'
            },
            startY: {
              detail: 'startY',
              "default": 0
            },
            endY: {
              detail: 'startY',
              "default": null //'node'

            }
          }
        },
        node: {
          detail: '数据图形节点',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": true
            },
            radius: {
              detail: '节点半径',
              "default": 5
            },
            fillStyle: {
              detail: '节点图形的背景色',
              "default": '#ffffff'
            },
            strokeStyle: {
              detail: '节点图形的描边色，默认和line.strokeStyle保持一致',
              "default": null
            },
            lineWidth: {
              detail: '节点图形边宽大小',
              "default": 2
            }
          }
        },
        label: {
          detail: '文本',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": false
            },
            fontColor: {
              detail: '文本字体颜色',
              "default": null
            },
            fontSize: {
              detail: '文本字体大小',
              "default": 12
            },
            text: {
              detail: '文本内容',
              documentation: "可以是函数",
              "default": null
            },
            format: {
              detail: '文本格式化函数',
              "default": null
            }
          }
        }
      };
    }
  }]);
  return markCloumn;
}(_component["default"]);

_component["default"].registerComponent(markCloumn, 'markcloumn');

var _default = markCloumn;
exports["default"] = _default;
});

unwrapExports(markcloumn);

var vec2 = createCommonjsModule(function (module) {
(function inject(clean, precision, undef) {

  var isArray = function (a) {
    return Object.prototype.toString.call(a) === "[object Array]";
  };

  function Vec2(x, y) {
    if (!(this instanceof Vec2)) {
      return new Vec2(x, y);
    }

    if (isArray(x)) {
      y = x[1];
      x = x[0];
    } else if('object' === typeof x && x) {
      y = x.y;
      x = x.x;
    }

    this.x = Vec2.clean(x || 0);
    this.y = Vec2.clean(y || 0);
  }

  Vec2.prototype = {
    change : function(fn) {
      if (typeof fn === 'function') {
        if (this.observers) {
          this.observers.push(fn);
        } else {
          this.observers = [fn];
        }
      } else if (this.observers && this.observers.length) {
        for (var i=this.observers.length-1; i>=0; i--) {
          this.observers[i](this, fn);
        }
      }

      return this;
    },

    ignore : function(fn) {
      if (this.observers) {
        if (!fn) {
          this.observers = [];
        } else {
          var o = this.observers, l = o.length;
          while(l--) {
            o[l] === fn && o.splice(l, 1);
          }
        }
      }
      return this;
    },

    // set x and y
    set: function(x, y, notify) {
      if('number' != typeof x) {
        notify = y;
        y = x.y;
        x = x.x;
      }

      if(this.x === x && this.y === y) {
        return this;
      }

      var orig = null;
      if (notify !== false && this.observers && this.observers.length) {
        orig = this.clone();
      }

      this.x = Vec2.clean(x);
      this.y = Vec2.clean(y);

      if(notify !== false) {
        return this.change(orig);
      }
    },

    // reset x and y to zero
    zero : function() {
      return this.set(0, 0);
    },

    // return a new vector with the same component values
    // as this one
    clone : function() {
      return new (this.constructor)(this.x, this.y);
    },

    // negate the values of this vector
    negate : function(returnNew) {
      if (returnNew) {
        return new (this.constructor)(-this.x, -this.y);
      } else {
        return this.set(-this.x, -this.y);
      }
    },

    // Add the incoming `vec2` vector to this vector
    add : function(x, y, returnNew) {

      if (typeof x != 'number') {
        returnNew = y;
        if (isArray(x)) {
          y = x[1];
          x = x[0];
        } else {
          y = x.y;
          x = x.x;
        }
      }

      x += this.x;
      y += this.y;


      if (!returnNew) {
        return this.set(x, y);
      } else {
        // Return a new vector if `returnNew` is truthy
        return new (this.constructor)(x, y);
      }
    },

    // Subtract the incoming `vec2` from this vector
    subtract : function(x, y, returnNew) {
      if (typeof x != 'number') {
        returnNew = y;
        if (isArray(x)) {
          y = x[1];
          x = x[0];
        } else {
          y = x.y;
          x = x.x;
        }
      }

      x = this.x - x;
      y = this.y - y;

      if (!returnNew) {
        return this.set(x, y);
      } else {
        // Return a new vector if `returnNew` is truthy
        return new (this.constructor)(x, y);
      }
    },

    // Multiply this vector by the incoming `vec2`
    multiply : function(x, y, returnNew) {
      if (typeof x != 'number') {
        returnNew = y;
        if (isArray(x)) {
          y = x[1];
          x = x[0];
        } else {
          y = x.y;
          x = x.x;
        }
      } else if (typeof y != 'number') {
        returnNew = y;
        y = x;
      }

      x *= this.x;
      y *= this.y;

      if (!returnNew) {
        return this.set(x, y);
      } else {
        return new (this.constructor)(x, y);
      }
    },

    // Rotate this vector. Accepts a `Rotation` or angle in radians.
    //
    // Passing a truthy `inverse` will cause the rotation to
    // be reversed.
    //
    // If `returnNew` is truthy, a new
    // `Vec2` will be created with the values resulting from
    // the rotation. Otherwise the rotation will be applied
    // to this vector directly, and this vector will be returned.
    rotate : function(r, inverse, returnNew) {
      var
      x = this.x,
      y = this.y,
      cos = Math.cos(r),
      sin = Math.sin(r),
      rx, ry;

      inverse = (inverse) ? -1 : 1;

      rx = cos * x - (inverse * sin) * y;
      ry = (inverse * sin) * x + cos * y;

      if (returnNew) {
        return new (this.constructor)(rx, ry);
      } else {
        return this.set(rx, ry);
      }
    },

    // Calculate the length of this vector
    length : function() {
      var x = this.x, y = this.y;
      return Math.sqrt(x * x + y * y);
    },

    // Get the length squared. For performance, use this instead of `Vec2#length` (if possible).
    lengthSquared : function() {
      var x = this.x, y = this.y;
      return x*x+y*y;
    },

    // Return the distance betwen this `Vec2` and the incoming vec2 vector
    // and return a scalar
    distance : function(vec2) {
      var x = this.x - vec2.x;
      var y = this.y - vec2.y;
      return Math.sqrt(x*x + y*y);
    },

    // Given Array of Vec2, find closest to this Vec2.
    nearest : function(others) {
      var
      shortestDistance = Number.MAX_VALUE,
      nearest = null,
      currentDistance;

      for (var i = others.length - 1; i >= 0; i--) {
        currentDistance = this.distance(others[i]);
        if (currentDistance <= shortestDistance) {
          shortestDistance = currentDistance;
          nearest = others[i];
        }
      }

      return nearest;
    },

    // Convert this vector into a unit vector.
    // Returns the length.
    normalize : function(returnNew) {
      var length = this.length();

      // Collect a ratio to shrink the x and y coords
      var invertedLength = (length < Number.MIN_VALUE) ? 0 : 1/length;

      if (!returnNew) {
        // Convert the coords to be greater than zero
        // but smaller than or equal to 1.0
        return this.set(this.x * invertedLength, this.y * invertedLength);
      } else {
        return new (this.constructor)(this.x * invertedLength, this.y * invertedLength);
      }
    },

    // Determine if another `Vec2`'s components match this one's
    // also accepts 2 scalars
    equal : function(v, w) {
      if (typeof v != 'number') {
        if (isArray(v)) {
          w = v[1];
          v = v[0];
        } else {
          w = v.y;
          v = v.x;
        }
      }

      return (Vec2.clean(v) === this.x && Vec2.clean(w) === this.y);
    },

    // Return a new `Vec2` that contains the absolute value of
    // each of this vector's parts
    abs : function(returnNew) {
      var x = Math.abs(this.x), y = Math.abs(this.y);

      if (returnNew) {
        return new (this.constructor)(x, y);
      } else {
        return this.set(x, y);
      }
    },

    // Return a new `Vec2` consisting of the smallest values
    // from this vector and the incoming
    //
    // When returnNew is truthy, a new `Vec2` will be returned
    // otherwise the minimum values in either this or `v` will
    // be applied to this vector.
    min : function(v, returnNew) {
      var
      tx = this.x,
      ty = this.y,
      vx = v.x,
      vy = v.y,
      x = tx < vx ? tx : vx,
      y = ty < vy ? ty : vy;

      if (returnNew) {
        return new (this.constructor)(x, y);
      } else {
        return this.set(x, y);
      }
    },

    // Return a new `Vec2` consisting of the largest values
    // from this vector and the incoming
    //
    // When returnNew is truthy, a new `Vec2` will be returned
    // otherwise the minimum values in either this or `v` will
    // be applied to this vector.
    max : function(v, returnNew) {
      var
      tx = this.x,
      ty = this.y,
      vx = v.x,
      vy = v.y,
      x = tx > vx ? tx : vx,
      y = ty > vy ? ty : vy;

      if (returnNew) {
        return new (this.constructor)(x, y);
      } else {
        return this.set(x, y);
      }
    },

    // Clamp values into a range.
    // If this vector's values are lower than the `low`'s
    // values, then raise them.  If they are higher than
    // `high`'s then lower them.
    //
    // Passing returnNew as true will cause a new Vec2 to be
    // returned.  Otherwise, this vector's values will be clamped
    clamp : function(low, high, returnNew) {
      var ret = this.min(high, true).max(low);
      if (returnNew) {
        return ret;
      } else {
        return this.set(ret.x, ret.y);
      }
    },

    // Perform linear interpolation between two vectors
    // amount is a decimal between 0 and 1
    lerp : function(vec, amount, returnNew) {
      return this.add(vec.subtract(this, true).multiply(amount), returnNew);
    },

    // Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
    skew : function(returnNew) {
      if (!returnNew) {
        return this.set(-this.y, this.x)
      } else {
        return new (this.constructor)(-this.y, this.x);
      }
    },

    // calculate the dot product between
    // this vector and the incoming
    dot : function(b) {
      return Vec2.clean(this.x * b.x + b.y * this.y);
    },

    // calculate the perpendicular dot product between
    // this vector and the incoming
    perpDot : function(b) {
      return Vec2.clean(this.x * b.y - this.y * b.x);
    },

    // Determine the angle between two vec2s
    angleTo : function(vec) {
      return Math.atan2(this.perpDot(vec), this.dot(vec));
    },

    // Divide this vector's components by a scalar
    divide : function(x, y, returnNew) {
      if (typeof x != 'number') {
        returnNew = y;
        if (isArray(x)) {
          y = x[1];
          x = x[0];
        } else {
          y = x.y;
          x = x.x;
        }
      } else if (typeof y != 'number') {
        returnNew = y;
        y = x;
      }

      if (x === 0 || y === 0) {
        throw new Error('division by zero')
      }

      if (isNaN(x) || isNaN(y)) {
        throw new Error('NaN detected');
      }

      if (returnNew) {
        return new (this.constructor)(this.x / x, this.y / y);
      }

      return this.set(this.x / x, this.y / y);
    },

    isPointOnLine : function(start, end) {
      return (start.y - this.y) * (start.x - end.x) ===
             (start.y - end.y) * (start.x - this.x);
    },

    toArray: function() {
      return [this.x, this.y];
    },

    fromArray: function(array) {
      return this.set(array[0], array[1]);
    },
    toJSON: function () {
      return {x: this.x, y: this.y};
    },
    toString: function() {
      return '(' + this.x + ', ' + this.y + ')';
    },
    constructor : Vec2
  };

  Vec2.fromArray = function(array, ctor) {
    return new (ctor || Vec2)(array[0], array[1]);
  };

  // Floating point stability
  Vec2.precision = precision || 8;
  var p = Math.pow(10, Vec2.precision);

  Vec2.clean = clean || function(val) {
    if (isNaN(val)) {
      throw new Error('NaN detected');
    }

    if (!isFinite(val)) {
      throw new Error('Infinity detected');
    }

    if(Math.round(val) === val) {
      return val;
    }

    return Math.round(val * p)/p;
  };

  Vec2.inject = inject;

  if(!clean) {
    Vec2.fast = inject(function (k) { return k; });

    // Expose, but also allow creating a fresh Vec2 subclass.
    {
      module.exports = Vec2;
    }
  }
  return Vec2;
})();
});

var intersect = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lineLine = lineLine;
exports.lineRect = lineRect;

var _vec = interopRequireDefault(vec2);

/**
 * !#en Test line and line
 * !#zh 测试线段与线段是否相交
 * @method lineLine
 * @param {Vec2} a1 - The start point of the first line
 * @param {Vec2} a2 - The end point of the first line
 * @param {Vec2} b1 - The start point of the second line
 * @param {Vec2} b2 - The end point of the second line
 * @return {boolean}
 */
function lineLine(a1, a2, b1, b2) {
  // b1->b2向量 与 a1->b1向量的向量积
  var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x); // a1->a2向量 与 a1->b1向量的向量积

  var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x); // a1->a2向量 与 b1->b2向量的向量积

  var u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y); // u_b == 0时，角度为0或者180 平行或者共线不属于相交

  if (u_b !== 0) {
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;

    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
      return true;
    }
  }

  return false;
}
/**
 * !#en Test line and rect
 * !#zh 测试线段与矩形是否相交
 * @method lineRect
 * @param {Vec2} a1 - The start point of the line
 * @param {Vec2} a2 - The end point of the line
 * @param {Rect} b - The rect
 * @return {boolean}
 */


function lineRect(a1, a2, b) {
  var r0 = new _vec["default"](b.x, b.y);
  var r1 = new _vec["default"](b.x, b.yMax);
  var r2 = new _vec["default"](b.xMax, b.yMax);
  var r3 = new _vec["default"](b.xMax, b.y);
  if (lineLine(a1, a2, r0, r1)) return true;
  if (lineLine(a1, a2, r1, r2)) return true;
  if (lineLine(a1, a2, r2, r3)) return true;
  if (lineLine(a1, a2, r3, r0)) return true;
  return false;
}
});

unwrapExports(intersect);
var intersect_1$1 = intersect.lineLine;
var intersect_2 = intersect.lineRect;

var relation_backline = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;
var BrokenLine = _canvax["default"].Shapes.BrokenLine;
var Arrow = _canvax["default"].Shapes.Arrow;
var Text = _canvax["default"].Display.Text;
var Circle = _canvax["default"].Shapes.Circle;

var relationBackLine = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(relationBackLine, _Component);

  var _super = _createSuper(relationBackLine);

  function relationBackLine(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, relationBackLine);
    _this = _super.call(this, opt, app);
    _this.name = "relation_backline";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(relationBackLine.defaultProps()), opt);

    _this.pointList = null;
    _this.sprite = new _canvax["default"].Display.Sprite();
    _this._line = null;
    _this._arrow = null;
    _this._label = null;
    _this._icon = null;
    return _this;
  }

  (0, _createClass2["default"])(relationBackLine, [{
    key: "draw",
    value: function draw(opt) {
      !opt && (opt = {});
      this.width = opt.width;
      this.height = opt.height;
      this.origin = opt.origin;

      this._widget();
    }
  }, {
    key: "reset",
    value: function reset(opt) {
      opt && _.extend(true, this, opt);

      this._widget();
    }
  }, {
    key: "_widget",
    value: function _widget() {
      var _this2 = this;

      var _graphs = this.app.getGraphs();

      if (_graphs.length) {
        var _graph = _graphs[0];

        _graph.on('complete', function () {
          _this2._setPoints(_graph);

          _this2._drawLine();

          _this2._drawArrow();

          _this2._drawIcon();

          _graph.graphsSp.addChild(_this2.sprite);
        });
      }
    }
  }, {
    key: "_setPoints",
    value: function _setPoints(_graph) {
      if (!this.line.pointList) {
        var key = this.key;

        var beginNode = _graph.data.nodes.find(function (_g) {
          return _g.key == key.split(',')[0];
        });

        var beginNodeBBox = {
          x: beginNode.x - beginNode.width / 2,
          y: beginNode.y - beginNode.height / 2,
          width: beginNode.width,
          height: beginNode.height
        };

        var endNode = _graph.data.nodes.find(function (_g) {
          return _g.key == key.split(',')[1];
        });

        var endNodeBBox = {
          x: endNode.x - endNode.width / 2,
          y: endNode.y - endNode.height / 2,
          width: endNode.width,
          height: endNode.height
        };
        var fristPoint = [beginNodeBBox.x + beginNodeBBox.width, beginNodeBBox.y + beginNodeBBox.height / 2];
        var secondPoint = [beginNodeBBox.x + beginNodeBBox.width + 20, beginNodeBBox.y + beginNodeBBox.height / 2];
        var endPoint;
        var endNodePointX = endNodeBBox.x + endNodeBBox.width / 2;
        var endNodeTopPoint = [endNodePointX, endNodeBBox.y];
        var endNodeBottomPoint = [endNodePointX, endNodeBBox.y + endNodeBBox.height];
        endPoint = endNodeTopPoint;

        var getThroughNodesNum = function getThroughNodesNum(dissY) {
          var y = secondPoint[1] + dissY;
          var num = 0;

          _graph.data.nodes.forEach(function (node) {
            var rectX = node.x - node.width / 2;
            var rectY = node.y - node.height / 2;
            var nodeRect = {
              x: rectX,
              y: rectY,
              xMax: rectX + node.width,
              yMax: rectY + node.height
            };

            if ((0, intersect.lineRect)({
              x: secondPoint[0],
              y: y
            }, {
              x: endNodePointX,
              y: y
            }, nodeRect)) {
              num++;
            }
          });

          return num;
        };

        var dissY,
            topDissY,
            bottomDissY,
            lines = [];

        if (this.line.dissY == null) {
          topDissY = -(secondPoint[1] - (Math.min(endNodeBBox.y, beginNodeBBox.y) - 6));
          lines.push({
            dissY: topDissY,
            throughNodesNum: getThroughNodesNum(topDissY),
            endPoint: endNodeTopPoint,
            type: 'n'
          }); //如果发现两个节点中间有足够的间隙，还可以

          if (endNodeBBox.y - (beginNodeBBox.y + beginNodeBBox.height) > 20) {
            //向下连接 z 形状
            topDissY = beginNodeBBox.y + beginNodeBBox.height + (endNodeBBox.y - (beginNodeBBox.y + beginNodeBBox.height)) / 2 - secondPoint[1];
            lines.push({
              dissY: topDissY,
              throughNodesNum: getThroughNodesNum(topDissY),
              endPoint: endNodeTopPoint,
              type: 'down_z'
            });
          }

          var endBottomY = endNodeBottomPoint[1];
          bottomDissY = Math.max(endBottomY, beginNodeBBox.y + beginNodeBBox.height) + 6 - secondPoint[1];
          lines.push({
            dissY: bottomDissY,
            throughNodesNum: getThroughNodesNum(bottomDissY),
            endPoint: endNodeBottomPoint,
            type: 'u'
          });

          if (beginNodeBBox.y - endBottomY > 20) {
            //向上的z 形状连接
            bottomDissY = endBottomY + (beginNodeBBox.y - endBottomY) / 2 - secondPoint[1];
            lines.push({
              dissY: bottomDissY,
              throughNodesNum: getThroughNodesNum(bottomDissY),
              endPoint: endNodeBottomPoint,
              type: 'up_z'
            });
          }

          lines = lines.sort(function (a, b) {
            return a.throughNodesNum - b.throughNodesNum;
          }); //如果前面有几个是throughNodesNum相同的，组成一个小组，重新按照dissY的绝对值最小值排序

          var _lines = [];
          lines.forEach(function (line) {
            if (line.throughNodesNum == lines[0].throughNodesNum) {
              _lines.push(line);
            }
          });
          _lines = _lines.sort(function (a, b) {
            return Math.abs(a.dissY) - Math.abs(b.dissY);
          });
          dissY = _lines[0].dissY;
          endPoint = _lines[0].endPoint;
        } else {
          dissY = this.line.dissY;
        }
        var thirdPoint, secondLastPoint;
        thirdPoint = [secondPoint[0], secondPoint[1] + dissY];
        secondLastPoint = [endPoint[0], secondPoint[1] + dissY];
        this.pointList = [fristPoint, secondPoint, thirdPoint, secondLastPoint, endPoint];
      } else {
        this.pointList = this.line.pointList;
      }
    }
  }, {
    key: "_drawLine",
    value: function _drawLine() {
      var me = this;
      if (!me.line.enabled) return;
      var lineOpt = {
        pointList: this.pointList,
        lineWidth: this.line.lineWidth,
        strokeStyle: this.line.strokeStyle,
        lineType: this.line.lineType
      };

      if (this._line) {
        _.extend(this._line.context, lineOpt);
      } else {
        this._line = new BrokenLine({
          context: lineOpt
        });
        this.sprite.addChild(this._line);
      }
    }
  }, {
    key: "_drawArrow",
    value: function _drawArrow() {
      var pointsList = this.pointList;
      var offsetY = 2;
      var endPoint = pointsList[pointsList.length - 1];
      var secondLastPoint = pointsList[pointsList.length - 2];

      if (secondLastPoint[1] < endPoint[1]) {
        offsetY = -2;
      }

      var strokeStyle = this.line.strokeStyle;
      var ctx = {
        y: offsetY,
        control: {
          x: secondLastPoint[0],
          y: secondLastPoint[1]
        },
        point: {
          x: endPoint[0],
          y: endPoint[1]
        },
        strokeStyle: strokeStyle,
        fillStyle: strokeStyle
      };

      if (this._arrow) {
        _.extend(true, this._arrow.context, ctx); // this._line.context.y = ctx.y;
        // this._line.context.control.x = ctx.control.x;
        // this._line.context.control.y = ctx.control.y;
        // this._line.context.point.x = ctx.point.x;
        // this._line.context.point.y = ctx.point.y;
        // this._line.context.strokeStyle = ctx.strokeStyle;
        // this._line.context.fillStyle = ctx.fillStyle;

      } else {
        this._arrow = new Arrow({
          context: ctx
        });
        this.sprite.addChild(this._arrow);
      }
    }
  }, {
    key: "_drawIcon",
    value: function _drawIcon() {
      var me = this;

      if (this.icon.enabled) {
        var _chartCode = this._getProp(this.icon.charCode, this);

        var charCode = String.fromCharCode(parseInt(_chartCode, 16));

        if (_chartCode != '') {
          var secondPoint = this.pointList[1];

          var lineWidth = this._getProp(this.icon.lineWidth, this);

          var strokeStyle = this._getProp(this.icon.strokeStyle, this);

          var fontFamily = this._getProp(this.icon.fontFamily, this);

          var fontSize = this._getProp(this.icon.fontSize, this);

          var fontColor = this._getProp(this.icon.fontColor, this);

          var background = this._getProp(this.icon.background, this);

          var textAlign = 'center';
          var textBaseline = 'middle';

          var offset = this._getProp(this.icon.offset, this);

          var offsetX = this._getProp(this.icon.offsetX, this);

          var offsetY = this._getProp(this.icon.offsetY, this);

          if (!offset) {
            //default 使用edge.x edge.y 也就是edge label的位置
            offset = {
              x: secondPoint[0] + offsetX,
              y: secondPoint[1] + offsetY
            };
          }
          var _iconBackCtx = {
            x: offset.x,
            y: offset.y - 1,
            r: parseInt(fontSize * 0.5) + 2,
            fillStyle: background,
            strokeStyle: strokeStyle,
            lineWidth: lineWidth
          };

          if (this._iconBack) {
            //_.extend( true, _iconBack.context, _iconBackCtx )
            Object.assign(this._iconBack.context, _iconBackCtx);
          } else {
            this._iconBack = new Circle({
              context: _iconBackCtx
            });
            this.sprite.addChild(this._iconBack);
          }

          if (this._icon) {
            this._icon.resetText(charCode);

            this._icon.context.x = offset.x;
            this._icon.context.y = offset.y;
            this._icon.context.fontSize = fontSize;
            this._icon.context.fillStyle = fontColor;
            this._icon.context.textAlign = textAlign;
            this._icon.context.textBaseline = textBaseline;
            this._icon.context.fontFamily = fontFamily;
            this._icon.context.lineWidth = lineWidth;
            this._icon.context.strokeStyle = strokeStyle;
          } else {
            this._icon = new Text(charCode, {
              context: {
                x: offset.x,
                y: offset.y,
                fillStyle: fontColor,
                cursor: 'pointer',
                fontSize: fontSize,
                textAlign: textAlign,
                textBaseline: textBaseline,
                fontFamily: fontFamily,
                lineWidth: lineWidth,
                strokeStyle: strokeStyle
              }
            });

            this._icon.on(event.types.get(), function (e) {
              var trigger = me.line;

              if (me.icon['on' + e.type]) {
                trigger = me.icon;
              }
              e.eventInfo = {
                trigger: trigger,
                nodes: [{
                  name: me.key
                }]
              };
              me.app.fire(e.type, e);
            });

            me.sprite.addChild(this._icon);
          }
        }
      }
    }
  }, {
    key: "_getProp",
    value: function _getProp(prop, nodeData) {
      var _prop = prop;

      if (_.isFunction(prop)) {
        _prop = prop.apply(this, [nodeData]);
      }
      return _prop;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        key: {
          detail: '和relation的line保持一致，用逗号分割',
          "default": null
        },
        line: {
          detail: '线的配置',
          propertys: {
            enabled: {
              detail: '是否开启',
              "default": true
            },
            pointList: {
              detail: '回链线的points',
              "default": null
            },
            lineWidth: {
              detail: '线宽',
              "default": 1
            },
            strokeStyle: {
              detail: '线的颜色',
              "default": '#e5e5e5'
            },
            lineType: {
              detail: '线的样式，虚线(dashed)实线(solid)',
              "default": 'solid'
            },
            dissY: {
              detail: '拐点和起始节点的距离',
              "default": null
            }
          }
        },
        icon: {
          detail: 'line上面的icon',
          propertys: {
            enabled: {
              detail: '是否开启线上的icon设置',
              "default": true
            },
            charCode: {
              detail: 'iconfont上面对应的unicode中&#x后面的字符',
              "default": null
            },
            lineWidth: {
              detail: 'icon描边线宽',
              "default": 1
            },
            strokeStyle: {
              detail: 'icon的描边颜色',
              "default": '#e5e5e5'
            },
            fontColor: {
              detail: 'icon的颜色',
              "default": '#e5e5e5'
            },
            fontFamily: {
              detail: 'font-face的font-family设置',
              "default": 'iconfont'
            },
            fontSize: {
              detail: 'icon的字体大小',
              "default": 14
            },
            offset: {
              detail: 'icon的位置，函数，参数是整个edge对象',
              "default": null
            },
            offsetX: {
              detail: '在计算出offset后的X再次便宜量',
              "default": 1
            },
            offsetY: {
              detail: '在计算出offset后的Y再次便宜量',
              "default": 2
            },
            background: {
              detail: 'icon的背景颜色，背景为圆形',
              "default": "#fff"
            }
          }
        }
      };
    }
  }]);
  return relationBackLine;
}(_component["default"]);

_component["default"].registerComponent(relationBackLine, 'relation_backline');

var _default = relationBackLine;
exports["default"] = _default;
});

unwrapExports(relation_backline);

var title = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);

var _trigger = interopRequireDefault(trigger);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._,
    event = _canvax["default"].event;

var Title = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(Title, _Component);

  var _super = _createSuper(Title);

  function Title(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, Title);
    _this = _super.call(this, opt, app);
    _this.name = "title";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(Title.defaultProps()), opt);

    _this.sprite = new _canvax["default"].Display.Sprite({
      id: "titleSprite",
      context: {}
    });

    _this.app.stage.addChild(_this.sprite);

    _this.widget(); //图例是需要自己绘制完成后，才能拿到高宽来设置自己的位置


    _this.layout();

    return _this;
  }

  (0, _createClass2["default"])(Title, [{
    key: "widget",
    value: function widget() {
      var textAlign = "left";

      if (this.text) {
        var txtStyle = this._getProp(this.textStyle) || {};
        var txt = new _canvax["default"].Display.Text(this.text, {
          id: "title_txt",
          context: {
            x: this.margin.left,
            y: this.margin.top,
            fillStyle: txtStyle.fontColor || this.text.fontColor,
            fontSize: this.text.fontSize,
            textAlign: textAlign,
            textBaseline: 'bottom'
          }
        });

        for (var p in txtStyle) {
          if (p in txt.context) {
            txt.context[p] = txtStyle[p];
          }
        }
        this.sprite.addChild(txt);
        this.width += txt.getTextWidth() + 6;
        this.height += txt.getTextHeight();
        txt.context.y = this.height;
      }

      if (this.desc) {
        var descStyle = this._getProp(this.descStyle) || {};
        var desc = new _canvax["default"].Display.Text(this.desc, {
          id: "title_txt",
          context: {
            x: this.width + this.margin.left,
            y: this.height,
            fillStyle: descStyle.fontColor || this.text.fontColor,
            fontSize: this.text.fontSize,
            textAlign: textAlign,
            textBaseline: 'bottom'
          }
        });

        for (var _p in descStyle) {
          if (_p in desc.context) {
            desc.context[_p] = descStyle[_p];
          }
        }

        this.sprite.addChild(desc);
        this.width += desc.getTextWidth();
        this.height = Math.max(desc.getTextHeight(), this.height);
        desc.context.y = this.height;
      }
    }
  }, {
    key: "layout",
    value: function layout() {
      var app = this.app;
      var height = this.height + this.margin.top + this.margin.bottom;
      var x = app.padding.left;
      var y = app.padding.top;

      if (this.position == "top-left") {
        x = app.padding.left;
      }

      if (this.position == "top-right") {
        x = app.width - app.padding.right - this.margin.right - this.width;
      }
      app.padding.top += height;
      this.pos = {
        x: x,
        y: y
      };
      return this.pos;
    }
  }, {
    key: "draw",
    value: function draw() {
      //为了在直角坐标系中，让 textAlign left的时候，图例和坐标系左侧对齐， 好看点, 用心良苦啊
      var _coord = this.app.getComponent({
        name: 'coord'
      });

      if (_coord && _coord.type == 'rect') {
        if (this.position == 'top-right') ; else {
          this.pos.x = _coord.getSizeAndOrigin().origin.x;
        }
      }
      this.setPosition();
    }
  }, {
    key: "_getProp",
    value: function _getProp(prop, nodeData) {
      var _prop = prop;

      if (_.isArray(prop)) {
        _prop = prop[nodeData.ind];
      }

      if (_.isFunction(prop)) {
        _prop = prop.apply(this, [nodeData]);
      }
      return _prop;
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        position: {
          detail: '图例位置',
          documentation: '默认top-left,可选top-right',
          "default": 'top-left'
        },
        text: {
          detail: '标题内容',
          "default": ''
        },
        textStyle: {
          detail: '主标题样式',
          propertys: {
            fontColor: {
              detail: '字体颜色',
              "default": '#666'
            },
            fontSize: {
              detail: '字体大小',
              "default": '14'
            },
            style: {
              detail: '样式集合',
              "default": null
            }
          }
        },
        desc: {
          detail: '描述内容',
          "default": ''
        },
        descStyle: {
          detail: '描述的样式',
          propertys: {
            fontColor: {
              detail: '字体颜色',
              "default": '#999'
            },
            fontSize: {
              detail: '字体大小',
              "default": '12'
            },
            style: {
              detail: '样式集合',
              "default": null
            }
          }
        },
        margin: {
          propertys: {
            bottom: {
              "default": 10
            }
          }
        }
      };
    }
  }]);
  return Title;
}(_component["default"]);

_component["default"].registerComponent(Title, 'title');

var _default = Title;
exports["default"] = _default;
});

unwrapExports(title);

var linemarkpoint = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = interopRequireDefault(classCallCheck$1);

var _createClass2 = interopRequireDefault(createClass$1);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized$1);

var _inherits2 = interopRequireDefault(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault(getPrototypeOf$1);

var _component = interopRequireDefault(component);

var _canvax = interopRequireDefault(Canvax);



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _ = _canvax["default"]._;
var Rect = _canvax["default"].Shapes.Rect;

var lineMarkPoint = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(lineMarkPoint, _Component);

  var _super = _createSuper(lineMarkPoint);

  function lineMarkPoint(opt, app) {
    var _this;

    (0, _classCallCheck2["default"])(this, lineMarkPoint);
    _this = _super.call(this, opt, app);
    _this.name = "lineMarkPoint";

    _.extend(true, (0, _assertThisInitialized2["default"])(_this), (0, tools.getDefaultProps)(lineMarkPoint.defaultProps()), opt);

    _this.lineDatas = null;
    _this.sprite = new _canvax["default"].Display.Sprite();

    _this.app.graphsSprite.addChild(_this.sprite);

    return _this;
  }

  (0, _createClass2["default"])(lineMarkPoint, [{
    key: "reset",
    value: function reset(opt) {
      _.extend(true, this, opt);

      this.lineDatas = null;
      this.sprite.removeAllChildren();
      this.draw();
    }
  }, {
    key: "draw",
    value: function draw() {
      var me = this;

      var _coord = this.app.getComponent({
        name: 'coord'
      });

      this.pos = {
        x: _coord.origin.x,
        y: _coord.origin.y
      };
      this.setPosition();
      var lineGraphs = me.app.getComponent({
        name: 'graphs',
        type: "line",
        field: me.lineField
      });
      me.lineDatas = lineGraphs.data[me.lineField].data;
      var iNode = this.app.getComponent({
        name: "coord"
      }).getAxis({
        type: "xAxis"
      }).getIndexOfVal(this.xValue);

      if (iNode == -1) {
        return;
      }
      var nodeData = this.lineDatas[iNode];
      var preNodeData = iNode ? this.lineDatas[iNode - 1] : null;
      var nextNodeData = iNode == me.lineDatas.length ? null : this.lineDatas[iNode + 1];

      if (nodeData.y != undefined) {
        var x = nodeData.x;

        var _txtSp = new _canvax["default"].Display.Sprite({
          context: {
            x: x
          }
        });

        this.sprite.addChild(_txtSp);
        var txtHeight = 0;

        var _label = new _canvax["default"].Display.Text(me.label.text, {
          context: {
            fillStyle: this.label.fontColor,
            fontSize: this.label.fontSize,
            textAlign: 'center',
            textBaseline: 'top'
          }
        });

        _txtSp.addChild(_label);

        txtHeight = _label.getTextHeight();

        var txtWidth = _label.getTextWidth();

        var _bgRect;

        var padding = 0; //如果有背景，那么就要加上背景的padding

        if (this.label.background.enabled) {
          padding = this.label.background.padding;
          txtHeight += padding * 2;
          txtWidth += padding * 2;
          _txtSp.context.x -= padding; //sp的y会在下面单独计算好

          _label.context.x += padding;
          _label.context.y += padding;
          var r = me.label.background.radius; //添加一下背景

          _bgRect = new Rect({
            context: {
              x: -txtWidth / 2 + padding,
              width: txtWidth,
              height: txtHeight,
              radius: [r, r, r, r],
              fillStyle: me.label.background.fillStyle,
              strokeStyle: me.label.background.strokeStyle,
              lineWidth: me.label.background.lineWidth
            }
          });

          _txtSp.addChild(_bgRect, 0);
        }

        if (txtWidth / 2 + x > _coord.width) {
          _txtSp.context.x = _coord.width;
          _label.context.textAlign = "right";
          _bgRect && (_bgRect.context.x -= txtWidth / 2 - padding);
        }

        if (x - txtWidth / 2 < 0) {
          _txtSp.context.x = 0;
          _label.context.textAlign = "left";
          _bgRect && (_bgRect.context.x += txtWidth / 2 - padding);
        }

        var _me$_getNodeYandLineP = me._getNodeYandLinePointList(nodeData, preNodeData, nextNodeData, _coord, txtHeight),
            y = _me$_getNodeYandLineP.y,
            pointList = _me$_getNodeYandLineP.pointList;

        _txtSp.context.y = y;

        if (me.line.enabled) {
          var _line = new _canvax["default"].Shapes.BrokenLine({
            context: {
              pointList: pointList,
              strokeStyle: me.line.strokeStyle,
              lineWidth: me.line.lineWidth
            }
          });

          me.sprite.addChild(_line, 0);
        }
      }
    }
  }, {
    key: "_getNodeYandLinePointList",
    value: function _getNodeYandLinePointList(nodeData, preNodeData, nextNodeData, _coord, txtHeight) {
      var appHeight = this.app.height;
      var coordHeight = _coord.height;
      var y = nodeData.y;
      var lineLength = !this.line.enabled ? 3 : this.line.lineLength;
      var lineDis = this.line.lineDis; //line到node的距离

      var position = "online";

      if (this.position == 'auto') {
        if (preNodeData && preNodeData.y < nodeData.y || nextNodeData && nextNodeData.y < nodeData.y) {
          position = 'offline'; //在线的下方
        }

        if (position == "online" && Math.abs(y) + lineLength + lineDis + txtHeight > coordHeight) {
          //在上面但是超过了坐标系顶部空间
          position = "offline";
        }

        if (position == "offline" && Math.abs(y) < lineLength + txtHeight + lineDis) {
          //在线下面，但是超出了坐标系底部空间
          position = "online";
        }
      } else {
        position = this.position;
      }
      var top = 0;

      if (position == "online") {
        top = y - lineLength - lineDis - txtHeight;
      } else {
        top = y + lineDis + lineLength;
      }

      var pointList = [[nodeData.x, top], [nodeData.x, nodeData.y + lineDis]];

      if (position == "online") {
        pointList = [[nodeData.x, top + txtHeight], [nodeData.x, nodeData.y - lineDis]];
      }
      return {
        y: top,
        pointList: pointList
      };
    }
  }], [{
    key: "defaultProps",
    value: function defaultProps() {
      return {
        lineField: {
          detail: '对应的line字段',
          "default": null
        },
        xValue: {
          detail: '在lineFile字段的折线上对应点的x轴的值',
          "default": null
        },
        line: {
          detail: 'line的配置',
          propertys: {
            enabled: {
              detail: '是否要指示线',
              "default": true
            },
            lineWidth: {
              detail: '线宽',
              "default": 2
            },
            strokeStyle: {
              detail: '线颜色',
              "default": '#ccc'
            },
            lineLength: {
              detail: '线的长度，也就是label到line的距离',
              "default": 8
            },
            lineDis: {
              detail: 'line到折线上面node的距离',
              "default": 3
            }
          }
        },
        label: {
          detail: 'markpoint标注的文本配置',
          propertys: {
            text: {
              detail: 'label内容',
              "default": ''
            },
            fontSize: {
              detail: 'label的文本大小',
              "default": 12
            },
            fontColor: {
              detail: '文本颜色',
              "default": '#666'
            },
            background: {
              detail: 'label的background配置',
              propertys: {
                enabled: {
                  detail: 'label是否需要背景',
                  "default": true
                },
                fillStyle: {
                  detail: 'label的背景颜色',
                  "default": '#f5f5f6'
                },
                radius: {
                  detail: 'label的背景圆角',
                  "default": 6
                },
                strokeStyle: {
                  detail: 'label的背景边框颜色',
                  "default": '#f5f5f6'
                },
                lineWidth: {
                  detail: '背景描边',
                  "default": 1
                },
                padding: {
                  detail: 'background和label之间的距离',
                  "default": 6
                }
              }
            }
          }
        },
        position: {
          detail: '在线的方向，online（线上边） or offline（线下方），默认自动计算',
          "default": 'auto'
        }
      };
    }
  }]);
  return lineMarkPoint;
}(_component["default"]);

_component["default"].registerComponent(lineMarkPoint, 'lineMarkPoint');

var _default = lineMarkPoint;
exports["default"] = _default;
});

unwrapExports(linemarkpoint);

var dist = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _global = interopRequireDefault(global$1);







































































//2d图表元类
//-----------------------------------------------
//坐标系
//-----------------------------------------------
//graphs
// //-----------------------------------------------
// //布局算法
// import "./layout/dagre/index"
// import "./layout/tree/index"
//-----------------------------------------------
//components
//皮肤设定begin ---------------
//如果数据库中有项目皮肤
var projectTheme = []; //从数据库中查询出来设计师设置的项目皮肤

if (projectTheme && projectTheme.length) {
  _global["default"].setGlobalTheme(projectTheme);
}

var chartx = {
  version: '1.1.142',
  options: {}
};

for (var p in _global["default"]) {
  chartx[p] = _global["default"][p];
}
var _default = chartx;
exports["default"] = _default;
});

var index$3 = unwrapExports(dist);

module.exports = index$3;
